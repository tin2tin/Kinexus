<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kinexus</title>
		<style>
		:root {
			--primary-color: #4a78ad; --secondary-color: #6c757d; --light-bg: #121212;
			--dark-text: #e0e0e0; --border-color: #333333; --success-color: #5a8f66;
			--danger-color: #b85a66; --warning-color: #c7921a; --warning-text: #ffffff;
			--purple-color: #8e63a9;

			/* Styles from Choice UI Template */
			--bg-main: #131316; --bg-container: #1e1e22; --bg-element: #2c2d30;
			--text-primary: #e1e1e1; --text-secondary: #9e9ea5;
			--accent-color-primary: #5FB5AC;
			--accent-color-secondary: #5FB5AC;
			--title-underline-color: #4A78AD;
			--condition-icon-color: #5FB5AC;
            --canvas-bg: #131316; /* For edge label background */

            /* New colors for node headers and tags from React script */
            --header-none-bg: #4a4a4f;
            --header-image-bg: #4A78AD;
            --header-video-bg: #8e63a9;
            --color-tag-blue: #4a78ad;
            --color-tag-green: #5f876f;
            --color-tag-orange: #b8855a;
		}
		body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; display: flex; height: 100vh; margin: 0; background-color: var(--light-bg); color: var(--dark-text); font-size: 16px; overflow: hidden; }
		::-webkit-scrollbar { width: 12px; height: 12px; }
		::-webkit-scrollbar-track { background: #1e1e1e; }
		::-webkit-scrollbar-thumb { background-color: #444; border-radius: 6px; border: 2px solid #1e1e1e; }
		::-webkit-scrollbar-thumb:hover { background-color: #555; }
		html { scrollbar-color: #444 #1e1e1e; }

		#main-layout-container { display: flex; width: 100%; height: 100%; }

		#left-panel-container {
			width: 25%;
			background-color: #1e1e1e;
			padding: 15px;
			display: flex;
			flex-direction: column;
			overflow: hidden;
			position: relative;
		}
		#resizer {
			width: 5px;
			height: 100%;
			background: var(--border-color);
			cursor: col-resize;
			flex-shrink: 0;
			z-index: 100;
			user-select: none;
		}
		#editor-container {
            position: relative; /* Added for player positioning */
            flex-grow: 1;
            padding: 0 20px 20px;
            overflow-y: auto;
            background-color: var(--light-bg);
        }
		#editor-container fieldset { border: none; padding: 0; margin: 0; }
		#editor-container fieldset:disabled { opacity: 0.5; pointer-events: none; }
		#player-container {
			display: none;
			position: absolute; /* Changed for positioning within editor-container */
			top: 0; left: 0;
			width: 100%; height: 100%;
			overflow: auto;
			justify-content: center;
			align-items: center;
			z-index: 2000;
			/* FIX: Player background image fix */
			background-size: cover;
			background-repeat: no-repeat;
			background-position: center;
			font-family: var(--font-family); /* FIX: Apply selected font to player */
			font-size: var(--font-size); /* <-- ADD THIS LINE */
		}
		#player-container.layout-panel-bottom {
			align-items: flex-end;
			padding: 20px;
			box-sizing: border-box;
		}
		#player-container.layout-panel-left {
			justify-content: flex-start;
		}
		#player-container.layout-panel-right {
			justify-content: flex-end;
		}

		/* Dark Scrollbar for Inner Content Panes */
		#player-inner-container::-webkit-scrollbar,
		#scene-editor-preview #preview-player-inner-container::-webkit-scrollbar {
			width: 12px;
		}

		#player-inner-container::-webkit-scrollbar-track,
		#scene-editor-preview #preview-player-inner-container::-webkit-scrollbar-track {
			background: #1e1e1e;
			border-radius: 8px;
		}

		#player-inner-container::-webkit-scrollbar-thumb,
		#scene-editor-preview #preview-player-inner-container::-webkit-scrollbar-thumb {
			background-color: #444;
			border-radius: 6px;
			border: 2px solid #1e1e1e;
		}

		#player-inner-container::-webkit-scrollbar-thumb:hover,
		#scene-editor-preview #preview-player-inner-container::-webkit-scrollbar-thumb:hover {
			background-color: #555;
		}

		h1, h2, h3 { border-bottom: 2px solid var(--primary-color); padding-bottom: 5px; margin-top: 0; }
		#variable-manager-modal h3 { border-bottom: none !important; }
		#editor-container h1 { margin-top: 20px; }
		.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; margin-top: 15px; }
		.header h1 { white-space: nowrap; border-bottom: none; } /* FIX: Removed underline */
		.header h2 { margin-bottom: 0; }
		.header h3 { border-bottom: none; }
		#save-project-dirty-btn {
			display: none; /* JS toggles this to inline-flex */
			padding: 6px;
			margin-left: 10px;
			line-height: 1;
			min-width: 0;
			width: 32px;
			height: 32px;
			border-radius: 50%;
			vertical-align: middle;
		}

		hr { border: none; border-top: 1px solid var(--border-color); margin: 15px 0; }

		/* --- NEW: Node Editor Styles --- */
		#node-editor-view {
			flex-grow: 1;
			position: relative;
			overflow: hidden;
			background-color: #131316;
            background-image: radial-gradient(rgba(60, 61, 64, 0.7) 0.5px, transparent 0);
			cursor: grab;
			border: 1px solid var(--border-color);
			border-radius: 4px;
			margin-top: 10px;
		}
		#node-editor-view.grabbing { cursor: grabbing; }
        #transform-pane {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
        }
        #node-element-container {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }
		.node-editor-node {
			position: absolute;
			background: #2c2d30;
			border: 1px solid #444;
			border-radius: 6px;
			width: 240px;
			font-size: 13px;
			text-align: left;
			overflow: visible; /* Allow handles to be visible */
			box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			cursor: default;
			display: flex;
			flex-direction: column;
			transition: border-color 0.3s, box-shadow 0.2s;
            pointer-events: all;
		}
        .node-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--primary-color);
            border: 2px solid var(--bg-element);
            border-radius: 50%;
            z-index: 10;
            cursor: crosshair;
        }
         .node-handle:hover {
            transform: scale(1.2);
            background: #fff;
        }
        .node-handle-top { top: -7px; left: 50%; transform: translateX(-50%); }
        .node-handle-bottom { bottom: -7px; left: 50%; transform: translateX(-50%); }

        .node-handle-top:hover { transform: translateX(-50%) scale(1.2); }
        .node-handle-bottom:hover { transform: translateX(-50%) scale(1.2); }

		.node-editor-node.selected { border: 2px solid var(--primary-color); box-shadow: 0 0 10px var(--primary-color); }
		.node-editor-node.has-broken-link { border: 2px dashed var(--danger-color) !important; }
		.node-editor-node.is-filtered-out { /* Opacity removed */ pointer-events: none; filter: grayscale(80%); }

		.node-header { padding: 8px 12px; font-weight: bold; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #444; cursor: move; user-select: none; background-color: var(--header-none-bg); color: #fff; transition: background-color 0.3s; border-radius: 5px 5px 0 0; }
        .node-header.media-image { background-color: var(--header-image-bg); }
        .node-header.media-video { background-color: var(--header-video-bg); }
		.node-body { padding: 12px; transition: border-left 0.3s; background-color: var(--bg-element); }
		.node-thumbnail { width: 100%; aspect-ratio: 16/9; background-color: #111; border-radius: 4px; display: flex; justify-content: center; align-items: center; font-size: 0.8em; color: var(--text-secondary); overflow: hidden; border: 1px solid #444; margin-bottom: 8px; }
		.node-thumbnail img, .node-thumbnail canvas { width: 100%; height: 100%; object-fit: cover; }
        .node-thumbnail svg { width: 48px; height: 48px; color: var(--text-secondary); opacity: 0.5; }
		.node-text-display { color: #aaa; max-height: 80px; overflow-y: auto; white-space: pre-wrap; word-break: break-word; }
		.node-text-display::-webkit-scrollbar { width: 8px; }
		.node-text-display::-webkit-scrollbar-thumb { background-color: #444; }

		.node-footer { padding: 8px 12px; background-color: rgba(0,0,0,0.2); border-top: 1px solid #444; display: flex; justify-content: space-between; align-items: center; font-size: 11px; border-radius: 0 0 5px 5px; }
		.node-icons { display: flex; gap: 8px; align-items: center; }
		.node-icons .icon-group { display: flex; align-items: center; gap: 2px; }
		.node-icons svg, .scene-card-icon { width: 16px; height: 16px; flex-shrink: 0; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
		.icon-start { color: var(--success-color); }
		.icon-image, .icon-video, .icon-video-loop { color: #8ab4f8; }
		.icon-sound, .icon-audio-loop { color: #fdd663; }
		.icon-deadend { color: var(--danger-color); }
		.icon-condition { color: var(--condition-icon-color); }
		.icon-orphan { color: #fff; }

		.choice-count-icon { background-color: #6c757d; color: white; border-radius: 50%; width: 18px; height: 18px; display: inline-flex; justify-content: center; align-items: center; font-size: 11px; font-weight: bold; line-height: 1; flex-shrink: 0; }
		#node-svg-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: visible; }
        #edge-group-container { transform-origin: 0 0; }
		.node-handle {background: #6c757d; /* Default to grey */}
		.node-handle.is-connected {
			background: var(--primary-color); /* Make connected handles blue */
		}
		#node-svg-layer .edge-path {
			stroke: #888; /* Lighter grey for normal connections */
			stroke-width: 3;
			fill: none !important;
		}
		#node-svg-layer .edge-path.edge-path-loopback {
			stroke: #6c757d; /* Darker grey for loopback */
			stroke-dasharray: 6, 6;
		}
        #node-svg-layer .edge-hitbox { stroke: transparent; stroke-width: 12; fill: none; }
        #node-svg-layer .edge-group:hover .edge-path { stroke: var(--primary-color); stroke-width: 4; }
		#node-svg-layer .edge-path.is-filtered-out { stroke: #444; }
		#node-svg-layer .edge-arrow { fill: #555; transition: fill 0.2s; }
        #node-svg-layer .edge-group:hover .edge-arrow { fill: var(--primary-color); }
		#node-svg-layer .edge-arrow.is-filtered-out { fill: #444; }
        #temp-edge { stroke: var(--primary-color); stroke-width: 2; stroke-dasharray: 5,5; fill: none; pointer-events: none; }
		#node-editor-controls {
			position: absolute;
			bottom: 10px;
			left: 10px;
			display: flex;
			gap: 8px;
			z-index: 10;
		}
		#node-editor-controls button {
			background-color: rgba(44, 45, 48, 0.8);
			border: 1px solid #444;
			backdrop-filter: blur(5px);
			padding: 8px;
			min-width: 36px;
		}

        /* --- STYLES FOR EDGE LABELS --- */
        #node-svg-layer .edge-group {
            cursor: pointer;
            pointer-events: all; /* Make the group clickable */
        }
        #node-svg-layer .edge-label {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 12px;
            fill: var(--text-primary);
            text-anchor: middle; /* Center the text */
            dominant-baseline: middle;
            pointer-events: none; /* Text should not block clicks on the group */
            transition: fill 0.2s;
        }
        #node-svg-layer .edge-group:hover .edge-label { fill: #fff; }
        #node-svg-layer .edge-label-bg {
            fill: var(--canvas-bg);
            stroke: var(--border-color);
            stroke-width: 1px;
            pointer-events: none;
            transition: fill 0.2s;
        }
        #node-svg-layer .edge-group:hover .edge-label-bg {
            fill: var(--primary-color);
        }

        /* Style for the temporary text editor */
        #edge-text-editor {
            position: absolute;
            z-index: 1001; /* Ensure it's on top of everything */
            padding: 4px;
            font-size: 12px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            border: 1px solid var(--primary-color);
            background-color: var(--bg-element);
            color: var(--text-primary);
            border-radius: 3px;
        }


		/* Scene List View Styles */
		#scene-list-view-wrapper { display: none; flex-direction: column; flex-grow: 1; min-height: 0; }
		#scene-list-view { list-style-type: none; padding-left: 0; flex-grow: 1; overflow: auto; min-height: 100px; margin-top: 10px; }
		#scene-list-controls { display: flex; justify-content: flex-end; align-items: center; gap: 10px; margin-top: 10px; flex-shrink: 0; }
		#scene-list-sort { background-color: #1e1e1e; color: var(--dark-text); border: 1px solid #444; border-radius: 4px; padding: 5px 8px; font-size: 0.9em; }
		.scene-list-group-header { font-size: 0.8em; text-transform: uppercase; color: #888; margin: 15px 0 5px 5px; font-weight: bold; }
		.scene-card { display: flex; gap: 12px; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; margin-bottom: 10px; cursor: pointer; transition: border-color 0.2s, background-color 0.2s; }
		.scene-card:hover { background-color: #2a2a2a; border-color: #555; }
		.scene-card.active { background-color: var(--primary-color); border-color: var(--primary-color); color: white; }
		.scene-card.has-broken-link { background-color: #4d2529 !important; border-color: var(--danger-color) !important; }
		.scene-card.has-broken-link:hover { background-color: #6b353c !important; }
		.scene-card.has-broken-link .scene-card-id, .scene-card.has-broken-link .scene-card-text { color: #f5c5c5 !important; }
		.scene-card-thumbnail { width: 96px; height: 54px; flex-shrink: 0; background-color: #111; border-radius: 4px; display: flex; justify-content: center; align-items: center; font-size: 0.7em; color: var(--secondary-color); overflow: hidden; border: 1px solid #444; }
		.scene-card.active .scene-card-thumbnail { border-color: rgba(255,255,255,0.5); }
		.scene-card-thumbnail img, .scene-card-thumbnail canvas { width: 100%; height: 100%; object-fit: cover; }
		.scene-card-content { display: flex; flex-direction: column; gap: 6px; flex-grow: 1; overflow: hidden; }
		.scene-card-header { display: flex; justify-content: space-between; align-items: center; }
		.scene-card-id { font-weight: bold; font-size: 1.1em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
		.scene-card.active .scene-card-id { color: white; }
		.scene-card-icons { display: flex; gap: 8px; align-items: center; font-size: 0.9em; }
		.scene-card-icons .icon-orphan { order: -1; }
		.scene-card-icons .icon-condition { order: 1; }
		.scene-card-icons .choice-count-icon { order: 2; }
		.scene-card-icon-group { display: flex; align-items: center; gap: 3px; }
		.scene-card.active .choice-count-icon { background-color: rgba(255, 255, 255, 0.3); }
		.scene-card.active .scene-card-icons, .scene-card.active .node-icons { color: white; }
		.scene-card.active .icon-orphan, .scene-card.active .icon-deadend { color: white; background-color: rgba(0,0,0,0.2); border-radius: 3px; padding: 1px; }
		.scene-card-text { font-size: 0.85em; color: #aaa; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
		.scene-card.active .scene-card-text { color: #ddd; }

		/* View Toggler Styles */
		#view-mode-toggle { display: flex; gap: 5px; }
		#view-mode-toggle button { flex-grow: 1; background-color: var(--secondary-color); opacity: 0.6; }
		#view-mode-toggle button.active { background-color: var(--primary-color); opacity: 1; }

		button { padding: 10px 15px; background-color: var(--primary-color); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em; transition: background-color 0.2s; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
		.form-group.inline button { margin-top: 0; }
		button:disabled { background-color: var(--secondary-color); cursor: not-allowed; }
		.btn-group { display: flex; gap: 10px; flex-wrap: wrap; }
		.btn-group button { margin-top: 0; }
		.btn-success { background-color: var(--success-color); }
		#save-story-btn.dirty { animation: pulse-success 1.5s infinite; }
		@keyframes pulse-success { 0% { box-shadow: 0 0 0 0 rgba(90, 143, 102, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(90, 143, 102, 0); } 100% { box-shadow: 0 0 0 0 rgba(90, 143, 102, 0); } }
		.btn-warning { background-color: var(--warning-color); color: var(--warning-text); }
		#save-project-dirty-btn.dirty { animation: pulse-warning 1.5s infinite; }
		@keyframes pulse-warning { 0% { box-shadow: 0 0 0 0 rgba(199, 146, 26, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(199, 146, 26, 0); } 100% { box-shadow: 0 0 0 0 rgba(199, 146, 26, 0); } }
		.btn-danger { background-color: var(--danger-color); }
		.btn-secondary { background-color: var(--secondary-color); }
		.btn-purple { background-color: var(--purple-color); }
		.file-icon-btn { padding: 8px; min-width: 40px; }
		.btn-round { border-radius: 50%; width: 30px; height: 30px; padding: 0; font-size: 1.2em; line-height: 30px; flex-shrink: 0; }
		#image-file-input, #sound-file-input { display: none; }

		.form-group { margin-bottom: 20px; }
		.form-group.choice-group { margin-bottom: 8px; }
		.form-group.inline { display: flex; align-items: center; gap: 10px; }
		.form-group.inline input, .form-group.inline select { flex-grow: 1; }
		.form-group label.checkbox-label { display: flex; align-items: center; gap: 8px; font-weight: normal; cursor: pointer; }
		.form-group label.checkbox-label input { width: auto; flex-grow: 0; }
		label { display: block; font-weight: bold; margin-bottom: 5px; }
		input[type="text"], input[type="search"], input[type="number"], textarea, select { width: 100%; box-sizing: border-box; padding: 10px; border: 1px solid #444444; border-radius: 4px; font-size: 1em; background-color: #1e1e1e; color: var(--dark-text); }
		input[type="text"]:disabled { background-color: #333333; cursor: not-allowed; }
		textarea { height: 120px; resize: vertical; }
		#image-preview.drag-over,
		input.drag-over { border: 2px dashed var(--primary-color) !important; box-shadow: 0 0 10px var(--primary-color); }

		#media-hub {
			display: flex;
			gap: 15px;
			align-items: center;
		}
		#media-paths-container { flex-grow: 1; display: flex; flex-direction: column; gap: 10px; }
		#media-paths-container .form-group.inline { margin: 0; }
		#media-paths-container .media-icon-label { margin-bottom: 0; flex-shrink: 0; width: 24px; height: 24px; color: var(--secondary-color); display: inline-flex; align-items: center; justify-content: center; }
		#video-controls { display: none; } /* Hide video controls by default */
		.form-group.inline .video-control-btn { flex-shrink: 0; }


		#scene-editor-preview-wrapper {
			position: relative;
			width: 100%;
			max-width: 720px;
			margin: 0 auto 25px auto;
			aspect-ratio: 16 / 9;
			border: 1px solid var(--border-color);
			border-radius: 8px;
			overflow: hidden;
			background-color: #000;
		}
		#scene-editor-preview-wrapper.is-loading::after {
			content: 'Loading...';
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			display: flex;
			justify-content: center;
			align-items: center;
			background-color: rgba(0, 0, 0, 0.5);
			color: white;
			font-size: 1.2em;
			z-index: 10;
		}
		#scene-editor-preview { position: absolute; top: 0; left: 0; width: 200%; height: 200%; transform: scale(0.5); transform-origin: top left; overflow: auto; background-color: var(--bg-color); color: var(--text-color); font-family: var(--font-family); font-size: var(--font-size); display: flex; justify-content: center; align-items: center; background-size: cover; background-position: center;}
		#scene-editor-preview.layout-panel-bottom { align-items: flex-end; }
		#scene-editor-preview.layout-panel-left { justify-content: flex-start; }
		#scene-editor-preview.layout-panel-right { justify-content: flex-end; }


		#scene-editor-preview #preview-player-inner-container {
			width: 100%; max-width: 800px; margin: 20px;
			box-shadow: var(--container-shadow, 0 5px 20px rgba(0,0,0,.5));
			border-width: var(--container-outline-width, 0px);
            border-style: solid;
            border-color: var(--container-outline-color, transparent);
			background-color: var(--container-bg-color);
			gap: 20px; padding: var(--padding); border-radius: 12px; box-sizing: border-box; display: flex;
			max-height: 95%;
			overflow-y: auto;
		}

		#scene-editor-preview .choice-btn { padding: 15px 20px; pointer-events: none; background-color: var(--btn-color); color: var(--btn-text-color); border: var(--container-outline-width, 0) solid var(--container-outline-color, transparent); text-align: left; border-radius: 6px; font-size: 1em; font-family: var(--font-family); }
		#scene-editor-preview #preview-player-image,
		#scene-editor-preview #preview-player-video-fg { max-width: 100%; max-height: 50vh; display: block; margin: 0 auto; border-radius: 8px; object-fit: cover; }
		#scene-editor-preview #preview-player-video { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: -1; }
		#scene-editor-preview #preview-player-text { white-space: pre-wrap; margin-bottom: 20px; line-height: 1.6; }
		#scene-editor-preview #preview-player-choices { display: flex; flex-direction: column; gap: 12px; }

		.layout-top-down #preview-player-inner-container { flex-direction: column; }
		.layout-top-down #preview-player-image-container { width: 100%; margin-bottom: 20px; }
		.layout-top-down #preview-player-image { width: 100%; height: auto; }

		.layout-side-by-side #preview-player-inner-container { flex-direction: row; align-items: flex-start; }
		.layout-side-by-side #preview-player-image-container { width: 40%; flex-shrink: 0; }
		.layout-side-by-side #preview-player-content-container { width: 60%; }

		.layout-panel-bottom #preview-player-image-container,
		.layout-panel-left #preview-player-image-container,
		.layout-panel-right #preview-player-image-container { display: none !important; }

		.layout-panel-bottom #preview-player-content-container,
		.layout-panel-left #preview-player-content-container,
		.layout-panel-right #preview-player-content-container { width: 100%; }

		#scene-editor-preview.layout-panel-left #preview-player-inner-container,
		#scene-editor-preview.layout-panel-right #preview-player-inner-container {
			width: 25%; height: auto; flex-direction: column; max-width: none; max-height: 180vh;
		}
		.layout-panel-left #preview-player-choices .choice-btn { text-align: left !important; }
		.layout-panel-right #preview-player-choices .choice-btn { text-align: right !important; }

		#ai-image-generator { display: flex; gap: 10px; align-items: center; margin-top: 5px; }
		#ai-image-preview { width: 150px; height: 150px; background-color: #1e1e1e; border: 1px dashed var(--border-color); display: flex; justify-content: center; align-items: center; font-size: 0.8em; color: var(--text-secondary); text-align: center; flex-shrink: 0; position: relative; }
		#ai-image-preview img { max-width: 100%; max-height: 100%; object-fit: contain; }
		#ai-image-controls { display: flex; gap: 10px; align-items: center; flex-grow: 1; }
		.modal { display: none; opacity: 0; visibility: hidden; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); justify-content: center; align-items: center; transition: opacity 0.2s, visibility 0.2s; }
		.modal.visible { display: flex; opacity: 1; visibility: visible; }
		.modal-content { position: relative; background-color: #1e1e1e; padding: 20px; border-radius: 8px; width: 80%; max-width: 600px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); color: var(--dark-text); }
		.modal-close { position: absolute; top: 10px; right: 15px; font-size: 1.5em; font-weight: bold; cursor: pointer; color: #aaaaaa; }
		.modal-close:hover { color: #ffffff; }
		.modal-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
		.modal-grid label { display: flex; flex-direction: column; }
		.modal-grid .grid-span-2 { grid-column: 1 / -1; display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
		.modal-grid .grid-full-width { grid-column: 1 / -1; }
		.modal-grid .grid-separator { grid-column: 1 / -1; margin: 5px 0; border: none; border-top: 1px solid var(--border-color); }
		input[type="color"] { width: 100%; height: 40px; padding: 0; border: 1px solid #444444; cursor: pointer; background-color: transparent; }
		input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
		input[type="color"]::-webkit-color-swatch { border: none; }

		#style-editor-modal.visible,
		#batch-image-modal.visible {
			background-color: transparent;
			pointer-events: none;
			justify-content: flex-start;
			align-items: flex-start;
		}
		#style-editor-modal .modal-content,
		#batch-image-modal .modal-content {
			pointer-events: auto;
			margin: 0;
			border-radius: 0;
			max-height: none;
			max-width: none;
			overflow-y: auto;
			border-right: 1px solid var(--border-color);
			position: absolute;
			box-sizing: border-box;
			resize: horizontal;
			overflow: auto;
		}
		#batch-image-modal .modal-content { display: flex; flex-direction: column; }

		/* --- NEW Context Menu Styles --- */
        .context-menu {
            display: none;
            position: absolute;
            background-color: #252629;
            border: 1px solid var(--border-color);
            box-shadow: 2px 2px 8px rgba(0,0,0,0.3);
            border-radius: 6px;
            padding: 5px 0;
            z-index: 1001;
            min-width: 200px;
        }
        .context-menu button {
            width: 100%;
            text-align: left;
            background: none;
            color: var(--text-primary);
            margin: 0;
            padding: 8px 15px;
            border-radius: 0;
            border: none;
            font-size: 14px;
        }
        .context-menu button:hover {
            background-color: var(--primary-color);
            color: white;
        }
        .context-menu hr {
            border-top: 1px solid var(--border-color);
            margin: 5px 0;
        }
        .context-menu .submenu {
            position: relative;
        }
        .context-menu .submenu-content {
            display: none;
            position: absolute;
            left: 100%;
            top: -5px; /* Align with parent button */
            background-color: #252629;
            border: 1px solid var(--border-color);
            box-shadow: 2px 2px 8px rgba(0,0,0,0.3);
            border-radius: 6px;
            padding: 5px 0;
            z-index: 1002;
        }
        .context-menu .submenu:hover .submenu-content {
            display: block;
        }
        .context-menu .submenu button::after {
            content: '▶';
            float: right;
            font-size: 0.8em;
            line-height: 1.5;
        }
		
		#player-video-bg {
			display: none;
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			object-fit: cover;
			z-index: 0;
		}
		#player-inner-container {
			width: 100%;
			max-width: 800px;
			padding: var(--padding);
			border-radius: 12px;
			box-shadow: var(--container-shadow, 0 5px 20px rgba(0,0,0,0.5));
			border-width: var(--container-outline-width, 0px);
            border-style: solid;
            border-color: var(--container-outline-color, transparent);
			background-color: var(--container-bg-color);
			display:flex;
			gap: 20px;
			margin: 20px;
			position: relative;
			z-index: 1;
			max-height: 90vh;
			overflow-y: auto;
		}
		#player-inner-container.layout-panel-left,
		#player-inner-container.layout-panel-right {
			width: 25vw;
			min-width: 250px;
			max-width: 400px;
			flex-direction: column;
			height: auto;
			max-height: 90vh;
			overflow-y: auto;
		}
		#player-container.layout-panel-bottom #player-image-container,
		#player-container.layout-panel-left #player-image-container,
		#player-container.layout-panel-right #player-image-container {
			display: none;
		}
		#player-container.layout-panel-left #player-choices .choice-btn {
			text-align: left;
		}
		#player-container.layout-panel-right #player-choices .choice-btn {
			text-align: right;
		}

		#player-inner-container.layout-top-down {
			flex-direction: column;
		}
		#player-inner-container.layout-top-down #player-image-container {
			width: 100%;
			margin-bottom: 20px;
		}
		#player-inner-container.layout-top-down #player-image,
		#player-inner-container.layout-top-down #player-video-fg {
			width: 100%;
			height: auto;
		}
		#player-inner-container.layout-side-by-side {
			flex-direction: row;
			align-items: flex-start;
		}
		#player-inner-container.layout-side-by-side #player-image-container {
			width: 40%;
			flex-shrink: 0;
		}
		#player-inner-container.layout-side-by-side #player-image,
		#player-inner-container.layout-side-by-side #player-video-fg {
			width: 100%;
			height: auto;
		}
		#player-inner-container.layout-side-by-side #player-content-container {
			width: 60%;
		}

		#player-image-container,
		#player-content-container {
			position: relative;
			z-index: 1;
		}
		#player-image, #player-video-fg { max-width: 100%; max-height: 50vh; display: block; margin: 0 auto; border-radius: 8px; object-fit: cover; }
		#player-text { white-space: pre-wrap; margin-bottom: 20px; line-height: 1.6; }
		#player-text a { color: #8ab4f8; }
		#player-choices { display: flex; flex-direction: column; gap: 12px; }
		#player-choices .choice-btn { width: 100%; text-align: left; padding: 15px 20px; border-radius: 6px; cursor: pointer; font-size: 1em; transition: background-color .2s, transform .1s, border-color .2s; background-color: var(--btn-color); color: var(--btn-text-color); border: var(--container-outline-width, 0) solid var(--container-outline-color, transparent); font-family: var(--font-family); }
		#player-choices .choice-btn:hover { transform: translateY(-2px); background-color: var(--btn-hover-color); }
		#player-choices .choice-btn:active { transform: translateY(1px); }
		@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
		#player-choices .choice-btn.fade-in { animation: fadeIn 0.5s forwards; opacity: 0; }

		#stop-play-x { position: absolute; top: 10px; right: 10px; background: var(--danger-color); color: white; border: none; font-size: 1.5em; padding: 5px 10px; cursor: pointer; z-index: 10; }
		#restart-play { position: absolute; top: 10px; right: 60px; z-index: 10; }
		#image-preview { width: 150px; height: 150px; background-color: #1e1e1e; border: 1px dashed var(--border-color); display: flex; justify-content: center; align-items: center; font-size: 0.8em; color: var(--text-secondary); text-align: center; flex-shrink: 0; position: relative; }
		#image-preview img, #image-preview canvas { max-width: 100%; max-height: 100%; object-fit: contain; }
		#fullscreen-viewer { flex-direction: column; }
		#fullscreen-image { max-width: 90vw; max-height: 80vh; object-fit: contain; }
		#fullscreen-minimize { margin-top: 15px; }
		.thumbnail-fullscreen-icon { position: absolute; bottom: 4px; right: 4px; width: 24px; height: 24px; background-color: rgba(0, 0, 0, 0.6); color: white; border-radius: 4px; cursor: pointer; display: flex; justify-content: center; align-items: center; opacity: 0; transition: opacity 0.2s; }
		#image-preview:hover .thumbnail-fullscreen-icon,
		#ai-image-preview:hover .thumbnail-fullscreen-icon { opacity: 1; }
		.thumbnail-fullscreen-icon svg { width: 16px; height: 16px; }
		.play-pause-icon.hidden { display: none; }
		#style-editor-grid #style-font-size, #style-editor-grid #style-padding { background-color: #1E1E1E; color: white; border: 1px solid #444444; border-radius: 4px; height: 40px; box-sizing: border-box; }
		#toggle-loop-btn.active, #toggle-video-loop-btn.active { background-color: var(--primary-color); }
		#toggle-video-mute-btn:not(.active) { background-color: var(--primary-color); } /* Active means MUTED, so when NOT active, it's colored */
		#custom-tooltip { display: none; position: fixed; z-index: 9999; background-color: #333; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 5px 10px; font-size: 14px; max-width: 350px; word-wrap: break-word; white-space: pre-wrap; pointer-events: none; opacity: 0; transition: opacity 0.1s linear; }
		#icon-thumbnail-tooltip { display: none; position: fixed; z-index: 9999; background-color: #2a2a2e; color: #fff; border: 1px solid #555; border-radius: 6px; padding: 12px; font-size: 14px; width: 280px; pointer-events: none; opacity: 0; transition: opacity 0.1s linear; box-shadow: 0 4px 12px rgba(0,0,0,0.4); display: flex; gap: 12px; align-items: center; }
		#icon-thumbnail-tooltip .thumbnail-icon { flex-shrink: 0; width: 48px; height: 48px; display: flex; align-items: center; justify-content: center; }
		#icon-thumbnail-tooltip .thumbnail-icon svg { width: 32px; height: 32px; }
		#icon-thumbnail-tooltip .thumbnail-text h4 { margin: 0 0 4px 0; font-size: 1em; color: #e0e0e0; border: none; }
		#icon-thumbnail-tooltip .thumbnail-text p { margin: 0; font-size: 0.9em; color: #aaa; }
		#batch-fieldset { display: flex; flex-direction: column; flex-grow: 1; min-height: 0; border: none; padding: 0; margin: 0; }
		#batch-info-log { background-color: #000; border: 1px solid var(--border-color); border-radius: 4px; height: auto; flex-grow: 1; overflow-y: auto; padding: 10px; font-family: monospace; font-size: 0.9em; white-space: pre-wrap; margin-top: 15px; margin-bottom: 15px; color: #ccc; }
		#batch-controls-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; align-items: end; }
		#batch-controls-grid .full-width { grid-column: 1 / -1; }

		/* --- Choice UI Styles --- */
		#choices-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
		#manage-variables-btn { width: 30px; height: 30px; border-radius: 50%; }
		.choice-editor { display: flex; align-items: center; gap: 12px; margin-bottom: 15px; }
		.choice-editor .default-view, .choice-editor .condition-view { display: flex; flex-grow: 1; align-items: center; }
		.choice-editor .condition-view { display: none; }
		.choice-editor.is-conditional .condition-view { display: flex; }
		.choice-editor.is-conditional .default-view { display: none; }
		.choice-editor select, .choice-editor input[type="text"] { background-color: var(--bg-element); color: var(--text-primary); padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 14px; }
		.choice-editor input::placeholder { color: var(--text-secondary); }
		.choice-editor select optgroup { font-weight: bold; color: var(--text-secondary); }
		.icon-btn { background-color: var(--accent-color-primary); border: 1px solid #333333; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; display: flex; justify-content: center; align-items: center; flex-shrink: 0; transition: all 0.2s ease-in-out; color: var(--text-primary); padding: 0; }
		.icon-btn:hover { background-color: #4aa297; transform: scale(1.05); }
		.icon-btn.manage-vars-btn { background-color: var(--accent-color-secondary); border-color: #88d8d0; }
		.icon-btn.manage-vars-btn:hover { background-color: #4aa297; }
		.icon-btn svg, .icon-symbol { width: 20px; height: 20px; stroke: currentColor; stroke-width: 1.5; fill: none; stroke-linecap: round; stroke-linejoin: round; }
		.icon-symbol { color: var(--text-primary); flex-shrink: 0; stroke-width: 2; }
		.choice-editor .ui-box { display: flex; flex-grow: 1; align-items: center; gap: 10px; border: 1px solid var(--border-color); padding: 5px 10px; border-radius: 6px; background-color: var(--bg-main); }
		.choice-editor .ui-box > input, .choice-editor .ui-box > select { flex-grow: 1; flex-basis: 0; min-width: 80px; }
		.choice-editor .ui-box > .condition-boolean-select { flex-grow: 0; }
		.choice-editor .set-variable-ui { display: flex; align-items: center; gap: 10px; }
		.display-none { display: none !important; }
		.choice-editor .delete-choice-btn { background-color: var(--danger-color); font-size: 1.5em; color: white; }
		.go-to-scene-btn { padding: 8px; line-height: 1; min-width: auto; }

		/* --- Variable Manager Modal Styles --- */
		#variable-manager-modal .modal-content { max-width: 400px; }
		#variable-manager-modal h3 { margin: 0; padding-bottom: 10px; border-bottom: 2px solid var(--title-underline-color); }
		#variable-manager-modal .variable-list { list-style: none; padding: 0; margin: 20px 0; max-height: 50vh; overflow-y: auto; display: flex; flex-direction: column; gap: 8px;}
		#variable-manager-modal .variable-list li { display: flex; justify-content: space-between; align-items: center; background-color: var(--bg-element); padding: 8px 12px; border-radius: 4px; }
		#variable-manager-modal .remove-var-btn { background: none; border: none; color: var(--text-secondary); cursor: pointer; font-weight: bold; }
		#variable-manager-modal .remove-var-btn:hover { color: #ff8a8a; }
		#variable-manager-modal .add-var-form { display: flex; gap: 10px; }
		#variable-manager-modal .add-var-form input { flex-grow: 1; }
		#variable-manager-modal .add-var-form button { background-color: var(--title-underline-color); color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-weight: bold; }

		/* --- Debug Modal Styles --- */
		#debug-modal .modal-content { max-width: 80vw; width: 100%; height: 80vh; display: flex; flex-direction: column; }
		#debug-log { background-color: #000; flex-grow: 1; font-family: monospace; font-size: 14px; white-space: pre; overflow: auto; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; color: #ccc; }
		#debug-modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
		#debug-modal-header h2 { margin: 0; border: none; }

		/* --- Custom Styles for About Editor --- */
		#about-editor-modal .modal-content {
			font-size: 14px;
			max-width: 700px;
			background-color: var(--bg-container);
		}
		#about-editor-modal .modal-content h2 {
			border-bottom-color: var(--title-underline-color);
		}
		#about-editor-modal .modal-close {
			top: 15px;
			right: 15px;
			font-size: 2em;
			width: 36px;
			height: 36px;
			line-height: 36px;
			text-align: center;
		}

        /* --- Custom Prompt Styles --- */
        #custom-prompt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2000; /* Must be on top of other UI */
        }
        #custom-prompt {
            position: absolute;
            background-color: var(--bg-container);
            border: 1px solid var(--primary-color);
            border-radius: 6px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            padding: 15px;
            width: 300px;
            z-index: 2001;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #custom-prompt p { margin: 0 0 5px 0; font-size: 0.9em; }
        #custom-prompt-input { font-size: 0.9em !important; padding: 8px !important; }
        #custom-prompt-buttons { display: flex; justify-content: flex-end; gap: 10px; }
		
		/* Style for the selected connection path */
		#node-svg-layer .edge-group.is-selected-path .edge-path {
			stroke: var(--primary-color);
			stroke-width: 4px; /* Make the selected line slightly thicker */
		}

		/* Style for the arrow of the selected connection */
		#node-svg-layer .edge-group.is-selected-path .edge-arrow {
			fill: var(--primary-color);
		}

		/* Style for the text background of the selected connection */
		#node-svg-layer .edge-group.is-selected-path .edge-label-bg {
			fill: var(--primary-color);
			stroke: #fff;
		}

		/* Style for the text of the selected connection */
		#node-svg-layer .edge-group.is-selected-path .edge-label {
			fill: #fff;
		}
	</style>
</head>
<body>

<div id="main-layout-container">
    <div id="left-panel-container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <button id="project-menu-btn" class="btn-secondary" title="Open Project Menu">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"/></svg>
                Menu
            </button>
			
			<div id="view-mode-toggle">
				<button id="toggle-scene-view-btn" title="Scene List View">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
						<path d="M2.5,4A1.5,1.5,0,1,0,4,2.5,1.5,1.5,0,0,0,2.5,4Z"/>
						<path d="M2.5,9A1.5,1.5,0,1,0,4,7.5,1.5,1.5,0,0,0,2.5,9Z"/>
						<path d="M2.5,14A1.5,1.5,0,1,0,4,12.5,1.5,1.5,0,0,0,2.5,14Z"/>
						<path d="M7,3H15a1,1,0,0,1,0,2H7A1,1,0,0,1,7,3Z"/>
						<path d="M7,8H15a1,1,0,0,1,0,2H7A1,1,0,0,1,7,8Z"/>
						<path d="M7,13H15a1,1,0,0,1,0,2H7A1,1,0,0,1,7,13Z"/>
					</svg>
					Scenes
				</button>
				<button id="toggle-node-view-btn" class="active" title="Node Editor View">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
						<path d="M10 4.5a.5.5 0 0 0-1 0v1a.5.5 0 0 0 1 0v-1zM6 4.5a.5.5 0 0 0-1 0v1a.5.5 0 0 0 1 0v-1zM4 6.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5zm6 0a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5zM1.5 3A1.5 1.5 0 0 0 0 4.5v7A1.5 1.5 0 0 0 1.5 13h13a1.5 1.5 0 0 0 1.5-1.5v-7A1.5 1.5 0 0 0 14.5 3h-13zm0-1h13a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-.5.5h-13a.5.5 0 0 1-.5-.5v-7a.5.5 0 0 1 .5-.5z"/>
					</svg>
					Nodes
				</button>
			</div>	
			
            <button id="style-editor-btn" class="btn-secondary" title="Style Template Editor">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1 2.5A1.5 1.5 0 0 1 2.5 1h3A1.5 1.5 0 0 1 7 2.5v3A1.5 1.5 0 0 1 5.5 7h-3A1.5 1.5 0 0 1 1 5.5v-3zm8 0A1.5 1.5 0 0 1 10.5 1h3A1.5 1.5 0 0 1 15 2.5v3A1.5 1.5 0 0 1 13.5 7h-3A1.5 1.5 0 0 1 9 5.5v-3zm-8 8A1.5 1.5 0 0 1 2.5 9h3A1.5 1.5 0 0 1 7 10.5v3A1.5 1.5 0 0 1 5.5 15h-3A1.5 1.5 0 0 1 1 13.5v-3zm8 0A1.5 1.5 0 0 1 10.5 9h3a1.5 1.5 0 0 1 1.5 1.5v3a1.5 1.5 0 0 1-1.5 1.5h-3A1.5 1.5 0 0 1 9 13.5v-3z"/></svg>
				Style
            </button>
        </div>

        <div id="node-editor-view">
			<div id="transform-pane">
                <svg id="node-svg-layer">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" class="edge-arrow" />
                        </marker>
                    </defs>
                    <g id="edge-group-container"></g>
                    <path id="temp-edge" class="temp-edge" visibility="hidden"></path>
                </svg>
                <div id="node-element-container"></div>
            </div>
			<div id="node-editor-controls">
                <button id="node-zoom-in-btn" title="Zoom In">+</button>
                <button id="node-zoom-out-btn" title="Zoom Out">-</button>
                <button id="node-fit-view-btn" title="Fit View">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg>
                </button>
				<button id="node-auto-arrange-btn" title="Auto-Arrange Nodes">
					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6v12M21 6v12M3 12h18"/></svg>
				</button>
				<button id="node-find-orphans-btn" title="Find Orphan Nodes">
					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><circle cx="19" cy="5" r="2"/><circle cx="5" cy="19" r="2"/><path d="M13.5 10.5l3.5-3.5"/><path d="M10.5 13.5L7 17"/></svg>
				</button>
			</div>
		</div>

        <div id="scene-list-view-wrapper">
            <div id="scene-list-view"></div>
            <div id="scene-list-controls">
                <label for="scene-list-sort" style="font-size: 0.9em; margin: 0; font-weight: normal;">Sort by:</label>
                <select id="scene-list-sort">
                    <option value="file-order">File Order</option>
                    <option value="id">ID (A-Z)</option>
                    <option value="modified">Last Modified</option>
                </select>
            </div>
        </div>

        <div class="form-group inline" style="margin-top: 15px; margin-bottom: 0;">
            <input type="search" id="scene-search-input" placeholder="Filter scenes...">
            <button id="scene-search-btn" class="file-icon-btn" title="Search Scenes">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/></svg>
            </button>
        </div>
    </div>

    <div id="resizer"></div>

    <div id="editor-container">
        <fieldset id="editor-fieldset">
            <div class="header">
                 <button id="save-project-dirty-btn" class="btn-warning" title="Save Project (Ctrl+S)">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4.5 0h-2A1.5 1.5 0 0 0 1 1.5V15a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2.5A1.5 1.5 0 0 0 13.5 1h-2a.5.5 0 0 1 0-1h-2a.5.5 0 0 1 0 1h-2a.5.5 0 0 1 0-1H4.5zM3 14V2.5A.5.5 0 0 1 3.5 2H5v1.5A1.5 1.5 0 0 0 6.5 5h3A1.5 1.5 0 0 0 11 3.5V2h1.5a.5.5 0 0 1 .5.5V14a.5.5 0 0 1-.5-.5H3.5a.5.5 0 0 1-.5-.5z"/></svg>
                </button>
                <div style="flex-grow: 1; display: flex; justify-content: center; align-items: center;">
                    <div class="form-group inline" id="scene-id-group" style="margin-bottom: 0; min-width: 250px;">
                        <label for="scene-id" style="margin-bottom: 0; white-space: nowrap;">Scene ID</label>
                        <input type="text" id="scene-id" disabled style="padding-top: 10px; padding-bottom: 10px;">
                        <button id="rename-scene-btn" title="Rename Scene ID" class="file-icon-btn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z"/></svg>
                        </button>
                        <button id="delete-scene-btn" class="btn-danger file-icon-btn" title="Delete Current Scene">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg>
                        </button>
                        <button id="new-scene-btn" class="btn-round" title="Create New Scene">+</button>
                    </div>
                </div>
                <div class="btn-group">
                    <button id="play-from-current-btn" class="btn-success" title="Play from Current Scene">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" style="transform: scaleX(1.2);"><path d="M10.804 8 5 4.633v6.734L10.804 8zM4 4v8h-1V4h1zm8 0v8h-1V4h1z"/></svg>
                    </button>
                    <button id="play-from-start-btn" class="btn-success" title="Play from Start Scene">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>
                    </button>
                     <button id="preview-btn" class="btn-success" title="Preview Project in New Tab">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M6.271 5.055a.5.5 0 0 1 .52.038l3.5 2.5a.5.5 0 0 1 0 .814l-3.5 2.5A.5.5 0 0 1 6 10.5v-5a.5.5 0 0 1 .271-.445z"/></svg>
                    </button>
                </div>
            </div>
            <div id="editor-panel">

                <div id="scene-editor-preview-wrapper">
                    <div id="scene-editor-preview">
                        <video id="preview-player-video" playsinline></video>
                        <div id="preview-player-inner-container">
                            <div id="preview-player-image-container"><img id="preview-player-image" src="" alt="Preview image"><video id="preview-player-video-fg" playsinline style="display: none;"></video></div>
                            <div id="preview-player-content-container">
                                <div id="preview-player-text"></div>
                                <div id="preview-player-choices"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="form-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                    <textarea id="scene-text" placeholder="Story text goes here... You can use markdown for **bold**, *italic*, and [links](...). " style="flex-grow: 1;"></textarea>
                    <button id="process-text-ai-btn" class="btn-purple" title="Process Text with AI">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M7.657 6.247c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937zM3.794 1.148c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937z"/></svg>
                    </button>
                </div>

                <div id="choices-container"></div>
                <div id="choices-controls">
                     <button id="manage-variables-btn" class="icon-btn manage-vars-btn" title="Manage variables"></button>
                     <div style="flex-grow:1;"></div>
                     <button id="add-choice-btn" class="btn-round" title="Add New Choice">+</button>
                </div>

                <div class="form-group" id="media-hub">
                    <div id="image-preview">
                        <span>Thumbnail</span>
                        <div class="thumbnail-fullscreen-icon" title="View Fullscreen">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg>
                        </div>
                    </div>
                    <div id="media-paths-container">
                        <div class="form-group inline">
                            <span class="media-icon-label" title="Image or Video Path">
                                <svg id="media-icon-image" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/><path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/></svg>
                                <svg id="media-icon-video" class="hidden" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2zm5.5 3v6l5-3-5-3z"></path></svg>
                            </span>
                            <input type="text" id="scene-image" data-asset-type="images" placeholder="e.g., images/trench.jpg or videos/intro.mp4">

                            <!-- Video Controls -->
                            <div id="video-controls" style="display: none; gap: 10px;">
                                <button id="toggle-video-mute-btn" class="btn-secondary file-icon-btn video-control-btn" title="Toggle Video Mute">
                                    <svg class="play-pause-icon" id="video-unmute-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.536 14.01A8.473 8.473 0 0 0 14.026 8a8.473 8.473 0 0 0-2.49-6.01l-.708.707A7.476 7.476 0 0 1 13.025 8c0 2.071-.84 3.946-2.197 5.303l.708.707z"/><path d="M10.121 12.596A6.48 6.48 0 0 0 12.025 8a6.48 6.48 0 0 0-1.904-4.596l-.707.707A5.483 5.483 0 0 1 11.025 8a5.483 5.483 0 0 1-1.61 3.89l.706.706z"/><path d="M8.707 11.182A4.486 4.486 0 0 0 10.025 8a4.486 4.486 0 0 0-1.318-3.182L8 5.525A3.489 3.489 0 0 1 9.025 8 3.49 3.49 0 0 1 8 10.475l.707.707zM6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06z"/></svg>
                                    <svg class="play-pause-icon hidden" id="video-mute-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06zm7.137 2.096a.5.5 0 0 1 0 .708L12.207 8l1.647 1.646a.5.5 0 0 1-.708.708L11.5 8.707l-1.646 1.647a.5.5 0 0 1-.708-.708L10.793 8 9.146 6.354a.5.5 0 1 1 .708-.708L11.5 7.293l1.646-1.647a.5.5 0 0 1 .708 0z"/></svg>
                                </button>
                                 <button id="toggle-video-loop-btn" class="btn-secondary file-icon-btn video-control-btn" title="Toggle Video Loop">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966a.25.25 0 0 1 0 .384l-2.36 1.966A.25.25 0 0 1 8 4.466z"/></svg>
                                </button>
                                <button id="toggle-video-playback-btn" class="btn-secondary file-icon-btn video-control-btn" title="Play/Pause Video">
                                    <svg class="play-pause-icon" id="video-play-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M10.804 8 5 4.633v6.734L10.804 8z"/></svg>
                                    <svg class="play-pause-icon hidden" id="video-pause-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M6 3.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5zm4 0a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5z"/></svg>
                                </button>
                            </div>
                             <button id="select-image-btn" class="btn-warning file-icon-btn" title="Select Image/Video File">
                                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.54 3.87.5 3a2 2 0 0 1 2-2h3.672a2 2 0 0 1 1.414.586l.828.828A2 2 0 0 0 9.828 3h3.982a2 2 0 0 1 1.992 2.181l-.637 7A2 2 0 0 1 13.174 14H2.826a2 2 0 0 1-1.991-1.819l-.637-7a1.99 1.99 0 0 1 .342-1.31zM6.172 2a1 1 0 0 0-.707.293L4.646 3.114a1 1 0 0 1-.707.293H2.5a1 1 0 0 0-1 .981l.637 7a1 1 0 0 0 .992.919h10.348a1 1 0 0 0 .991-.919l.637-7a1 1 0 0 0-1-1.019h-3.982a1 1 0 0 1-.707-.293l-.828-.828A1 1 0 0 0 6.172 2H2.5z"/></svg>
                            </button>
                        </div>
                        <div class="form-group inline">
                             <span class="media-icon-label" title="Ambience Sound Path">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M8 3a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0v-8A.5.5 0 0 1 8 3zm-2 2a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 1 .5-.5zm4 0a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 1 .5-.5zm-6 1a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2a.5.5 0 0 1 .5-.5zm8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2a.5.5 0 0 1 .5-.5zm-10 1a.5.5 0 0 1 .5.5v0a.5.5 0 0 1-1 0v0a.5.5 0 0 1 .5-.5zm12 0a.5.5 0 0 1 .5.5v0a.5.5 0 0 1-1 0v0a.5.5 0 0 1 .5-.5z"/></svg>
                            </span>
                            <input type="text" id="scene-sound" data-asset-type="sounds" placeholder="e.g., sounds/wind.mp3">
                             <button id="toggle-loop-btn" class="btn-secondary file-icon-btn" title="Toggle Ambience Loop">
                                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                     <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                                     <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966a.25.25 0 0 1 0 .384l-2.36 1.966A.25.25 0 0 1 8 4.466z"/>
                                 </svg>
                             </button>
                             <button id="toggle-ambience-btn" class="btn-secondary file-icon-btn" title="Play/Pause Ambience">
                                <svg class="play-pause-icon" id="ambience-play-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M10.804 8 5 4.633v6.734L10.804 8z"/></svg>
                                <svg class="play-pause-icon hidden" id="ambience-pause-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M6 3.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5zm4 0a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5z"/></svg>
                            </button>
                            <button id="select-sound-btn" class="btn-warning file-icon-btn" title="Select Sound File">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.54 3.87.5 3a2 2 0 0 1 2-2h3.672a2 2 0 0 1 1.414.586l.828.828A2 2 0 0 0 9.828 3h3.982a2 2 0 0 1 1.992 2.181l-.637 7A2 2 0 0 1 13.174 14H2.826a2 2 0 0 1-1.991-1.819l-.637-7a1.99 1.99 0 0 1 .342-1.31zM6.172 2a1 1 0 0 0-.707.293L4.646 3.114a1 1 0 0 1-.707.293H2.5a1 1 0 0 0-1 .981l.637 7a1 1 0 0 0 .992.919h10.348a1 1 0 0 0 .991-.919l.637-7a1 1 0 0 0-1-1.019h-3.982a1 1 0 0 1-.707-.293l-.828-.828A1 1 0 0 0 6.172 2H2.5z"/></svg>
                            </button>
                        </div>
                    </div>
                </div>

                <hr>

                <div class="form-group">
                    <label for="scene-image-prompt">AI Image</label>
                    <div id="ai-image-generator">
                        <div id="ai-image-preview">
                            <span>Preview</span>
                            <div class="thumbnail-fullscreen-icon" title="View Fullscreen">
                                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg>
                            </div>
                        </div>
                        <div id="ai-image-controls">
                            <textarea id="scene-image-prompt" placeholder="A stunning vista of a fantasy castle at sunset, digital art" style="flex-grow: 1; height: 150px; resize: none; margin-top:0;"></textarea>
                            <div class="btn-group" style="flex-direction: column; flex-shrink: 0; gap: 5px; margin-top: 0; align-self: stretch; justify-content: center;">
                                <button id="render-ai-image-btn" class="btn-purple" style="margin-top:0;" title="Render AI Image (Right-click for batch options)">
                                     <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M7.657 6.247c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937zM3.794 1.148c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937z"/></svg>
                                </button>
                                <button id="add-ai-image-btn" class="btn-success" style="margin-top:0;" title="Add Rendered Image to Scene">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/></svg>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </fieldset>
         <div id="player-container">
            <video id="player-video-bg" playsinline></video>
            <button id="stop-play-x" class="btn-danger">X</button>
            <button id="restart-play" class="btn-secondary" title="Restart Game"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908.417A6 6 0 1 0 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466z"/></svg></button>
            <div id="player-inner-container">
                <div id="player-image-container">
                    <img id="player-image" src="">
                    <video id="player-video-fg" playsinline></video>
                </div>
                <div id="player-content-container">
                    <div id="player-text"></div>
                    <div id="player-choices"></div>
                </div>
            </div>
            <audio id="ambience-player"></audio>
            <audio id="music-player" loop></audio>
        </div>
    </div>
</div>


<!-- Hidden Inputs for File Selection -->
<input type="file" id="image-file-input" accept="image/*,video/*">
<input type="file" id="sound-file-input" accept="audio/*">

<!-- Context Menus -->
<div id="tree-context-menu" class="context-menu">
    <button id="set-start-scene-btn">Set as Start Scene</button>
</div>
<div id="editor-context-menu" class="context-menu"></div>


<!-- Tooltips -->
<div id="custom-tooltip"></div>
<div id="icon-thumbnail-tooltip">
    <div class="thumbnail-icon"></div>
    <div class="thumbnail-text">
        <h4></h4>
        <p></p>
    </div>
</div>


<!-- Modals -->
<div id="project-menu-modal" class="modal">
    <div class="modal-content">
        <span class="modal-close">&times;</span>
        <h2>Project Menu</h2>
        <div class="btn-group" style="flex-direction: column; gap: 15px; align-items: stretch;">
            <button id="new-project-btn" class="btn-secondary">New Project</button>
            <button id="open-project-btn" class="btn-secondary">Open Project</button>
            <button id="save-story-btn" class="btn-success">Save Project</button>
            <button id="about-editor-btn">Project Text Editor</button>
            <button id="batch-image-gen-btn" class="btn-secondary" disabled>Batch Image Generation</button>
            <button id="export-data-btn" class="btn-warning">Export Data</button>
            <button id="export-project-btn" class="btn-warning">Export Standalone Game</button>
        </div>
    </div>
</div>
<div id="about-editor-modal" class="modal"><div class="modal-content"><span class="modal-close">&times;</span><h2>Project Text Editor</h2><p>This information will be displayed in the player's "About" section.</p><div class="form-group"><label for="story-title">Story Title</label><input type="text" id="story-title" placeholder="Your story title"></div><div class="form-group"><label for="creator-name">Creator Name</label><input type="text" id="creator-name" placeholder="Your name or alias"></div><div class="form-group"><label for="about-text">About Text</label><textarea id="about-text" placeholder="A brief description of your project."></textarea></div></div></div>
<div id="export-data-modal" class="modal"><div class="modal-content"><span class="modal-close">&times;</span><h2>Export Specific Data</h2><p>Select data to export as a JSON file.</p><button data-export-type="imagePrompts">Export All Image Prompts</button></div></div>
<div id="style-editor-modal" class="modal"><div class="modal-content"><span class="modal-close">&times;</span><h2>Style Template Editor</h2><div id="style-editor-grid" class="modal-grid"></div></div></div>
<div id="fullscreen-viewer" class="modal"><img id="fullscreen-image" src=""><button id="fullscreen-minimize" class="btn-secondary">Minimize</button></div>
<div id="notification-modal" class="modal">
    <div class="modal-content" style="max-width: 400px; text-align: center;">
        <p id="notification-message" style="margin-top: 0;"></p>
        <button id="notification-close-btn" class="btn-secondary" style="min-width: 80px;">OK</button>
    </div>
</div>
<div id="pollinations-text-modal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="modal-close">&times;</span>
        <h2>Process Text with AI</h2>
        <div class="form-group">
            <label for="pollinations-instruction">Instruction</label>
            <textarea id="pollinations-instruction" placeholder="e.g., Rewrite this text in the style of Edgar Allan Poe"></textarea>
        </div>
        <div class="btn-group" style="justify-content: flex-end;">
            <button id="pollinations-submit-btn" class="btn-purple">Process Text</button>
        </div>
    </div>
</div>

<div id="batch-image-modal" class="modal">
    <div class="modal-content">
        <span class="modal-close">&times;</span>
        <h2>Batch Image Generation</h2>
        <fieldset id="batch-fieldset">
            <div id="batch-controls-grid">
                <div class="form-group full-width" style="margin-bottom:0;">
                    <label for="batch-suffix-input">Prompt Suffix</label>
                    <input type="text" id="batch-suffix-input" placeholder="e.g., , cinematic lighting, 4k">
                </div>
                <div class="form-group" style="margin-bottom:0;">
                    <label for="batch-cooldown-input">Cooldown (sec)</label>
                    <input type="number" id="batch-cooldown-input" value="15" min="0">
                </div>
                <div class="form-group" style="margin-bottom:0;">
                     <label class="checkbox-label">
                        <input type="checkbox" id="batch-rewrite-prompt-checkbox">
                        AI Rewrite Text to Prompt
                    </label>
                </div>
                 <div class="form-group" style="margin-bottom:0;">
                     <label class="checkbox-label" title="If checked, new images will be generated even for scenes that already have one. Also allows 'AI Rewrite' to replace existing prompts.">
                        <input type="checkbox" id="batch-overwrite-checkbox">
                        Overwrite
                    </label>
                </div>
            </div>
            <div id="batch-info-log">Ready to generate.</div>
             <hr style="margin-top: 0;">
             <div class="btn-group" style="justify-content: space-between;">
                <button id="batch-remove-images-btn" class="btn-danger">Delete All Images</button>
                <button id="batch-remove-prompts-btn" class="btn-danger">Delete All Prompts</button>
            </div>
        </fieldset>
        <div class="btn-group" style="margin-top: 20px; justify-content: flex-end; flex-shrink: 0;">
            <button id="batch-generate-btn" class="btn-purple">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M7.657 6.247c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937zM3.794 1.148c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937z"/></svg>
                Generate
            </button>
        </div>
    </div>
</div>

<div id="variable-manager-modal" class="modal">
    <div class="modal-content">
        <span class="modal-close">&times;</span>
        <h3>Manage Variables</h3>
        <div class="add-var-form">
            <input type="text" id="new-variable-name" placeholder="New_Variable_Name">
            <button>Add</button>
        </div>
        <ul id="variable-list" class="variable-list"></ul>
    </div>
</div>

<!-- DEBUG MODAL -->
<div id="debug-modal" class="modal">
    <div class="modal-content">
        <span class="modal-close">&times;</span>
        <div id="debug-modal-header">
            <h2>Import Log</h2>
            <button id="copy-debug-log-btn" class="btn-secondary">Copy Log</button>
        </div>
        <pre id="debug-log"></pre>
    </div>
</div>

<!-- JSZip Library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<!-- Player HTML Template -->
<template id="player-template">
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>__STORY_TITLE__</title>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        __GOOGLE_FONT_LINK__
        <style>
            :root { --primary-color: #4a78ad; --secondary-color: #6c757d; }
            * { box-sizing: border-box; }
            body {
                margin: 0;
                display: flex;
                justify-content: center;
                min-height: 100vh;
                transition: background-color .3s;
                background-size: cover;
                background-position: center;
                padding: 20px;
                position: relative;
                overflow: hidden;
            }
            body:not(.layout-panel-bottom):not(.layout-panel-left):not(.layout-panel-right) {
                align-items: center;
            }
            body.layout-panel-bottom {
                align-items: flex-end;
            }
            body.layout-panel-left {
                justify-content: flex-start;
                align-items: center;
            }
            body.layout-panel-right {
                justify-content: flex-end;
                align-items: center;
            }

            #background-video {
				display: none;
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				z-index: 0;
				object-fit: cover;
				background-size: cover;
				transition: opacity 1s;
				opacity: 0;
			}
            #background-video.visible {
                display: block;
                opacity: 1;
            }

            #game-container {
                width: 100%;
                max-width: 800px;
                border-radius: 12px;
                box-shadow: var(--container-shadow, 0 5px 20px rgba(0,0,0,.5));
                border-width: var(--container-outline-width, 0px);
                border-style: solid;
                border-color: var(--container-outline-color, transparent);
                background-color: var(--container-bg-color);
                display: flex;
                gap: 20px;
                position: relative;
                padding: var(--padding);
                z-index: 1;
                max-height: 90vh;
                overflow-y: auto;
            }
			#game-container::-webkit-scrollbar {
                width: 12px;
            }
            #game-container::-webkit-scrollbar-track {
                background: #1e1e1e;
                border-radius: 8px;
            }
            #game-container::-webkit-scrollbar-thumb {
                background-color: #444;
                border-radius: 6px;
                border: 2px solid #1e1e1e;
            }
            #game-container::-webkit-scrollbar-thumb:hover {
                background-color: #555;
            }
            #image-container, #content-container {
                position: relative;
                z-index: 1;
            }
            #image-container { flex-shrink: 0; }
            #scene-image, #scene-video {
                display: block;
                margin: 0 auto;
                border-radius: 8px;
                object-fit: cover;
            }
            #scene-text { white-space: pre-wrap; margin-bottom: 20px; line-height: 1.6; }
            #scene-text a { color: #8ab4f8; }
            #choices-container { display: flex; flex-direction: column; gap: 12px; }
            .choice-btn { padding: 15px 20px; border-radius: 6px; cursor: pointer; font-size: 1em; text-align: left; transition: background-color .2s,transform .1s, border-color .2s; border: var(--container-outline-width, 0) solid var(--container-outline-color, transparent); }
            .choice-btn:hover { transform: translateY(-2px); }
            .choice-btn:active { transform: translateY(1px); }
            @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
            .choice-btn.fade-in { animation: fadeIn 0.5s forwards; opacity: 0; }

            #game-container.layout-top-down { flex-direction: column; }
            #game-container.layout-top-down #image-container { width: 100%; margin-bottom: 20px; }
            #game-container.layout-top-down #scene-image,
            #game-container.layout-top-down #scene-video { width: 100%; height: auto; max-height: 50vh; }

            #game-container.layout-side-by-side { flex-direction: row; align-items: flex-start; }
            #game-container.layout-side-by-side #image-container { width: 40%; }
            #game-container.layout-side-by-side #scene-image,
            #game-container.layout-side-by-side #scene-video { width: 100%; height: auto; }
            #game-container.layout-side-by-side #content-container { width: 60%; }

            #game-container.layout-panel-bottom #image-container,
            #game-container.layout-panel-left #image-container,
            #game-container.layout-panel-right #image-container { display: none; }

            #game-container.layout-panel-bottom #content-container,
            #game-container.layout-panel-left #content-container,
            #game-container.layout-panel-right #content-container { width: 100%; }

            #game-container.layout-panel-left,
            #game-container.layout-panel-right {
                width: 25vw;
                min-width: 250px;
                max-width: 400px;
                flex-direction: column;
                height: auto;
                max-height: 90vh;
                overflow-y: auto;
            }

            body.layout-panel-bottom .choice-btn { text-align: center; }
            body.layout-panel-left .choice-btn { text-align: left; }
            body.layout-panel-right .choice-btn { text-align: right; }

            .player-top-bar { position: fixed; top: 0; left: 0; width: 100%; padding: 10px; display: flex; justify-content: space-between; align-items: center; z-index: 100; pointer-events: none; }
            .player-top-bar-left, .player-top-bar-right { display: flex; gap: 10px; }
            .player-ui-btn { pointer-events: auto; background: rgba(0,0,0,0.5); color: white; border: 1px solid rgba(255,255,255,0.5); border-radius: 50%; width: 40px; height: 40px; padding: 0; font-size: 24px; line-height: 40px; text-align: center; cursor: pointer; display: flex; justify-content: center; align-items: center; transition: background-color 0.2s; }
            .player-ui-btn.active { background-color: var(--primary-color); }
            .player-ui-btn svg { width: 22px; height: 22px; fill: currentColor; }
            .player-ui-btn .icon-off { display: none; }
            #fullscreen-btn { position: fixed; bottom: 15px; right: 15px; z-index: 100; }
            #exit-message { display: none; width: 100%; text-align: center; font-size: 1.2em; color: var(--text-color, #f0f0f0); }

            #player-video-controls { display: none; gap: 10px; pointer-events: auto; }
            #player-video-controls .player-ui-btn { font-size: 18px; }
            #player-video-controls .player-ui-btn svg { width: 18px; height: 18px; }

            @media (max-width: 800px) {
                #game-container.layout-panel-left,
                #game-container.layout-panel-right { width: 40vw; }
            }
            @media (max-width: 600px) {
                body { padding: 10px; }
                #game-container { padding: 15px; gap: 15px; }
                .choice-btn { padding: 12px 15px; font-size: 0.9em; }
                #game-container.layout-panel-left, #game-container.layout-panel-right { width: 60vw; }
            }

            .player-modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: transparent; transition: background-color 0.3s ease-out; }
            .player-modal.visible { background-color: rgba(0, 0, 0, 0.5); }
            .player-modal-content { background-color: #2c2c2c; color: #e0e0e0; padding: 20px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); position: relative; max-height: 90vh; overflow-y: auto; }
            #player-menu-modal { justify-content: flex-start; }
            #player-menu-modal .player-modal-content { background-color: #202124; width: 100%; max-width: 360px; height: 100%; max-height: 100vh; border-radius: 0; margin: 0; transform: translateX(-100%); transition: transform 0.3s ease-out; padding: 0; display: flex; flex-direction: column; }
            #player-menu-modal.visible .player-modal-content { transform: translateX(0); }
            #about-modal { justify-content: center; align-items: center; }
            #about-modal .player-modal-content {
                width: 90%;
                max-width: 700px;
                border-radius: 8px;
                font-size: 14px; /* Smaller font size for about text */
            }
            #about-modal .player-modal-close {
                position: absolute;
                top: 10px;
                right: 15px;
                font-size: 2em;
                line-height: 1;
                cursor: pointer;
                color: #aaa;
                transition: color 0.2s;
            }
            #about-modal .player-modal-close:hover {
                color: #fff;
            }
            .menu-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; flex-shrink: 0; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
            .menu-header h2 { margin: 0; border: none; font-size: 1.1em; color: #e8eaed; }
            .menu-header .player-modal-close { position: static; font-size: 1.8em; line-height: 1; }
            .menu-body { padding: 20px; overflow-y: auto; flex-grow: 1; }
            .menu-body hr { border: none; border-top: 1px solid rgba(255, 255, 255, 0.1); margin: 20px 0; }
            .menu-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; gap: 15px; }
            .menu-item button { flex-grow: 1; margin: 0; background-color: var(--secondary-color); padding: 8px 12px; }
            .menu-item button:disabled { background-color: #444; color: #888; cursor: not-allowed; }
            .menu-item span { flex-shrink: 0; color: #bdc1c6; }

            #about-title { text-align: center; }
            #about-creator { text-align: center; font-style: italic; margin-top: -10px; }
            #about-text { text-align: left; }
            #about-text a { color: #8ab4f8; text-decoration: none; }
            #about-text a:hover { text-decoration: underline; }
            .about-footer { margin-top: 20px; padding-top: 10px; border-top: 1px solid #444; font-size: 0.8em; text-align: center; white-space: pre-wrap; }
            .about-footer a { color: #8af; text-decoration: none; }

            #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #111; z-index: 9999; display: flex; justify-content: center; align-items: center; flex-direction: column; color: white; font-size: 1.5em; transition: opacity 0.5s; }
            .loading-spinner { border: 8px solid #f3f3f3; border-top: 8px solid var(--primary-color); border-radius: 50%; width: 60px; height: 60px; animation: spin 1.5s linear infinite; margin-bottom: 20px; }
            @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
            __CUSTOM_STYLES__

			.hidden {
            display: none !important;
			}
        </style>
    </head>
    <body class="__LAYOUT_CLASS__">
        <div id="loading-overlay">
            <div class="loading-spinner"></div>
            <p id="loading-status">Loading Game...</p>
			<div id="loading-progress-container" style="display: none; width: 80%; max-width: 400px; background: #444; border-radius: 5px; overflow: hidden; height: 20px; margin-top: 20px; border: 1px solid #666;">
				<div id="loading-progress-bar" style="width: 0%; height: 100%; background: var(--primary-color); transition: width 0.2s ease-out;"></div>
			</div>
        </div>

        <video id="background-video" playsinline></video>

        <div id="exit-message">
            <p>Thanks for playing!</p>
            <p>You can now close this window.</p>
        </div>
        <div id="game-container" class="__LAYOUT_CLASS__">
            <div id="image-container">
                <img id="scene-image" src="">
                <video id="scene-video" playsinline></video>
            </div>
            <div id="content-container">
                <div id="scene-text"></div>
                <div id="choices-container"></div>
            </div>
            <audio id="ambience-player"></audio>
            <audio id="music-player" loop></audio>
        </div>

        <div class="player-top-bar">
            <div class="player-top-bar-left">
                <button id="player-menu-btn" class="player-ui-btn" title="Open Menu">&#9776;</button>
                <button id="player-sound-toggle-btn" class="player-ui-btn" title="Toggle Sound">
                    <svg class="icon-on" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg>
                    <svg class="icon-off" viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"></path></svg>
                </button>
                <div id="player-video-controls">
                    <button id="player-video-play-btn" class="player-ui-btn" title="Play/Pause Video">
                        <svg class="icon-on" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>
                        <svg class="icon-off" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
                    </button>
                    <button id="player-video-mute-btn" class="player-ui-btn hidden" title="Mute/Unmute Video">
                        <svg class="icon-on" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg>
                        <svg class="icon-off" viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"></path></svg>
                    </button>
                    <button id="player-video-loop-btn" class="player-ui-btn hidden" title="Toggle Video Loop">
                        <svg viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"></path></svg>
                    </button>
                </div>
            </div>
            <div class="player-top-bar-right">
                <button id="player-close-btn" class="player-ui-btn" title="Exit Game">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
                </button>
            </div>
        </div>

        <button id="fullscreen-btn" class="player-ui-btn" title="Toggle Fullscreen">
            <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"></path></svg>
        </button>

        <div id="player-menu-modal" class="player-modal">
            <div class="player-modal-content">
                <div class="menu-header">
                    <h2>Menu</h2>
                    <span class="player-modal-close">&times;</span>
                </div>
                <div class="menu-body">
                    <div class="menu-item"><button id="restart-btn">Restart Game</button></div>
                    <hr>
                    <div class="menu-item"><button id="save-btn">Save Progress</button><button id="load-btn">Load Progress</button></div>
                    <hr>
                    <div class="menu-item"><span>Music</span><input type="range" id="volume-slider" min="0" max="1" step="0.01"></div>
                    <div class="menu-item"><span>Ambience</span><input type="range" id="ambience-volume-slider" min="0" max="1" step="0.01"></div>
                    <div class="menu-item"><span>Video</span><input type="range" id="video-volume-slider" min="0" max="1" step="0.01"></div>
                    <div class="menu-item"><span>Font Size</span><input type="range" id="font-size-slider" min="8" max="28" step="1" value="16"></div>
                    <hr>
                    <div class="menu-item"><button id="about-btn">About</button></div>
                </div>
            </div>
        </div>

        <div id="about-modal" class="player-modal">
            <div class="player-modal-content">
                <span class="player-modal-close">&times;</span>
                <h2 id="about-title"></h2>
                <p id="about-creator"></p>
                <p id="about-text"></p>
                <div class="about-footer">Created in Kinexus <a href="https://github.com/tin2tin/CYOA_Studio" target="_blank">https://github.com/tin2tin/CYOA_Studio</a></div>
            </div>
        </div>
__PLAYER_SCRIPT__
    </body>
    </html>
</template>

<!-- Main Application Logic -->
<script>
const App = {
    state: {
        storyData: {},
        currentSceneId: null,
        isDirty: false,
        contextSceneId: null,
        projectDirectoryHandle: null,
        lastAssetHandles: { images: null, sounds: null },
        pendingAssetCopies: new Map(),
        aiImageUrl: null,
        orphanSceneIds: new Set(),
        typewriter: { intervalId: null, skipListener: null },
        currentNavView: 'nodes', // 'nodes' or 'list'
        navViewsDirty: true,
        missingAssetWarnings: new Set(),
        brokenAssetLinks: new Map(),
        previewLoadId: 0,
        thumbnailLoadId: 0,
        player: {
            gameState: null,
			typewriter: { intervalId: null, skipListener: null },
            activeVideoElement: null,
        },
        debugMode: false // Secret debug mode flag
    },
    elements: {},
    constants: {
        GOOGLE_FONTS: [
            { name: "Default System Font", value: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif' },
            { name: "Architects Daughter", value: "'Architects Daughter', cursive" },
			{ name: "Asset", value: "'Asset', cursive" },
			{ name: "Atma", value: "'Atma', cursive" },
			{ name: "Audiowide", value: "'Audiowide', sans-serif" },
			{ name: "Autour One", value: "'Autour One', cursive" },
			{ name: "Averia Libre", value: "'Averia Libre', cursive" },
			{ name: "Bangers", value: "'Bangers', cursive" },
			{ name: "Big Shoulders Text", value: "'Big Shoulders Text', cursive" },
			{ name: "Birkshire Swash", value: "'Birkshire Swash', cursive" },
			{ name: "Butcherman", value: "'Butcherman', cursive" },
			{ name: "Calistoga", value: "'Calistoga', cursive" },
			{ name: "Caveat Brush", value: "'Caveat Brush', cursive" },
			{ name: "Cinzel", value: "'Cinzel', serif" },
			{ name: "Concert One", value: "'Concert One', sans-serif" },
			{ name: "Comic Neue", value: "'Comic Neue', cursive" },
			{ name: "Creepster", value: "'Creepster', cursive" },
			{ name: "Exo 2", value: "'Exo 2', sans-serif" },
			{ name: "Gamja Flower", value: "'Gamja Flower', cursive" },
			{ name: "Hachi Maru Pop", value: "'Hachi Maru Pop', cursive" },
			{ name: "Henny Penny", value: "'Henny Penny', cursive" },
			{ name: "Inconsolata", value: "'Inconsolata', monospace" },
			{ name: "Just Another Hand", value: "'Just Another Hand', cursive" },
			{ name: "Lato", value: "'Lato', sans-serif" },
			{ name: "Libre Baskerville", value: "'Libre Baskerville', serif" },
			{ name: "Limelight", value: "'Limelight', cursive" },
			{ name: "Lora", value: "'Lora', serif" },
			{ name: "MedievalSharp", value: "'MedievalSharp', cursive" },
			{ name: "Merriweather", value: "'Merriweather', serif" },
			{ name: "Metamorphous", value: "'Metamorphous', serif" },
			{ name: "Mochiy Pop One", value: "'Mochiy Pop One', sans-serif" },
			{ name: "Modern Antiqua", value: "'Modern Antiqua', serif" },
			{ name: "Montserrat", value: "'Montserrat', sans-serif" },
			{ name: "Nosifer", value: "'Nosifer', cursive" },
			{ name: "Nothing You Could Do", value: "'Nothing You Could Do', cursive" },
			{ name: "Nova Oval", value: "'Nova Oval', serif" },
			{ name: "Nunito", value: "'Nunito', sans-serif" },
			{ name: "Open Sans", value: "'Open Sans', sans-serif" },
			{ name: "Orbitron", value: "'Orbitron', sans-serif" },
			{ name: "Patrick Hand", value: "'Patrick Hand', cursive" },
			{ name: "Permanent Marker", value: "'Permanent Marker', cursive" },
			{ name: "Pirata One", value: "'Pirata One', cursive" },
			{ name: "Playfair Display", value: "'Playfair Display', serif" },
			{ name: "Poiret One", value: "'Poiret One', cursive" },
			{ name: "Road Rage", value: "'Road Rage', cursive" },
			{ name: "Roboto", value: "'Roboto', sans-serif" },
			{ name: "Smokum", value: "'Smokum', cursive" },
			{ name: "Snowburst One", value: "'Snowburst One', cursive" },
			{ name: "Source Code Pro", value: "'Source Code Pro', monospace" },
			{ name: "Special Elite", value: "'Special Elite', cursive" },
			{ name: "Uncial Antiqua", value: "'Uncial Antiqua', cursive" }
        ],
        VIDEO_EXTENSIONS: ['.mp4', '.webm', '.ogv']
    },

    init() {
        this.cacheElements();
        this.bindEvents(); // Bind generic events first
        this.nodeEditor.init(); // Then initialize modules
        this.debug.init();

        this.ui.enableEditor(false);
        this.ui.displayWelcomeMessage();
        this.modals.show('project-menu-modal');
        this.ui.setViewMode(localStorage.getItem('cyoa-nav-view') || 'scenes');
        this.ui.initDraggableDivider();
    },

    getNewStoryObject() {
        return {
            meta: {
                title: "New Story",
                startSceneId: "start",
                creatorName: "",
                aboutText: "",
                variables: [],
                styles: App.styles.getDefaults(),
                layout: 'layout-panel-bottom'
            },
            scenes: { "start": {
                id: "start", text: "Start here.", image: "", imagePrompt: "",
                videoLoop: true, videoMuted: true,
                ambienceSound: "", ambienceLoop: true, choices: [], visited: false,
                lastModified: Date.now(),
                mediaType: 'none', color: null, // New properties
                position: { x: 200, y: 50 }
            } }
        };
    },

    cacheElements() {
        const ids = [
            'editor-container', 'player-container', 'scene-id', 'scene-image',
            'scene-image-prompt', 'scene-sound', 'scene-text', 'choices-container',
            'ambience-player', 'music-player', 'export-data-modal', 'style-editor-modal', 'about-editor-modal',
            'tree-context-menu', 'editor-context-menu', 'save-project-dirty-btn',
            'save-story-btn', 'player-image', 'player-text', 'player-choices', 'player-content-container', 'player-inner-container',
            'player-video-bg', 'player-video-fg',
            'editor-fieldset', 'ai-image-preview', 'render-ai-image-btn', 'add-ai-image-btn', 'image-preview',
            'story-title', 'creator-name', 'about-text',
            'notification-modal', 'notification-message', 'notification-close-btn',
            'toggle-ambience-btn', 'ambience-play-icon', 'ambience-pause-icon', 'toggle-loop-btn',
            'scene-editor-preview', 'scene-editor-preview-wrapper', 'preview-player-video',
            'video-controls', 'toggle-video-loop-btn', 'toggle-video-mute-btn', 'toggle-video-playback-btn',
            'video-play-icon', 'video-pause-icon', 'video-unmute-icon', 'video-mute-icon',
            'media-icon-image', 'media-icon-video',
            'pollinations-text-modal', 'pollinations-instruction', 'pollinations-submit-btn', 'process-text-ai-btn',
            'style-editor-btn', 'batch-image-modal', 'batch-image-gen-btn',
            'scene-list-view', 'toggle-node-view-btn', 'toggle-scene-view-btn',
            'scene-list-view-wrapper', 'scene-list-sort', 'variable-manager-modal', 'manage-variables-btn',
            'debug-modal', 'debug-log', 'copy-debug-log-btn',
            'node-editor-view', 'node-svg-layer',
            'transform-pane', 'node-element-container', 'edge-group-container', 'temp-edge'
        ];
        ids.forEach(id => this.elements[id] = document.getElementById(id));
    },

    bindEvents() {
        document.getElementById('new-project-btn').addEventListener('click', () => App.io.newProject());
        document.getElementById('open-project-btn').addEventListener('click', () => App.io.openProject());
        App.elements['save-story-btn'].addEventListener('click', () => App.io.saveProject());
        this.elements['save-project-dirty-btn'].addEventListener('click', () => App.io.saveProject());

        document.getElementById('new-scene-btn').addEventListener('click', (e) => App.nodeEditor.addNewScene(null, e));
        document.getElementById('rename-scene-btn').addEventListener('click', () => App.tree.renameScene());
        document.getElementById('delete-scene-btn').addEventListener('click', () => App.tree.deleteCurrentScene());
        document.getElementById('add-choice-btn').addEventListener('click', () => App.editor.addChoiceToDOM());

        document.getElementById('select-image-btn').addEventListener('click', () => App.assets.selectFile('images', 'scene-image'));
        document.getElementById('select-sound-btn').addEventListener('click', () => App.assets.selectFile('sounds', 'scene-sound'));

        // Ambience Controls
        App.elements['toggle-ambience-btn'].addEventListener('click', () => App.player.toggleAmbienceSound());
        App.elements['ambience-player'].addEventListener('play', () => App.player.updateAmbienceButton(true));
        App.elements['ambience-player'].addEventListener('pause', () => App.player.updateAmbienceButton(false));
        App.elements['toggle-loop-btn'].addEventListener('click', (e) => {
            e.currentTarget.classList.toggle('active');
            App.editor.saveCurrentScene();
            App.ui.invalidateNavViews();
            App.ui.renderCurrentView();
        });

        // Video Controls
        App.elements['toggle-video-loop-btn'].addEventListener('click', (e) => {
            e.currentTarget.classList.toggle('active');
            App.editor.saveCurrentScene();
            App.editor.renderPreview();
            App.ui.invalidateNavViews();
            App.ui.renderCurrentView();
        });
        App.elements['toggle-video-mute-btn'].addEventListener('click', (e) => {
            const btn = e.currentTarget;
            btn.classList.toggle('active');
            App.editor.ui.updateVideoMuteButton(btn.classList.contains('active'));
            App.editor.saveCurrentScene();
            App.editor.renderPreview();
        });
        App.elements['toggle-video-playback-btn'].addEventListener('click', () => {
            const video = App.elements['preview-player-video'];
            if (video.paused) video.play(); else video.pause();
        });
        App.elements['preview-player-video'].addEventListener('play', () => App.editor.ui.updateVideoPlaybackButton(true));
        App.elements['preview-player-video'].addEventListener('pause', () => App.editor.ui.updateVideoPlaybackButton(false));


        // Automatic saving and UI update listeners
        const saveAndPreview = () => { App.editor.saveCurrentScene(); App.editor.renderPreview(); };
        const saveAndUpdateMediaUI = () => {
			App.editor.saveCurrentScene();
			App.editor.ui.updateMediaButtonStates();
		};

        App.elements['scene-text'].addEventListener('input', saveAndPreview);
        App.elements['choices-container'].addEventListener('input', saveAndPreview);
        App.elements['choices-container'].addEventListener('change', saveAndPreview);
        document.getElementById('scene-image-prompt').addEventListener('input', () => App.editor.saveCurrentScene());
        
        App.elements['scene-sound'].addEventListener('input', () => {
			App.editor.saveCurrentScene();
			App.editor.ui.updateMediaButtonStates();
            App.ui.invalidateNavViews();
            App.ui.renderCurrentView();
		});

		App.elements['scene-image'].addEventListener('input', (e) => {
            App.editor.saveCurrentScene();
            App.editor.ui.updateVideoControlsVisibility();
			App.editor.ui.updateMediaButtonStates();
			App.ui.updateImageThumbnail(e.target.value);
            App.ui.invalidateNavViews();
            App.ui.renderCurrentView();
		});


        ['story-title', 'creator-name', 'about-text'].forEach(id => {
            App.elements[id].addEventListener('input', (e) => {
                const key = id === 'story-title' ? 'title' : id === 'creator-name' ? 'creatorName' : 'aboutText';
                App.state.storyData.meta[key] = e.target.value;
                App.setDirty(true);
            });
        });

        App.elements['render-ai-image-btn'].addEventListener('click', () => App.assets.renderPollinationImage());
        App.elements['render-ai-image-btn'].addEventListener('contextmenu', (e) => {
            e.preventDefault();
            App.batch.open();
        });

        App.elements['add-ai-image-btn'].addEventListener('click', () => App.assets.addPollinationImageToScene());
        App.elements['process-text-ai-btn'].addEventListener('click', () => App.modals.show('pollinations-text-modal'));
        App.elements['pollinations-submit-btn'].addEventListener('click', () => App.assets.processTextWithPollinations());

        document.getElementById('play-from-start-btn').addEventListener('click', () => { App.editor.saveCurrentScene(); App.player.play(App.state.storyData.meta.startSceneId, true); });
        document.getElementById('play-from-current-btn').addEventListener('click', () => { App.editor.saveCurrentScene(); App.player.play(App.state.currentSceneId); });
        document.getElementById('stop-play-x')?.addEventListener('click', () => App.player.stop());
        document.getElementById('restart-play')?.addEventListener('click', () => App.player.play(App.state.storyData.meta.startSceneId, true));

        document.getElementById('export-project-btn').addEventListener('click', () => App.io.exportProjectZip());
        document.getElementById('preview-btn').addEventListener('click', () => App.io.previewProject());
        document.getElementById('export-data-btn').addEventListener('click', () => App.modals.show('export-data-modal'));
        (function ensureValidateButton(){
            const menu = document.querySelector('#project-menu-modal .btn-group');
            if (menu && !document.getElementById('validate-project-btn')) {
                const btn = document.createElement('button');
                btn.id = 'validate-project-btn';
                btn.className = 'btn-secondary';
                btn.textContent = 'Validate Project';
                btn.addEventListener('click', App.io.openValidationReport);
                menu.insertBefore(btn, document.getElementById('export-data-btn'));
            }
        })();
        App.elements['style-editor-btn'].addEventListener('click', () => App.styles.open());
        App.elements['batch-image-gen-btn'].addEventListener('click', () => App.batch.open());
        document.getElementById('about-editor-btn').addEventListener('click', () => App.modals.show('about-editor-modal'));

        document.querySelectorAll('.modal-close').forEach(el => el.addEventListener('click', (e) => App.modals.hide(e.target.closest('.modal'))));
        App.elements['export-data-modal'].addEventListener('click', (e) => { if(e.target.dataset.exportType) App.io.exportData(e.target.dataset.exportType); });
        document.getElementById('set-start-scene-btn').addEventListener('click', () => App.tree.setAsStartScene());
        document.addEventListener('click', () => {
            App.elements['tree-context-menu'].style.display = 'none';
            App.elements['editor-context-menu'].style.display = 'none';
        } );

        window.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal') && e.target.id !== 'about-editor-modal') {
                App.modals.hide(e.target);
            }
        });

        document.getElementById('project-menu-btn').addEventListener('click', () => App.modals.show('project-menu-modal'));
        App.elements['notification-close-btn'].addEventListener('click', () => App.modals.hide(App.elements['notification-modal']));

        // Variable Manager Events
        App.elements['manage-variables-btn'].addEventListener('click', () => App.editor.variables.showModal());
        const varModal = App.elements['variable-manager-modal'];
        const newVarInput = varModal.querySelector('#new-variable-name');
        varModal.querySelector('button').addEventListener('click', () => App.editor.variables.add());
        newVarInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); App.editor.variables.add(); } });

        document.getElementById('batch-generate-btn').addEventListener('click', () => App.batch.startGeneration());
        document.getElementById('batch-remove-images-btn').addEventListener('click', () => App.batch.removeAllImages());
        document.getElementById('batch-remove-prompts-btn').addEventListener('click', () => App.batch.removeAllImagePrompts());

        const inputs = ['scene-image', 'scene-sound'];
        inputs.forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('dragover', App.assets.handleDragOver);
            el.addEventListener('dragleave', App.assets.handleDragLeave);
            el.addEventListener('drop', App.assets.handleFileDrop);
        });

		const imagePreviewEl = document.getElementById('image-preview');
        const sceneImageInput = document.getElementById('scene-image');

        imagePreviewEl.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            imagePreviewEl.classList.add('drag-over');
        });

        imagePreviewEl.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            imagePreviewEl.classList.remove('drag-over');
        });

        imagePreviewEl.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            imagePreviewEl.classList.remove('drag-over');

            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                const file = e.dataTransfer.files[0];
                const assetTypeFolder = App.assets.isVideo(file.name) ? 'videos' : 'images';
                const destinationPath = `${assetTypeFolder}/${file.name}`;
                App.state.pendingAssetCopies.set(destinationPath, file);
                sceneImageInput.value = destinationPath;
                sceneImageInput.dispatchEvent(new Event('input', { bubbles: true }));
                App.setDirty(true);
            }
        });

        window.addEventListener('beforeunload', (e) => { if (App.state.isDirty) { e.preventDefault(); e.returnValue = ''; } });

        const searchInput = document.getElementById('scene-search-input');
        // FIX: Invalidate view on search input to trigger live filtering
        searchInput.addEventListener('input', () => { App.ui.invalidateNavViews(); App.ui.renderCurrentView(); });
        document.getElementById('scene-search-btn').addEventListener('click', () => { App.ui.invalidateNavViews(); App.ui.renderCurrentView(); });


        App.elements['toggle-node-view-btn'].addEventListener('click', () => App.ui.setViewMode('nodes'));
        App.elements['toggle-scene-view-btn'].addEventListener('click', () => App.ui.setViewMode('list'));
        App.elements['scene-list-sort'].addEventListener('change', () => App.sceneList.render());

        // Node Editor Controls
        document.getElementById('node-auto-arrange-btn').addEventListener('click', () => App.nodeEditor.autoArrange());
        document.getElementById('node-find-orphans-btn').addEventListener('click', () => App.nodeEditor.findNextOrphan());
        document.getElementById('node-zoom-in-btn').addEventListener('click', () => App.nodeEditor.zoom(1.2));
        document.getElementById('node-zoom-out-btn').addEventListener('click', () => App.nodeEditor.zoom(1 / 1.2));
        document.getElementById('node-fit-view-btn').addEventListener('click', () => App.nodeEditor.fitView());


        document.querySelectorAll('.thumbnail-fullscreen-icon').forEach(icon => {
            icon.addEventListener('click', (e) => {
                e.stopPropagation();
                const parentPreview = e.currentTarget.parentElement;
                const img = parentPreview.querySelector('img, canvas');
                if (img?.src && !img.src.startsWith('data:image/gif')) {
                    App.ui.showFullscreenImage(img.src);
                } else if (img?.toDataURL) {
                    App.ui.showFullscreenImage(img.toDataURL());
                }
            });
        });
        document.getElementById('fullscreen-minimize').addEventListener('click', () => App.modals.hide(document.getElementById('fullscreen-viewer')));
        document.getElementById('fullscreen-viewer').addEventListener('click', (e) => {
            if (e.target.id === 'fullscreen-viewer') {
                App.modals.hide(document.getElementById('fullscreen-viewer'));
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                App.modals.hideAll();
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                if (App.state.projectDirectoryHandle && document.getElementById('editor-container').style.display !== 'none') {
                    App.io.saveProject();
                }
            }
        });

        // Tooltip Logic
        const tooltip = document.getElementById('custom-tooltip');
        const thumbnailTooltip = document.getElementById('icon-thumbnail-tooltip');
        let activeTooltip = null;

        document.body.addEventListener('mouseover', e => {
            const iconTarget = e.target.closest('[class*="icon-"]');
            const titleTarget = e.target.closest('[title]');

            if (iconTarget && App.ui.iconThumbnails[iconTarget.classList[0]]) {
                activeTooltip = thumbnailTooltip;
                const iconClass = Array.from(iconTarget.classList).find(c => c.startsWith('icon-'));
                App.ui.showIconThumbnail(App.ui.iconThumbnails[iconClass]);
            } else if (titleTarget && titleTarget.title) {
                activeTooltip = tooltip;
                tooltip.textContent = titleTarget.title;
                titleTarget.dataset.originalTitle = titleTarget.title;
                titleTarget.removeAttribute('title');
                tooltip.style.display = 'block';
                requestAnimationFrame(() => { tooltip.style.opacity = '1'; });
            }
        });

        document.body.addEventListener('mouseout', () => {
            if (activeTooltip) {
                if (activeTooltip === tooltip) {
                    const originalTarget = document.querySelector('[data-original-title]');
                    if (originalTarget) {
                        originalTarget.setAttribute('title', originalTarget.dataset.originalTitle);
                        originalTarget.removeAttribute('data-original-title');
                    }
                }
                activeTooltip.style.opacity = '0';
                const tooltipRef = activeTooltip;
                setTimeout(() => {
                    if (tooltipRef && tooltipRef.style.opacity === '0') {
                        tooltipRef.style.display = 'none';
                    }
                }, 150);
                activeTooltip = null;
            }
        });

        document.body.addEventListener('mousemove', e => {
            if (activeTooltip) {
                const x = e.clientX;
                const y = e.clientY;
                const tooltipRect = activeTooltip.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                let top = y + 24;
                let left = x + 12;

                if (left + tooltipRect.width > viewportWidth) {
                    left = x - tooltipRect.width - 12;
                }
                if (top + tooltipRect.height > viewportHeight) {
                    top = y - tooltipRect.height - 24;
                }
                if (left < 0) left = 0;
                if (top < 0) top = 0;

                activeTooltip.style.left = `${left}px`;
                activeTooltip.style.top = `${top}px`;
            }
        });
    },

    setDirty(isDirty) {
        this.state.isDirty = isDirty;
        this.elements['save-project-dirty-btn'].style.display = isDirty ? 'inline-flex' : 'none';
        this.elements['save-project-dirty-btn'].classList.toggle('dirty', isDirty);
        this.elements['save-story-btn'].classList.toggle('dirty', isDirty);
    },

    markdown: {
        parse(text) {
            if (!text) return '';
            let html = text
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/__(.*?)__/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/_(.*?)_/g, '<em>$1</em>')
                .replace(/~~(.*?)~~/g, '<s>$1</s>')
                .replace(/`(.*?)`/g, '<code>$1</code>')
                .replace(/\n/g, '<br>');
            return html;
        }
    },

	ui: {
		cursor: {
			wait() { document.body.style.cursor = 'wait'; },
			default() { document.body.style.cursor = 'default'; }
		},
        initDraggableDivider() {
            const resizer = document.getElementById('resizer');
            const leftPanel = document.getElementById('left-panel-container');
            let isResizing = false;

             const updateConstraints = () => {
                const minWidth = window.innerWidth * 0.25;
                const maxWidth = window.innerWidth * 0.75;
                let currentWidth = leftPanel.offsetWidth;
                if (currentWidth < minWidth) leftPanel.style.width = `${minWidth}px`;
                if (currentWidth > maxWidth) leftPanel.style.width = `${maxWidth}px`;
            };

            resizer.addEventListener('mousedown', (e) => {
                e.preventDefault();
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', stopResize);
            });

            function handleMouseMove(e) {
                if (!isResizing) return;
                const minWidth = window.innerWidth * 0.25;
                const maxWidth = window.innerWidth * 0.75;
                let newWidth = e.clientX;
                if (newWidth < minWidth) newWidth = minWidth;
                if (newWidth > maxWidth) newWidth = maxWidth;
                leftPanel.style.width = `${newWidth}px`;
                App.nodeEditor.onResize();
            }

            function stopResize() {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                window.removeEventListener('mousemove', handleMouseMove);
                window.removeEventListener('mouseup', stopResize);
            }
            window.addEventListener('resize', updateConstraints);
            updateConstraints(); // Initial call
        },
		invalidateNavViews() {
			if (!App.state.navViewsDirty) {
				App.state.navViewsDirty = true;
			}
		},
		async setViewMode(mode) {
            if (!App.state.projectDirectoryHandle) return;

			if (App.state.navViewsDirty) {
				this.cursor.wait();
				App.debug.log('UI view is dirty. Re-rendering navigation views...', 'INFO');
				try {
					await App.io.checkAllProjectAssets(); // Check for broken links before rendering
					const filterTerm = document.getElementById('scene-search-input').value;
					if (App.nodeEditor) await App.nodeEditor.render(filterTerm);
					if (App.sceneList) await App.sceneList.render(filterTerm);
					App.state.navViewsDirty = false;
					App.debug.log('Navigation views re-rendered successfully.', 'SUCCESS');
				} finally {
					this.cursor.default();
				}
			}

			App.state.currentNavView = mode;
			localStorage.setItem('cyoa-nav-view', mode);

			const isNodeView = mode === 'nodes';
			App.elements['node-editor-view'].style.display = isNodeView ? 'flex' : 'none';
			App.elements['scene-list-view-wrapper'].style.display = isNodeView ? 'none' : 'flex';

			App.elements['toggle-node-view-btn'].classList.toggle('active', isNodeView);
			App.elements['toggle-scene-view-btn'].classList.toggle('active', !isNodeView);

            if (isNodeView) {
                App.nodeEditor.onResize(); // Ensure canvas is correctly sized
            }
		},
		async renderCurrentView() {
			if (!App.state.projectDirectoryHandle) {
				this.displayWelcomeMessage();
				return;
			}
			await this.setViewMode(App.state.currentNavView);
		},

		async selectScene(sceneId) {
			if (!sceneId || !App.state.storyData.scenes[sceneId]) {
				console.error(`Attempted to select non-existent scene: ${sceneId}`);
				return;
			}

			const isPlayerActive = App.elements['player-container'].style.display === 'flex';

			if (!isPlayerActive && App.state.currentSceneId) {
				App.editor.saveCurrentScene();
			}

			App.elements['ambience-player'].pause();
			const previewVideo = App.elements['preview-player-video'];
			if(previewVideo && !previewVideo.paused) {
				previewVideo.pause();
				previewVideo.removeAttribute('src');
				previewVideo.load();
			}

			if (isPlayerActive) {
				await App.player.renderScene(sceneId);
				return;
			}

			const oldSceneId = App.state.currentSceneId;
			App.state.currentSceneId = sceneId;

            // Update Scene List View
            const oldCardNode = document.querySelector(`.scene-card.active`);
            if(oldCardNode) oldCardNode.classList.remove('active');
            const newCardNode = document.querySelector(`.scene-card[data-scene-id="${sceneId}"]`);
            if (newCardNode) newCardNode.classList.add('active');

            // Update Node Editor View
            App.nodeEditor.updateSelection();

			App.editor.render();

			requestAnimationFrame(() => {
				const activeNode = document.querySelector(`.scene-card.active`);
				if (activeNode) {
					activeNode.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
				}
			});
		},

		enableEditor(isEnabled) {
			App.elements['editor-fieldset'].disabled = !isEnabled;
			document.getElementById('new-scene-btn').disabled = !isEnabled;
			document.getElementById('scene-search-input').disabled = !isEnabled;
			document.getElementById('scene-search-btn').disabled = !isEnabled;
			App.elements['save-story-btn'].disabled = !isEnabled;
			document.getElementById('export-project-btn').disabled = !isEnabled;
			document.getElementById('export-data-btn').disabled = !isEnabled;
			App.elements['style-editor-btn'].disabled = !isEnabled;
			document.getElementById('about-editor-btn').disabled = !isEnabled;

			const batchBtn = App.elements['batch-image-gen-btn'];
			if (batchBtn) {
				batchBtn.disabled = !isEnabled;
				if (isEnabled) {
					batchBtn.classList.remove('btn-secondary');
					batchBtn.classList.add('btn-purple');
				} else {
					batchBtn.classList.remove('btn-purple');
					batchBtn.classList.add('btn-secondary');
				}
			}
		},
		displayWelcomeMessage() {
            App.elements['node-element-container'].innerHTML = '';
			const welcomeDiv = document.createElement('div');
			welcomeDiv.style.margin = 'auto';
			welcomeDiv.style.textAlign = 'center';
            welcomeDiv.style.padding = '50px';
            welcomeDiv.style.color = 'var(--text-secondary)';
			welcomeDiv.innerHTML = `Welcome! Please create a <strong>New Project</strong> or <strong>Open an existing one</strong> to begin.`;
			App.elements['node-element-container'].appendChild(welcomeDiv);

			App.elements['scene-list-view'].innerHTML = `<li style="padding:10px; color: var(--text-secondary);">Welcome! Please create a project to see scenes here.</li>`;
			document.getElementById('scene-search-input').disabled = true;
			document.getElementById('scene-search-btn').disabled = true;
		},
		updateAiImagePreview(url, message = '') {
			const preview = App.elements['ai-image-preview'];
			const icon = preview.querySelector('.thumbnail-fullscreen-icon');
			preview.innerHTML = '';
			if (icon) preview.appendChild(icon);

			if (url) {
				const img = document.createElement('img');
				img.src = url;
				preview.appendChild(img);
			} else {
				const span = document.createElement('span');
				span.textContent = message || 'Preview';
				preview.appendChild(span);
			}
		},
		async updateImageThumbnail(path) {
			App.state.thumbnailLoadId++;
			const currentLoadId = App.state.thumbnailLoadId;

			const preview = App.elements['image-preview'];
			const icon = preview.querySelector('.thumbnail-fullscreen-icon');
			preview.innerHTML = '';
			if(icon) preview.appendChild(icon);
			const defaultSpan = document.createElement('span');
			defaultSpan.textContent = 'Thumbnail';
			preview.appendChild(defaultSpan);

			App.editor.renderPreview(); // Trigger a preview render to handle video/image switching
			if (!path) return;

			try {
				defaultSpan.textContent = 'Loading...';
				const isVideo = App.assets.isVideo(path);
				const url = await (isVideo ? App.assets.getVideoThumbnail(path) : App.io.getAssetDataUrl(path));

				if (currentLoadId !== App.state.thumbnailLoadId) return;

				if (url) {
					preview.innerHTML = '';
					if(icon) preview.appendChild(icon);
					const mediaElement = document.createElement(isVideo ? 'canvas' : 'img');
					if (isVideo) {
						const img = new Image();
						img.onload = () => {
							mediaElement.width = img.width;
							mediaElement.height = img.height;
							mediaElement.getContext('2d').drawImage(img, 0, 0);
						}
						img.src = url;
					} else {
						 mediaElement.src = url;
					}
					preview.appendChild(mediaElement);
				} else {
					 defaultSpan.textContent = 'Invalid Path';
				}
			} catch (e) {
				if (currentLoadId === App.state.thumbnailLoadId) {
					defaultSpan.textContent = 'Invalid Path';
				}
				console.warn('Thumbnail load failed:', e);
			}
		},
		updateMetaInputs() {
			const meta = App.state.storyData?.meta;
			App.elements['story-title'].value = meta?.title || '';
			App.elements['creator-name'].value = meta?.creatorName || '';
			App.elements['about-text'].value = meta?.aboutText || '';
		},
		showFullscreenImage(src) {
			document.getElementById('fullscreen-image').src = src;
			App.modals.show('fullscreen-viewer');
		},
		showNotification(message) {
			App.elements['notification-message'].innerHTML = message;
			App.modals.show('notification-modal');
		},
        showCustomPrompt({ text, value, event, callback }) {
            let existingOverlay = document.getElementById('custom-prompt-overlay');
            if (existingOverlay) existingOverlay.remove();

            const overlay = document.createElement('div');
            overlay.id = 'custom-prompt-overlay';

            const promptDiv = document.createElement('div');
            promptDiv.id = 'custom-prompt';
            promptDiv.innerHTML = `
                <p>${text}</p>
                <input type="text" id="custom-prompt-input" value="${value}">
                <div id="custom-prompt-buttons">
                    <button id="custom-prompt-cancel" class="btn-secondary">Cancel</button>
                    <button id="custom-prompt-ok" class="btn-success">OK</button>
                </div>
            `;
            
            if (event) {
                 promptDiv.style.left = `${event.clientX}px`;
                 promptDiv.style.top = `${event.clientY}px`;
            } else {
                 promptDiv.style.left = `50%`;
                 promptDiv.style.top = `30%`;
                 promptDiv.style.transform = `translate(-50%, -50%)`;
            }

            overlay.appendChild(promptDiv);
            document.body.appendChild(overlay);

            const input = document.getElementById('custom-prompt-input');
            input.focus();
            input.select();

            const closePrompt = (result) => {
                overlay.remove();
                callback(result);
            };

            document.getElementById('custom-prompt-ok').onclick = () => closePrompt(input.value);
            document.getElementById('custom-prompt-cancel').onclick = () => closePrompt(null);
            overlay.onclick = (e) => { if (e.target === overlay) closePrompt(null); };
            input.onkeydown = (e) => {
                if (e.key === 'Enter') closePrompt(input.value);
                if (e.key === 'Escape') closePrompt(null);
            };
        },
		showIconThumbnail(data) {
			const tooltip = document.getElementById('icon-thumbnail-tooltip');
			tooltip.querySelector('.thumbnail-icon').innerHTML = data.icon;
			tooltip.querySelector('h4').textContent = data.title;
			tooltip.querySelector('p').textContent = data.desc;
			tooltip.style.display = 'flex';
			requestAnimationFrame(() => { tooltip.style.opacity = '1'; });
		},
		showProgress(message) {
			let progressModal = document.getElementById('progress-modal');
			if (!progressModal) {
				progressModal = document.createElement('div');
				progressModal.id = 'progress-modal';
				progressModal.className = 'modal';
				progressModal.style.backgroundColor = 'rgba(0,0,0,0.7)';
				progressModal.innerHTML = `
					<div class="modal-content" style="max-width: 400px; text-align: center;">
						<h3 style="margin-top:0;">Loading Project</h3>
						<p id="progress-message"></p>
					</div>
				`;
				document.body.appendChild(progressModal);
			}
			progressModal.classList.add('visible');
			document.getElementById('progress-message').innerHTML = message;
		},
		hideProgress() {
			const progressModal = document.getElementById('progress-modal');
			if (progressModal) {
				progressModal.classList.remove('visible');
			}
		},
		iconThumbnails: {
			'icon-start': {
				icon: `<svg class="icon-start" viewBox="0 0 16 16"><path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>`,
				title: 'Start Scene',
				desc: 'This is the first scene players will see when the story begins.'
			},
			'icon-image': {
				icon: `<svg class="icon-image" viewBox="0 0 16 16"><path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/><path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/></svg>`,
				title: 'Has Image/Video',
				desc: 'This scene has an associated background image or video.'
			},
			'icon-sound': {
				icon: `<svg class="icon-sound" viewBox="0 0 16 16"><path d="M9.707,2.293a1,1,0,0,0-1.414,0L4.6,6H2.5A1.5,1.5,0,0,0,1,7.5v1A1.5,1.5,0,0,0,2.5,10H4.6l3.69,3.707a1,1,0,0,0,1.414,0V2.293Z"/></svg>`,
				title: 'Has Audio',
				desc: 'This scene has ambient sound or music that will play.'
			},
			 'icon-condition': {
				icon: `<svg class="icon-condition" viewBox="0 0 16 16"><path d="M11 12L19 8 M11 12L19 16 M3 12h8"/><circle cx="3" cy="12" r="2"/><circle cx="19" cy="8" r="2"/><circle cx="19" cy="16" r="2"/></svg>`,
				title: 'Has Conditions',
				desc: 'This scene contains one or more choices that depend on a variable or a previously visited scene.'
			},
				'icon-deadend': {
					icon: `<svg class="icon-deadend" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
							  <circle cx="8" cy="8" r="7.5" fill="none" stroke="currentColor" stroke-width="1" />
							  <rect x="3" y="6.5" width="10" height="3" fill="currentColor" />
						   </svg>`,
					title: 'Dead End',
					desc: 'This scene has no choices that create a button, and ends a branch of the story.'
				},
				'icon-orphan': {
					icon: `<svg class="icon-orphan" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
							  <rect x="7" y="2" width="2" height="12" fill="currentColor" />
							  <rect x="2" y="7" width="12" height="2" fill="currentColor" />
						   </svg>`,
					title: 'Orphan Scene',
					desc: 'This scene cannot be reached from the main story flow.'
				}
		}
	},

	io: {
        async verifyPermission(directoryHandle) {
            const options = { mode: 'readwrite' };
            if ((await directoryHandle.queryPermission(options)) === 'granted') {
                return true;
            }
            if ((await directoryHandle.requestPermission(options)) === 'granted') {
                return true;
            }
            return false;
        },

        async saveProject() {
            if (!App.state.projectDirectoryHandle) {
                // If there's no directory handle, this will trigger the "Save As" flow
                return await App.io.saveProjectAs();
            }

            try {
                // The "Saving..." notification has been removed to make the final confirmation more prominent.
        
                const storyFileHandle = await App.state.projectDirectoryHandle.getFileHandle('story.json', { create: true });
                const writable = await storyFileHandle.createWritable();

                await writable.write(JSON.stringify(App.state.storyData, null, 2));
                await writable.close();

                // Copy any pending new assets (images, sounds, etc.)
                if (App.state.pendingAssetCopies.size > 0) {
                    for (const [path, file] of App.state.pendingAssetCopies.entries()) {
                        const pathParts = path.split('/');
                        const fileName = pathParts.pop();
                        let dirHandle = App.state.projectDirectoryHandle;
                        for (const part of pathParts) {
                            dirHandle = await dirHandle.getDirectoryHandle(part, { create: true });
                        }
                        const newFileHandle = await dirHandle.getFileHandle(fileName, { create: true });
                        const assetWritable = await newFileHandle.createWritable();
                        await assetWritable.write(file);
                        await assetWritable.close();
                    }
                    App.state.pendingAssetCopies.clear();
                }

                App.setDirty(false);
                // Now, show the single, clear confirmation pop-up.
                App.ui.showNotification(`Project '${App.state.storyData.meta.title}' saved!`);

            } catch (err) {
                console.error("Failed to save project:", err);
                App.ui.showNotification(`Could not save project: ${err.name}`);
            }
        },

        async saveProjectAs() {
            try {
                const dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
                if (dirHandle) {
                    App.state.projectDirectoryHandle = dirHandle;
                    // After selecting a directory, call the main save function
                    await App.io.saveProject();
                }
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('Save As was aborted or failed:', err);
                    App.ui.showNotification(`Could not save project: ${err.name}`);
                }
            }
        },

        async openValidationReport() {
            if (!App.state.projectDirectoryHandle) {
                App.ui.showNotification('Please open a project first.');
                return;
            }
            try {
                const storyFileHandle = await App.state.projectDirectoryHandle.getFileHandle('story.json');
                const file = await storyFileHandle.getFile();
                const content = await file.text();
                let raw;
                try {
                    raw = JSON.parse(content);
                } catch (e) {
                    App.ui.showNotification(`<b>Validation Error:</b><br>Malformed JSON in story.json<br><br><i>${e.message}</i>`);
                    return;
                }
                const result = await App.io.validateProjectData(raw, { autofix: false });
                if (!result.ok) {
                    App.ui.showNotification(`<b>Validation Failed:</b><br>${result.errors.join('<br>')}`);
                    return;
                }
                const warnings = result.warnings && result.warnings.length ? ('<br><br><b>Warnings:</b><br>' + result.warnings.map(w => '• ' + w).join('<br>')) : '';
                App.ui.showNotification(`<b>Validation OK</b>${warnings}`);
            } catch (err) {
                console.error('Validation error:', err);
                App.ui.showNotification('Validation failed due to an unexpected error.');
            }
        },

        async validateProjectData(rawStoryData, { autofix = true, onProgress = null } = {}) {
            return new Promise(async (resolve) => {
                const warnings = [];
                const errors = [];
                const defaultStory = App.getNewStoryObject();
                let storyData = rawStoryData;

                if (typeof storyData !== 'object' || storyData === null) {
                    errors.push("Project root is not an object.");
                    return resolve({ ok: false, data: defaultStory, warnings, errors });
                }

                storyData.meta = { ...defaultStory.meta, ...(storyData.meta || {}) };

                // Backwards compatibility for old layout name
                if (storyData.meta.layout === 'layout-image-as-bg') {
                    storyData.meta.layout = 'layout-panel-bottom';
                    warnings.push("Updated 'layout-image-as-bg' to 'layout-panel-bottom'.");
                }

                // Remove obsolete container background image property
                if (storyData.meta.styles && storyData.meta.styles['--container-bg-image']) {
                    delete storyData.meta.styles['--container-bg-image'];
                    warnings.push("Removed obsolete 'container-bg-image' style property.");
                }

                if (typeof storyData.meta.variables === 'object' && !Array.isArray(storyData.meta.variables) && storyData.meta.variables !== null) {
                    warnings.push("'meta.variables' was an object. Converting to an array of keys.");
                    storyData.meta.variables = Object.keys(storyData.meta.variables);
                } else if (!Array.isArray(storyData.meta.variables)) {
                    warnings.push("'meta.variables' was not an array. Reset to empty array.");
                    storyData.meta.variables = [];
                }

                if (typeof storyData.scenes !== 'object' || storyData.scenes === null) {
                    warnings.push("'scenes' missing or invalid. Initialized with default 'start' scene.");
                    storyData.scenes = { ...defaultStory.scenes };
                }

                const sanitizedScenes = {};
                const sceneEntries = Object.entries(storyData.scenes);
                const totalScenes = sceneEntries.length;
                let currentIndex = 0;
                const CHUNK_SIZE = 25; // Process scenes in small batches

                const processChunk = async () => {
                    const limit = Math.min(currentIndex + CHUNK_SIZE, totalScenes);

                    for (let i = currentIndex; i < limit; i++) {
                        const [key, sceneObj] = sceneEntries[i];
                        const scene = (typeof sceneObj === 'object' && sceneObj !== null) ? sceneObj : {};

                        // BACKWARDS COMPATIBILITY: Ensure position exists
                        let position = scene.position;
                        if (typeof position !== 'object' || typeof position.x !== 'number' || typeof position.y !== 'number') {
                            warnings.push(`Scene '${key}' was missing position data. Auto-placing node.`);
                            position = { x: (i % 5) * 280, y: Math.floor(i / 5) * 250 };
                        }

                        const safeChoices = (Array.isArray(scene.choices) ? scene.choices : []).map(c => {
                            if (!c || typeof c !== 'object') return null;
                            if (c.action === undefined) {
                                if (i === currentIndex) { // Log this warning only once per chunk
                                    warnings.push(`Upgraded old choice format in scene '${key}'.`);
                                }
                                return {
                                    condition: null,
                                    action: { text: c.text || '', target: c.target || '', set_variable: null, set_value: false }
                                };
                            }
                            // Sanitize modern choice format
                            return {
                                condition: (c.condition && typeof c.condition.variable === 'string') ? { variable: c.condition.variable, value: c.condition.value === true } : null,
                                action: {
                                    text: typeof c.action?.text === 'string' ? c.action.text : '',
                                    target: typeof c.action?.target === 'string' ? c.action.target : null,
                                    set_variable: typeof c.action?.set_variable === 'string' ? c.action.set_variable : null,
                                    set_value: c.action?.set_value === true
                                }
                            };
                        }).filter(Boolean);

                        sanitizedScenes[key] = {
                            id: key,
                            text: typeof scene.text === 'string' ? scene.text : '',
                            image: typeof scene.image === 'string' ? scene.image : '',
                            imagePrompt: typeof scene.imagePrompt === 'string' ? scene.imagePrompt : '',
                            videoLoop: scene.videoLoop ?? true,
                            videoMuted: scene.videoMuted ?? true,
                            ambienceSound: typeof scene.ambienceSound === 'string' ? scene.ambienceSound : '',
                            ambienceLoop: scene.ambienceLoop ?? true,
                            choices: safeChoices,
                            visited: scene.visited === true,
                            lastModified: typeof scene.lastModified === 'number' ? scene.lastModified : Date.now(),
                            mediaType: scene.mediaType || 'none', // New property
                            color: scene.color || null, // New property
                            position: position
                        };
                    }

                    currentIndex = limit;

                    if (onProgress) {
                        onProgress(currentIndex / totalScenes, `Processing scene ${currentIndex} of ${totalScenes}...`);
                    }

                    if (currentIndex < totalScenes) {
                        await App.debug.yieldToMain(); // Yield to main thread
                        await processChunk();
                    } else {
                        // All scenes processed, finalize
                        storyData.scenes = sanitizedScenes;
                        if (Object.keys(storyData.scenes).length === 0) {
                            warnings.push("No valid scenes found. Added default 'start' scene.");
                            storyData.scenes = { ...defaultStory.scenes };
                        }
                        if (!storyData.meta.startSceneId || !storyData.scenes[storyData.meta.startSceneId]) {
                            const old = storyData.meta.startSceneId;
                            const fallback = Object.keys(storyData.scenes)[0];
                            storyData.meta.startSceneId = fallback;
                            warnings.push(`Start scene '${old || '(none)'}' was invalid. Using '${fallback}'.`);
                        }
                        resolve({ ok: errors.length === 0, data: storyData, warnings, errors });
                    }
                };

                await processChunk(); // Start the async processing
            });
        },
        async newProject() {
            try {
                const dirHandle = await window.showDirectoryPicker({ mode: 'readwrite', startIn: App.state.projectDirectoryHandle || 'documents' });

                let projectName = prompt("Enter a name for your new project:", "My Kinexus Story");
                if (!projectName) return;
                projectName = projectName.trim().replace(/[\s/\\?%*:|"<>]/g, '_');

                let projectHandle;
                try {
                    projectHandle = await dirHandle.getDirectoryHandle(projectName);
                    await projectHandle.getFileHandle('story.json');
                    if (confirm(`Project '${projectName}' already exists. Do you want to open it instead?`)) {
                        await App.io.openProject(projectHandle);
                        return;
                    } else {
                         return;
                    }
                } catch (e) {
                    if (e.name === 'NotFoundError') {
                        projectHandle = await dirHandle.getDirectoryHandle(projectName, { create: true });
                    } else {
                        throw e;
                    }
                }

                await projectHandle.getDirectoryHandle('images', { create: true });
                await projectHandle.getDirectoryHandle('sounds', { create: true });
                await projectHandle.getDirectoryHandle('videos', { create: true });

                const storyFileHandle = await projectHandle.getFileHandle('story.json', { create: true });
                const writable = await storyFileHandle.createWritable();
                const newStory = App.getNewStoryObject();
                newStory.meta.title = projectName.replace(/_/g, ' ');
                await writable.write(JSON.stringify(newStory, null, 2));
                await writable.close();

                App.state.projectDirectoryHandle = projectHandle;
                App.state.storyData = newStory;
                App.state.pendingAssetCopies.clear();
                App.modals.hideAll();
                App.ui.enableEditor(true);
                App.setDirty(false);
                App.ui.updateMetaInputs();
                App.ui.invalidateNavViews();
                await App.ui.setViewMode(App.state.currentNavView);
                App.ui.selectScene('start');
                App.nodeEditor.centerOnNode('start');
                App.ui.showNotification(`Project '${projectName}' created successfully!`);

            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error(err);
                    App.ui.showNotification(`Could not create the project. Error: ${err.name}`);
                }
            }
        },

        async openProject(dirHandle = null) {
            if (App.state.debugMode) {
                App.debug.clear();
                App.debug.log('--- Starting Project Import ---', 'INFO');
                App.modals.show('debug-modal');
            }
            App.ui.showProgress('Opening project...');
            App.ui.cursor.wait();
            try {
                App.player.stop();
                if (!dirHandle) {
                    App.debug.log('Opening directory picker...');
                    dirHandle = await window.showDirectoryPicker({ mode: 'readwrite', startIn: App.state.projectDirectoryHandle || 'documents' });
                    App.debug.log('Directory handle acquired.', 'SUCCESS');
                }

                App.debug.log(`Verifying permissions for directory: ${dirHandle.name}...`, 'INFO');
                const hasPermission = await this.verifyPermission(dirHandle);
                if (!hasPermission) {
                    App.debug.log('Permission to access directory was denied.', 'ERROR');
                    App.ui.showNotification('Permission to access the project folder was denied. Please try opening the project again.');
                    return;
                }
                App.debug.log('Permissions verified successfully.', 'SUCCESS');

                App.debug.log('Resetting application state...');
                App.ui.enableEditor(false);
                App.state.storyData = {};
                App.state.currentSceneId = null;
                App.state.projectDirectoryHandle = null;
                App.state.pendingAssetCopies.clear();
                App.state.missingAssetWarnings.clear();
                App.setDirty(false);
                App.elements['node-element-container'].innerHTML = '';
                App.elements['scene-list-view'].innerHTML = '';
                document.getElementById('scene-search-input').value = '';
                App.editor.render();
                App.ui.updateMetaInputs();
                App.debug.log('State reset complete.', 'SUCCESS');

                let storyData;
                let fileContent = '';
                try {
                    App.debug.log('Attempting to get handle for "story.json"...');
                    const storyFileHandle = await dirHandle.getFileHandle('story.json');
                    App.debug.log('"story.json" handle acquired.', 'SUCCESS');

                    App.debug.log('Attempting to get file object from handle...');
                    const file = await storyFileHandle.getFile();
                    App.debug.log(`File object acquired. Size: ${file.size} bytes.`, 'SUCCESS');

                    App.debug.log('Reading file content as text...');
                    fileContent = await file.text();
                    App.debug.log(`File content read (${fileContent.length} chars). Parsing JSON...`, 'SUCCESS');

                    storyData = fileContent.trim() ? JSON.parse(fileContent) : App.getNewStoryObject();
                    App.debug.log('JSON parsed successfully.', 'SUCCESS');

                } catch (e) {
                    App.debug.log(`Error during file processing: ${e.name} - ${e.message}`, 'ERROR');
                    if (e instanceof SyntaxError) {
                        App.debug.log(`Malformed JSON detected. Raw content:\n${fileContent}`, 'ERROR');
                    }
                    if (e.name === 'NotFoundError') {
                        App.debug.log('"story.json" not found, creating new default story object.');
                        storyData = App.getNewStoryObject();
                    } else { throw e; }
                }

                App.debug.log('Validating and migrating project data asynchronously...');
                const onProgress = (percent, message) => {
                    const progressMessage = `Upgrading project structure... (${Math.round(percent * 100)}%)<br><small>${message}</small>`;
                    App.ui.showProgress(progressMessage);
                    if (App.state.debugMode) {
                        App.debug.log(`Migration progress: ${Math.round(percent * 100)}% - ${message}`, 'INFO');
                    }
                };
                const result = await App.io.validateProjectData(storyData, { autofix: true, onProgress });

                storyData = result.data;
                App.debug.log(`Validation complete. Warnings: ${result.warnings.length}. Errors: ${result.errors.length}.`, 'INFO');
                if (result.warnings.length > 0) {
                     App.debug.log('Validation Warnings:\n' + result.warnings.join('\n'), 'WARN');
                }

                App.ui.showProgress('Finishing up...');
                App.debug.log('Populating application with project data...');
                App.state.storyData = storyData;
                App.state.projectDirectoryHandle = dirHandle;
                App.styles.loadGoogleFont(App.state.storyData.meta.styles['--font-family']);
                if(!App.state.debugMode) App.modals.hideAll();
                App.ui.enableEditor(true);
                App.ui.updateMetaInputs();
                App.ui.invalidateNavViews();
                await App.ui.setViewMode(App.state.currentNavView);
                await App.ui.selectScene(App.state.storyData.meta.startSceneId);
                App.nodeEditor.fitView(); // Fit view on load instead of centering

                App.debug.log('Ensuring asset folders exist...');
                await dirHandle.getDirectoryHandle('images', { create: true });
                await dirHandle.getDirectoryHandle('sounds', { create: true });
                await dirHandle.getDirectoryHandle('videos', { create: true });
                App.debug.log('Asset folders checked/created.', 'SUCCESS');

                let finalNotification = `Project '${App.state.storyData.meta.title}' loaded successfully!`;
                if (result.warnings.length) {
                    finalNotification += `<br><br><b>Note:</b> The project format was updated. Please save the project to make this change permanent and ensure faster loading in the future.`;
                }
                App.ui.showNotification(finalNotification);

            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error("Failed to open project:", err);
                    App.debug.log(`CRITICAL FAILURE: ${err.name} - ${err.message}\n${err.stack}`, 'ERROR');
                    App.ui.showNotification(`A critical error occurred while opening the project: ${err.name}`);
                } else {
                     App.debug.log('User aborted directory picker.', 'INFO');
                }
            } finally {
                App.ui.cursor.default();
                App.ui.hideProgress();
            }
        },

        async getFormattedPlayerHTML(isForExport = false) {
            if (!App.state.storyData.meta) return ''; // Guard against no project
				const storyData = JSON.parse(JSON.stringify(App.state.storyData));
				let storyJsonString;

				// Stringify the data first
				if (isForExport) {
					storyJsonString = JSON.stringify(storyData, null, 2);
				} else {
					storyJsonString = JSON.stringify(storyData);
				}

			// NOW, make it safe for HTML injection by escaping the '<' character.
			storyJsonString = storyJsonString.replace(/</g, '\\u003c');

            let googleFontLink = '';
            const fontFamily = storyData.meta.styles['--font-family'] || App.styles.getDefaults()['--font-family'];
            const fontName = fontFamily.split(',')[0].replace(/'/g, '').trim();
            const isGoogleFont = App.constants.GOOGLE_FONTS.find(f => f.name === fontName && !f.value.startsWith('-'));

            if (isGoogleFont) {
                const formattedFontName = fontName.replace(/ /g, '+');
                googleFontLink = `<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=${formattedFontName}:wght@400;700&display=swap">`;
            }

            const playerScript = `
        <script>
            document.addEventListener('DOMContentLoaded', () => {
                const storyData = ${storyJsonString};
                const sceneImage = document.getElementById('scene-image'), sceneVideo = document.getElementById('scene-video'), sceneText = document.getElementById('scene-text'), choicesContainer = document.getElementById('choices-container'), ambiencePlayer = document.getElementById('ambience-player'), musicPlayer = document.getElementById('music-player'), playerMenuBtn = document.getElementById('player-menu-btn'), playerMenuModal = document.getElementById('player-menu-modal'), aboutModal = document.getElementById('about-modal'), gameContainer = document.getElementById('game-container'), contentContainer = document.getElementById('content-container'), backgroundVideo = document.getElementById('background-video');
                let gameState = { currentSceneId: null, variables: {}, visited: {} };
                let currentAmbienceSrc = '', currentMusicSrc = '', activeVideoElement = null;
                let typewriterState = { intervalId: null, skipListener: null };
                let isGloballyPaused = false;
                let restorePlayState = { music: false, ambience: false, video: false };

                const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                const isAndroid = /android/i.test(navigator.userAgent);
                const clickEvent = isTouchDevice ? 'touchend' : 'click';
                const VIDEO_EXTENSIONS = ['.mp4', '.webm', '.ogv'];
                const isVideo = (path) => {
                    if (!path) return false;
                    const lowerPath = path.toLowerCase();
                    if (lowerPath.startsWith('data:video')) return true;
                    return VIDEO_EXTENSIONS.some(ext => lowerPath.endsWith(ext));
                }

				function parseMarkdown(text) {
                    if (!text) return '';
                    // This function mirrors the main app's markdown parser for consistency.
                    let html = text
                        .replace(/</g, '&lt;') // IMPORTANT: Must be first to prevent HTML injection.
                        .replace(/>/g, '&gt;')
                        .replace(/\\[(.*?)\]\\((.*?)\\)/g, (match, text, url) => {
                            const safeUrl = url.trim();
                             if (safeUrl.startsWith('javascript:') || safeUrl.startsWith('data:') || safeUrl.startsWith('vbscript:')) {
                                return \`[\${text}](javascript:void(0))\`; // Sanitize malicious links
                            }
                            return \`<a href="\${safeUrl}" target="_blank" rel="noopener noreferrer">\${text}</a>\`;
                        })
                        .replace(/\\*\\*(.*?)\\*\\*/g, '<strong>$1</strong>')
                        .replace(/__(.*?)__/g, '<strong>$1</strong>')
                        .replace(/\\*(.*?)\\*/g, '<em>$1</em>')
                        .replace(/_(.*?)_/g, '<em>$1</em>')
                        .replace(/~~(.*?)~~/g, '<s>$1</s>')
                        .replace(/\`(.*?)\`/g, '<code>$1</code>')
                        .replace(/\\n/g, '<br>');
                    return html;
                }

                function bindEvent(element, handler) {
                    if(!element) return;
                    element.addEventListener(clickEvent, (e) => {
                        if (isTouchDevice) e.preventDefault();
                        handler(e);
                    });
                }
                function isStorageAvailable() { try { const x = '__storage_test__'; localStorage.setItem(x, x); localStorage.removeItem(x); return true; } catch (e) { return false; } }
                const storageAvailable = isStorageAvailable();
                const saveKey = 'cyoa-save-' + storyData.meta.title;

                function showModal(modal) { modal.style.display = 'flex'; setTimeout(() => modal.classList.add('visible'), 10); }
                function hideModal(modal) { modal.classList.remove('visible'); setTimeout(() => modal.style.display = 'none', 300); }

                function initializeGameState() {
                    gameState.variables = {};
                    (storyData.meta.variables || []).forEach(varName => { gameState.variables[varName] = false; });
                    gameState.visited = {};
                }

                function setupMenu() {
                    bindEvent(playerMenuBtn, () => showModal(playerMenuModal));
                    bindEvent(playerMenuModal, e => { if (e.target === playerMenuModal) hideModal(playerMenuModal); });
                    bindEvent(playerMenuModal.querySelector('.player-modal-close'), () => hideModal(playerMenuModal));
                    bindEvent(aboutModal.querySelector('.player-modal-close'), () => hideModal(aboutModal));

                    bindEvent(document.getElementById('about-btn'), () => { hideModal(playerMenuModal); showModal(aboutModal); });
                    bindEvent(document.getElementById('restart-btn'), () => { if (storageAvailable) localStorage.removeItem(saveKey); initializeGameState(); renderScene(storyData.meta.startSceneId); hideModal(playerMenuModal); });
                    bindEvent(document.getElementById('fullscreen-btn'), () => { if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(console.warn); else if(document.exitFullscreen) document.exitFullscreen(); });
                    bindEvent(document.getElementById('player-close-btn'), () => { if (window.top === window.self) { if (document.fullscreenElement) document.exitFullscreen(); window.close(); } else { document.body.innerHTML = '<div id="exit-message" style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; text-align: center; font-size: 1.2em; color: #f0f0f0;"><p>Thanks for playing!</p><p>You can now close this window.</p></div>'; } });

                    const soundToggleBtn = document.getElementById('player-sound-toggle-btn');
                    soundToggleBtn.title = "Pause/Play Audio";
                    bindEvent(soundToggleBtn, () => {
                        isGloballyPaused = !isGloballyPaused;
                        if (isGloballyPaused) {
                            restorePlayState.music = !musicPlayer.paused;
                            restorePlayState.ambience = !ambiencePlayer.paused;
                            restorePlayState.video = activeVideoElement ? !activeVideoElement.paused : false;

                            if (restorePlayState.music) musicPlayer.pause();
                            if (restorePlayState.ambience) ambiencePlayer.pause();
                            if (restorePlayState.video) activeVideoElement.pause();

                            soundToggleBtn.querySelector('.icon-on').style.display = 'none';
                            soundToggleBtn.querySelector('.icon-off').style.display = 'block';
                        } else {
                            if (restorePlayState.music) musicPlayer.play().catch(e => console.warn(e));
                            if (restorePlayState.ambience) ambiencePlayer.play().catch(e => console.warn(e));
                            if (restorePlayState.video) activeVideoElement.play().catch(e => console.warn(e));
                            
                            soundToggleBtn.querySelector('.icon-on').style.display = 'block';
                            soundToggleBtn.querySelector('.icon-off').style.display = 'none';
                        }
                    });

                    const saveBtn = document.getElementById('save-btn'), loadBtn = document.getElementById('load-btn');
                    if (!storageAvailable) { [saveBtn, loadBtn].forEach(b => {b.disabled = true; b.title = "Saving/Loading is disabled when run from a local file.";}); }
                    else {
                        bindEvent(saveBtn, () => { localStorage.setItem(saveKey, JSON.stringify(gameState)); alert('Progress saved!'); hideModal(playerMenuModal); });
                        bindEvent(loadBtn, () => {
                            const savedStateJSON = localStorage.getItem(saveKey);
                            if (savedStateJSON) {
                                initializeGameState();
                                const savedState = JSON.parse(savedStateJSON);
                                Object.assign(gameState.variables, savedState.variables);
                                gameState.visited = savedState.visited || {};
                                gameState.currentSceneId = savedState.currentSceneId;
                                renderScene(gameState.currentSceneId);
                            } else {
                                alert('No save data found.');
                            }
                            hideModal(playerMenuModal);
                        });
                    }

                    const setupSlider = (sliderId, player, storageKey, defaultKey) => {
                        const slider = document.getElementById(sliderId);
                        const savedVol = storageAvailable ? localStorage.getItem(storageKey) : null;
                        const defaultVol = storyData.meta.styles[defaultKey] || '0.4';
                        slider.value = savedVol !== null ? savedVol : defaultVol;
                        player.volume = slider.value;
                        slider.addEventListener('input', function() { player.volume = this.value; if (storageAvailable) localStorage.setItem(storageKey, this.value); });
                    };
                    setupSlider('volume-slider', musicPlayer, 'cyoa-music-volume-' + storyData.meta.title, '--music-volume');
                    setupSlider('ambience-volume-slider', ambiencePlayer, 'cyoa-ambience-volume-' + storyData.meta.title, '--ambience-volume');

                    const videoVolumeSlider = document.getElementById('video-volume-slider');
                    const videoVolKey = 'cyoa-video-volume-' + storyData.meta.title;
                    const savedVideoVol = storageAvailable ? localStorage.getItem(videoVolKey) : null;
                    const defaultVideoVol = storyData.meta.styles['--video-volume'] || '1.0';
                    videoVolumeSlider.value = savedVideoVol !== null ? savedVideoVol : defaultVideoVol;
                    if (activeVideoElement) activeVideoElement.volume = videoVolumeSlider.value;
                    videoVolumeSlider.addEventListener('input', function() {
                        if (activeVideoElement) activeVideoElement.volume = this.value;
                        if (storageAvailable) localStorage.setItem(videoVolKey, this.value);
                    });

                    const fontSizeSlider = document.getElementById('font-size-slider');
                    function applyFontSize(size) { gameContainer.style.fontSize = size + 'px'; if(fontSizeSlider) fontSizeSlider.value = size; }
                    const savedSize = storageAvailable ? localStorage.getItem('cyoa-fontsize-' + storyData.meta.title) : null;
                    if (savedSize) { applyFontSize(savedSize); } else if (isAndroid) { applyFontSize(12); }
                    if(fontSizeSlider) fontSizeSlider.addEventListener('input', function() { applyFontSize(this.value); if (storageAvailable) localStorage.setItem('cyoa-fontsize-' + storyData.meta.title, this.value); });

                    document.getElementById('about-title').textContent = storyData.meta.title;
                    document.getElementById('about-creator').textContent = storyData.meta.creatorName ? 'By ' + storyData.meta.creatorName : '';
                    document.getElementById('about-text').innerHTML = parseMarkdown(storyData.meta.aboutText || '');
                }

                function setupGlobalStyles() {
                    const musicPath = storyData.meta.styles['--music-path'] || '';
                    if (musicPath !== currentMusicSrc) {
                        currentMusicSrc = musicPath;
                        musicPlayer.src = musicPath;
                        if (musicPath) {
                            restorePlayState.music = true;
                            if (!isGloballyPaused) musicPlayer.play().catch(e=>console.log("Music autoplay blocked."));
                        } else {
                            restorePlayState.music = false;
                            musicPlayer.pause();
                        }
                    }

                    const startAudio = () => { 
                        if (!isGloballyPaused) {
                            if (restorePlayState.music && musicPlayer.paused) musicPlayer.play().catch(e => console.warn("Music start failed.", e)); 
                            if (restorePlayState.ambience && ambiencePlayer.paused) ambiencePlayer.play().catch(e => console.warn("Ambience start failed.", e));
                        }
                        document.body.removeEventListener('click', startAudio); document.body.removeEventListener('touchend', startAudio); 
                    };
                    document.body.addEventListener('click', startAudio);
                    document.body.addEventListener('touchend', startAudio);
                }

                function typeWriter(text, choices) {
                    if (typewriterState.intervalId) clearInterval(typewriterState.intervalId);
                    if (typewriterState.skipListener) document.body.removeEventListener('click', typewriterState.skipListener);

                    const originalMinHeight = contentContainer.style.minHeight;
                    contentContainer.style.minHeight = '';
                    sceneText.innerHTML = parseMarkdown(text);
                    choicesContainer.innerHTML = '';
                    choices.forEach(choice => {
                        const button = document.createElement('button');
                        button.className = 'choice-btn';
                        button.textContent = choice.action.text;
                        choicesContainer.appendChild(button);
                    });
                    const finalHeight = contentContainer.offsetHeight;
                    contentContainer.style.minHeight = finalHeight + 'px';

                    choicesContainer.innerHTML = '';
                    sceneText.innerHTML = '';
                    let i = 0;

                    const showChoices = () => {
                        choicesContainer.innerHTML = '';
                        choices.forEach((choice, index) => {
                            const button = document.createElement('button');
                            button.className = 'choice-btn fade-in';
                            button.textContent = choice.action.text;
                            button.style.animationDelay = (index * 0.2) + 's';
                            bindEvent(button, (e) => { e.stopPropagation(); processChoice(choice); });
                            choicesContainer.appendChild(button);
                        });
                    };

                    const skipTyping = (e) => {
                        if(e) e.stopPropagation();
                        clearInterval(typewriterState.intervalId);
                        document.body.removeEventListener('click', typewriterState.skipListener);
                        sceneText.innerHTML = parseMarkdown(text);
                        showChoices();
                        contentContainer.style.minHeight = originalMinHeight;
                        typewriterState.intervalId = null;
                        typewriterState.skipListener = null;
                    };

                    typewriterState.skipListener = skipTyping;
                    document.body.addEventListener('click', skipTyping);

                    typewriterState.intervalId = setInterval(() => {
                        if (i >= text.length) {
                            skipTyping(null);
                        } else {
                            sceneText.innerHTML = parseMarkdown(text.substring(0, i + 1));
                            i++;
                        }
                    }, 30);
                }


                function processChoice(choice) {
                    const action = choice.action;
                    if (action.set_variable) gameState.variables[action.set_variable] = action.set_value;
                    if (action.target) renderScene(action.target);
                }

                function renderScene(sceneId) {
                    const isLoopingBackToStart = sceneId === storyData.meta.startSceneId &&
                                                 Object.keys(gameState.visited).length > 0;
                    if (isLoopingBackToStart) {
                        initializeGameState();
                    }
                    try {
                        gameState.currentSceneId = sceneId;
                        gameState.visited[sceneId] = true;

                        const scene = storyData.scenes[sceneId];
                        if (!scene) { sceneText.innerHTML = 'Error: Scene "' + sceneId + '" not found.'; return; }

                        // Apply volumes from sliders
                        musicPlayer.volume = document.getElementById('volume-slider').value;
                        ambiencePlayer.volume = document.getElementById('ambience-volume-slider').value;
                        
                        const layout = storyData.meta.layout;
                        const mediaUrl = scene.image;
                        const isMediaVideo = isVideo(mediaUrl);
                        const isPanelLayout = layout.startsWith('layout-panel');

                        document.body.className = layout;
                        gameContainer.className = layout;

                        const imageContainer = document.getElementById('image-container');

                        [backgroundVideo, sceneVideo].forEach(v => {
                             if(!v.paused) { v.pause(); v.removeAttribute('src'); v.load(); }
                             v.style.display = 'none'; v.classList.remove('visible');
                        });
                        sceneImage.style.display = 'none';
                        imageContainer.style.display = 'none';
                        document.body.style.backgroundImage = 'var(--screen-bg-image)';
                        activeVideoElement = null;
                        restorePlayState.video = false;
                        document.getElementById('player-video-controls').style.display = 'none';

                        if (isMediaVideo && mediaUrl) {
                            activeVideoElement = isPanelLayout ? backgroundVideo : sceneVideo;
                            if (!isPanelLayout) imageContainer.style.display = 'block';

                            if (activeVideoElement.src !== mediaUrl) activeVideoElement.src = mediaUrl;
                            activeVideoElement.style.display = 'block'; activeVideoElement.classList.add('visible');
                            activeVideoElement.loop = scene.videoLoop ?? true;
                            activeVideoElement.muted = scene.videoMuted ?? true; // Scene-specific mute
                            activeVideoElement.volume = document.getElementById('video-volume-slider').value;
                            
                            restorePlayState.video = true;
                            if (!isGloballyPaused) {
                                activeVideoElement.play().catch(e => console.warn("Video autoplay failed:", e));
                            }
                            updateVideoControls(scene);
                        } else {
                           if (isPanelLayout && mediaUrl) {
                                document.body.style.backgroundImage = 'url("' + mediaUrl + '")';
                           } else if (mediaUrl) {
                                sceneImage.src = mediaUrl;
                                sceneImage.style.display = 'block';
                                imageContainer.style.display = 'block';
                           }
                        }

                        let visibleChoices = [];
                        for(const choice of (scene.choices || [])) {
                            let conditionMet = true;
                            if(choice.condition) {
                                const varName = choice.condition.variable;
                                conditionMet = varName.startsWith('visited_scene_') ? (!!gameState.visited[varName.substring(14)] === choice.condition.value) : (gameState.variables[varName.substring(4)] === choice.condition.value);
                            }

                            if (conditionMet) {
                                if (!choice.action.text && choice.action.target) {
                                    if(choice.action.target === sceneId) { console.error('Infinite loop detected: silent action targets itself in scene ' + sceneId); continue; }
                                    processChoice(choice);
                                    return;
                                }
                                if (choice.action.text) visibleChoices.push(choice);
                                else if (choice.action.set_variable) gameState.variables[choice.action.set_variable] = choice.action.set_value;
                            }
                        }

                        if (storyData.meta.styles['--typewriter-effect'] === 'on') {
                            typeWriter(scene.text, visibleChoices);
                        } else {
                            contentContainer.style.minHeight = '';
                            sceneText.innerHTML = parseMarkdown(scene.text);
                            choicesContainer.innerHTML = '';
                            visibleChoices.forEach(choice => { const b = document.createElement('button'); b.textContent = choice.action.text; b.className = 'choice-btn'; bindEvent(b, () => processChoice(choice)); choicesContainer.appendChild(b); });
                        }

                        ambiencePlayer.loop = scene.ambienceLoop ?? true; 
                        const soundUrl = scene.ambienceSound || '';
                        if (soundUrl !== currentAmbienceSrc) { 
                            currentAmbienceSrc = soundUrl; 
                            ambiencePlayer.src = soundUrl; 
                        }
                        
                        if (soundUrl) {
                            restorePlayState.ambience = true;
                            if (!isGloballyPaused) {
                                ambiencePlayer.play().catch(e => console.warn("Ambience autoplay blocked."));
                            }
                        } else {
                            restorePlayState.ambience = false;
                            ambiencePlayer.pause();
                        }
                    } catch(e) { console.error("Error rendering scene:", e); sceneText.innerHTML = "An error occurred. Check console for details."; }
                }

                function updateVideoControls(scene) {
                    if (!activeVideoElement) return;
                    const controls = document.getElementById('player-video-controls'), playBtn = document.getElementById('player-video-play-btn');
                    controls.style.display = 'flex';
                    const updatePlayIcon = () => {
                        playBtn.querySelector('.icon-on').style.display = activeVideoElement.paused ? 'block' : 'none';
                        playBtn.querySelector('.icon-off').style.display = activeVideoElement.paused ? 'none' : 'block';
                    };
                    activeVideoElement.onplay = activeVideoElement.onpause = updatePlayIcon;
                    playBtn.onclick = e => { e.stopPropagation(); if (activeVideoElement.paused) activeVideoElement.play(); else activeVideoElement.pause(); };
                    updatePlayIcon();
                }

                async function main() {
                    const loader = document.getElementById('loading-overlay');
                    const statusEl = document.getElementById('loading-status');
                    const progressContainer = document.getElementById('loading-progress-container');
                    const progressBar = document.getElementById('loading-progress-bar');

                    document.title = storyData.meta.title || 'Choose Your Own Adventure';

                    if (!window.opener) {
                        statusEl.textContent = "Loading complete.";
                        if(loader) loader.style.opacity = '0';
                        setTimeout(() => loader.style.display = 'none', 500);
                        setupMenu();
                        const savedStateJSON = storageAvailable ? localStorage.getItem(saveKey) : null;
                        if (savedStateJSON) {
                            initializeGameState();
                            const savedState = JSON.parse(savedStateJSON);
                            Object.assign(gameState.variables, savedState.variables);
                            gameState.visited = savedState.visited || {};
                            gameState.currentSceneId = savedState.currentSceneId;
                        } else {
                            initializeGameState();
                            gameState.currentSceneId = storyData.meta.startSceneId;
                        }
                        setupGlobalStyles();
                        renderScene(gameState.currentSceneId);
                        return;
                    }

                    progressContainer.style.display = 'block';
                    statusEl.textContent = 'Collecting assets...';

                    const assetPaths = new Set();
                    Object.values(storyData.scenes).forEach(scene => {
                        if (scene.image) assetPaths.add(scene.image);
                        if (scene.ambienceSound) assetPaths.add(scene.ambienceSound);
                    });
                    if (storyData.meta.styles['--music-path']) assetPaths.add(storyData.meta.styles['--music-path']);
                    if (storyData.meta.styles['--screen-bg-image']) assetPaths.add(storyData.meta.styles['--screen-bg-image']);

                    const pathsToLoad = Array.from(assetPaths);
                    const totalAssets = pathsToLoad.length;
                    let loadedCount = 0;
                    const assetDataUrls = {};

                    const requestAsset = (path) => {
                        return new Promise((resolve, reject) => {
                            const requestId = Math.random().toString(36).substring(2);

                            const handler = (event) => {
                                if (event.data.type === 'assetResponse' && event.data.requestId === requestId) {
                                    window.removeEventListener('message', handler);
                                    if(event.data.success) {
                                        resolve(event.data.dataUrl);
                                    } else {
                                        console.warn('Failed to load asset: ' + path);
                                        resolve(null); // Resolve with null on failure to not break Promise.all
                                    }
                                }
                            };

                            window.addEventListener('message', handler);
                            window.opener.postMessage({ type: 'requestAsset', path: path, requestId: requestId }, '*');
                        });
                    };

                    for (const path of pathsToLoad) {
                        statusEl.textContent = 'Loading asset (' + (loadedCount + 1) + '/' + totalAssets + ')...';
                        const dataUrl = await requestAsset(path);
                        if (dataUrl) assetDataUrls[path] = dataUrl;
                        loadedCount++;
                        progressBar.style.width = (loadedCount / totalAssets) * 100 + '%';
                    }

                    statusEl.textContent = 'Finalizing...';
                    Object.values(storyData.scenes).forEach(scene => {
                        if (scene.image && assetDataUrls[scene.image]) scene.image = assetDataUrls[scene.image];
                        if (scene.ambienceSound && assetDataUrls[scene.ambienceSound]) scene.ambienceSound = assetDataUrls[scene.ambienceSound];
                    });
                    if (storyData.meta.styles['--music-path'] && assetDataUrls[storyData.meta.styles['--music-path']]) storyData.meta.styles['--music-path'] = assetDataUrls[storyData.meta.styles['--music-path']];
                    if (storyData.meta.styles['--screen-bg-image'] && assetDataUrls[storyData.meta.styles['--screen-bg-image']]) storyData.meta.styles['--screen-bg-image'] = assetDataUrls[storyData.meta.styles['--screen-bg-image']];

                    if(loader) loader.style.opacity = '0';
                    setTimeout(() => loader.style.display = 'none', 500);

                    setupMenu();
                    initializeGameState();
                    // FIX: Ensure player always starts from startSceneId
                    gameState.currentSceneId = storyData.meta.startSceneId;
                    setupGlobalStyles();
                    renderScene(gameState.currentSceneId);
                }
                main();
            });
        </scr`+`ipt>
		`;

		return document.getElementById('player-template').innerHTML
			.replace(/__STORY_TITLE__/g, App.state.storyData.meta.title || 'My Story')
			.replace(/__LAYOUT_CLASS__/g, App.state.storyData.meta.layout)
			.replace('__GOOGLE_FONT_LINK__', googleFontLink)
			.replace('__CUSTOM_STYLES__', App.styles.generateCSS())
			.replace('__PLAYER_SCRIPT__', playerScript);
        },

        async exportProjectZip() {
            if (!App.state.projectDirectoryHandle) { App.ui.showNotification("Please open a project to export."); return; }
            App.editor.saveCurrentScene();

            const validationResult = await App.io.checkProjectAssets();
            if (!validationResult.isValid) {
                let errorMessage = `<b>Export Cancelled: Missing Files</b><br><br>The following files could not be found in your project folder. Please add them or correct the paths.<br><br>`;
                validationResult.errors.forEach(err => {
                    errorMessage += `• <b>${err.path}</b><br>  <small>(Used in scenes: ${err.scenes.join(', ')})</small><br>`;
                });
                App.ui.showNotification(errorMessage);
                return;
            }

            App.ui.showNotification("Collecting used assets and preparing export...");
            const zip = new window.JSZip();

            const playerHtml = await App.io.getFormattedPlayerHTML(true);
            zip.file("index.html", playerHtml);

            const usedAssetPaths = validationResult.found;

            const assetPromises = Array.from(usedAssetPaths).map(async (path) => {
                try {
                    const file = await App.io.getAssetFile(path);
                    if (file) {
                        zip.file(path, file);
                    }
                } catch(err) {
                     console.warn(`Could not add asset "${path}" to zip:`, err);
                }
            });

            await Promise.all(assetPromises);

            zip.generateAsync({ type: "blob" }).then(content => {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(content);
                a.download = `${App.state.storyData.meta.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_export.zip`;
                a.click();
                URL.revokeObjectURL(a.href);
                App.ui.showNotification("Project exported successfully!");
            }).catch(err => {
                console.error("ZIP Export failed:", err);
                App.ui.showNotification("Could not export project. Check console for details.");
            });
        },

        async previewProject() {
            if (!App.state.projectDirectoryHandle) { App.ui.showNotification("Please open a project to preview."); return; }
            App.editor.saveCurrentScene();
            // FIX: Ensure the player starts from the designated start scene
            App.state.storyData.meta.currentSceneId = App.state.storyData.meta.startSceneId;


            const validationResult = await App.io.checkProjectAssets();
            if (!validationResult.isValid) {
                let errorMessage = `<b>Preview Cancelled: Missing Files</b><br><br>The following files could not be found in your project folder. Please add them or correct the paths.<br><br>`;
                validationResult.errors.forEach(err => {
                    errorMessage += `• <b>${err.path}</b><br>  <small>(Used in scenes: ${err.scenes.join(', ')})</small><br>`;
                });
                App.ui.showNotification(errorMessage);
                return;
            }

            try {
                const playerHtml = await App.io.getFormattedPlayerHTML(false);
                const previewWindow = window.open('', '_blank');
                if (!previewWindow) {
                    App.ui.showNotification("Popup blocked. Please allow popups for this site to use the preview feature.");
                    return;
                }
                previewWindow.document.write(playerHtml);
                previewWindow.document.close();

                const assetRequestHandler = async (event) => {
                    if (event.source !== previewWindow|| !event.data || event.data.type !== 'requestAsset') return;

                    const { path, requestId } = event.data;
                    const dataUrl = await App.io.getAssetDataUrl(path);

                    previewWindow.postMessage({
                        type: 'assetResponse',
                        requestId: requestId,
                        success: !!dataUrl,
                        dataUrl: dataUrl
                    }, '*');
                };

                window.addEventListener('message', assetRequestHandler);

                const checkWindowClosed = setInterval(() => {
                    if (previewWindow.closed) {
                        clearInterval(checkWindowClosed);
                        window.removeEventListener('message', assetRequestHandler);
                    }
                }, 500);

            } catch (err) {
                console.error("Preview failed:", err);
                App.ui.showNotification("Could not generate preview. Check console for details.");
            }
        },

		async checkProjectAssets() {
            if (!App.state.storyData?.scenes) return { isValid: true, errors: [], found: new Set() };
			const errors = [];
			const found = new Set();
			const assetMap = new Map();

			const collectAsset = (path, sceneId) => {
				if (!path || typeof path !== 'string') return;
				const trimmedPath = path.trim();
				if (trimmedPath === '') return;

				if (!assetMap.has(trimmedPath)) {
					assetMap.set(trimmedPath, new Set());
				}
				assetMap.get(trimmedPath).add(sceneId);
			};

			Object.values(App.state.storyData.scenes).forEach(scene => {
				collectAsset(scene.image, scene.id);
				collectAsset(scene.ambienceSound, scene.id);
			});

			const metaStyles = App.state.storyData.meta.styles;
			collectAsset(metaStyles['--screen-bg-image'], 'Project Styles');
			collectAsset(metaStyles['--music-path'], 'Project Styles');

			for (const [path, scenesSet] of assetMap.entries()) {
				const file = await App.io.getAssetFile(path);
				if (!file) {
					errors.push({
						path: path,
						scenes: Array.from(scenesSet)
					});
				} else {
					found.add(path);
				}
			}

			return {
				isValid: errors.length === 0,
				errors: errors,
				found: found
			};
		},
        async checkAllProjectAssets() {
            if (!App.state.storyData?.scenes) return;
            App.state.brokenAssetLinks.clear();
            for (const scene of Object.values(App.state.storyData.scenes)) {
                const brokenPaths = [];
                if(scene.image) {
                    const file = await App.io.getAssetFile(scene.image);
                    if(!file) brokenPaths.push(scene.image);
                }
                if(scene.ambienceSound) {
                    const file = await App.io.getAssetFile(scene.ambienceSound);
                    if(!file) brokenPaths.push(scene.ambienceSound);
                }
                if(brokenPaths.length > 0) {
                    App.state.brokenAssetLinks.set(scene.id, brokenPaths);
                }
            }
        },

        async getAssetDataUrl(path) {
            try {
                const file = await App.io.getAssetFile(path);
                if (!file) return null;

                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            } catch (error) {
                console.error(`Failed to get Data URL for path: ${path}`, error);
                return null;
            }
        },

        async getAssetFile(path) {
            if (!path || !App.state.projectDirectoryHandle) return null;
            if (App.state.pendingAssetCopies.has(path)) {
                return App.state.pendingAssetCopies.get(path);
            }
            try {
                const pathParts = path.split('/');
                const fileName = pathParts.pop();
                let dirHandle = App.state.projectDirectoryHandle;
                for (const part of pathParts) {
                    dirHandle = await dirHandle.getDirectoryHandle(part);
                }
                const fileHandle = await dirHandle.getFileHandle(fileName);
                return await fileHandle.getFile();
            } catch (e) {
                if (!App.state.missingAssetWarnings.has(path)) {
                    App.state.missingAssetWarnings.add(path);
                    console.warn(`Asset file not found in project: ${path}`);
                }
                return null;
            }
        },

        exportData(type) {
            let data = {};
            let filename = `${type}.json`;
            switch(type) {
                case 'imagePrompts':
                    Object.values(App.state.storyData.scenes).forEach(scene => {
                        if (scene.imagePrompt) {
                            data[scene.id] = scene.imagePrompt;
                        }
                    });
                    break;
                default:
                    App.ui.showNotification(`Unknown data export type: ${type}`);
                    return;
            }
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            a.click();
            URL.revokeObjectURL(a.href);
        }
    },
    sceneList: {
        ICONS: {
            start: `<svg class="scene-card-icon icon-start" viewBox="0 0 16 16"><path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>`,
            image: `<svg class="scene-card-icon icon-image" viewBox="0 0 16 16"><path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/><path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/></svg>`,
			video: `<svg class="scene-card-icon icon-video" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2zm5.5 3v6l5-3-5-3z"></path></svg>`,
			videoLoop: `<svg class="scene-card-icon icon-video-loop" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966a.25.25 0 0 1 0 .384l-2.36 1.966A.25.25 0 0 1 8 4.466z"/></svg>`,
            audio: `<svg class="scene-card-icon icon-sound" viewBox="0 0 16 16"><path d="M9.707,2.293a1,1,0,0,0-1.414,0L4.6,6H2.5A1.5,1.5,0,0,0,1,7.5v1A1.5,1.5,0,0,0,2.5,10H4.6l3.69,3.707a1,1,0,0,0,1.414,0V2.293Z"/></svg>`,
			audioLoop: `<svg class="scene-card-icon icon-audio-loop" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966a.25.25 0 0 1 0 .384l-2.36 1.966A.25.25 0 0 1 8 4.466z"/></svg>`,
            orphan: `<svg class="scene-card-icon icon-orphan" viewBox="0 0 16 16"><rect x="7" y="2" width="2" height="12"/><rect x="3" y="5" width="10" height="2"/></svg>`,
			end: `<svg class="scene-card-icon icon-deadend" viewBox="0 0 16 16"><circle cx="8" cy="8" r="7.5" fill="none" stroke="currentColor" stroke-width="1"/><rect x="3" y="6.5" width="10" height="3" fill="currentColor"/></svg>`,
            condition: `<svg class="scene-card-icon icon-condition" viewBox="0 0 16 16"><path d="M7.33 8L12.67 5.33M7.33 8L12.67 10.67M2 8h5.33"/><circle cx="2" cy="8" r="1.33"/><circle cx="12.67" cy="5.33" r="1.33"/><circle cx="12.67" cy="10.67" r="1.33"/></svg>`
        },

        createCard(scene) {
            const card = document.createElement('div');
            card.className = 'scene-card';
            card.dataset.sceneId = scene.id;

            const brokenLinks = App.state.brokenAssetLinks.get(scene.id);
            if (brokenLinks && brokenLinks.length > 0) {
                card.classList.add('has-broken-link');
                const brokenFilesList = brokenLinks.map(p => `• ${p}`).join('\n');
                card.title = `Broken Asset Links:\n${brokenFilesList}`;
            }

            if (scene.id === App.state.currentSceneId) {
                card.classList.add('active');
            }
            card.onclick = () => App.ui.selectScene(scene.id);
            card.oncontextmenu = (e) => {
                e.preventDefault();
                App.state.contextSceneId = scene.id;
                const menu = App.elements['editor-context-menu'];
				App.nodeEditor.showContextMenu(e, menu);
			};

            const choicesToSceneCount = scene.choices.filter(c => c.action.target).length;
            const isDeadEnd = choicesToSceneCount === 0;
            const hasConditions = scene.choices.some(c => c.condition);
            
            const mediaType = scene.mediaType || 'none';
            const hasMedia = mediaType === 'image' || mediaType === 'video';

            let iconsHTML = `
                ${scene.id === App.state.storyData.meta.startSceneId ? this.ICONS.start : ''}
				<span class="scene-card-icon-group">
					${hasMedia ? (mediaType === 'video' ? this.ICONS.video + (scene.videoLoop ? this.ICONS.videoLoop : '') : this.ICONS.image) : ''}
				</span>
                <span class="scene-card-icon-group">
                    ${scene.ambienceSound ? this.ICONS.audio + (scene.ambienceLoop ? this.ICONS.audioLoop : '') : ''}
                </span>
                ${isDeadEnd ? this.ICONS.end : ''}
                ${hasConditions ? this.ICONS.condition : ''}
                ${App.state.orphanSceneIds.has(scene.id) ? this.ICONS.orphan : ''}
                ${choicesToSceneCount > 0 ? `<span class="choice-count-icon">${choicesToSceneCount}</span>` : ''}
            `;

            card.innerHTML = `
                <div class="scene-card-thumbnail" data-thumbnail-for="${scene.id}"><span>No Img</span></div>
                <div class="scene-card-content">
                    <div class="scene-card-header">
                        <div class="scene-card-id">${scene.id}</div>
                        <div class="scene-card-icons">${iconsHTML}</div>
                    </div>
                    <div class="scene-card-text">${scene.text ? (scene.text.substring(0, 100).replace(/\n/g, ' ') + (scene.text.length > 100 ? '...' : '')) : 'No text content.'}</div>
                </div>
            `;
            return card;
		},

        async render(filterTerm = '') {
            const listView = App.elements['scene-list-view'];
             if (!App.state.storyData?.scenes) {
                listView.innerHTML = '';
                return;
            }
            App.tree.findAllSceneLinks();
            const searchText = filterTerm.trim().toLowerCase();

            let scenes = Object.values(App.state.storyData.scenes);

            if (searchText) {
                scenes = scenes.filter(s => s.id.toLowerCase().includes(searchText) || (s.text && s.text.toLowerCase().includes(searchText)));
            }

            const sortMethod = App.elements['scene-list-sort'].value;
            scenes.sort((a, b) => {
                if (sortMethod === 'id') return a.id.localeCompare(b.id);
                if (sortMethod === 'modified') return b.lastModified - a.lastModified;
                return 0; // file-order is default
            });

            listView.innerHTML = '';
            const fragment = document.createDocumentFragment();
            scenes.forEach(scene => fragment.appendChild(this.createCard(scene)));
            listView.appendChild(fragment);

            // Asynchronously load thumbnails
            const thumbnailDivs = listView.querySelectorAll('.scene-card-thumbnail');
            thumbnailDivs.forEach(async (div) => {
                const sceneId = div.dataset.thumbnailFor;
                const scene = App.state.storyData.scenes[sceneId];
                if (scene && scene.image) {
                    try {
                        const url = App.assets.isVideo(scene.image) ? await App.assets.getVideoThumbnail(scene.image) : await App.io.getAssetDataUrl(scene.image);
                        if (url) {
                            div.innerHTML = '';
                            const mediaElement = document.createElement(App.assets.isVideo(scene.image) ? 'canvas' : 'img');
                            if(App.assets.isVideo(scene.image)) {
                                const img = new Image();
                                img.onload = () => { mediaElement.width = img.width; mediaElement.height = img.height; mediaElement.getContext('2d').drawImage(img, 0, 0); }
                                img.src = url;
                            } else {
                                mediaElement.src = url;
                            }
                            div.appendChild(mediaElement);
                        }
                    } catch (e) { console.warn(`Thumbnail for ${sceneId} failed.`, e); }
                }
            });
        }
    },

    tree: {
        findAllSceneLinks() {
            if (!App.state.storyData?.scenes) {
                App.state.orphanSceneIds = new Set();
                return;
            }
            const allSceneIds = new Set(Object.keys(App.state.storyData.scenes));
            const linkedSceneIds = new Set();

            const traverse = (sceneId) => {
                if (!sceneId || !App.state.storyData.scenes[sceneId] || linkedSceneIds.has(sceneId)) return;
                
                linkedSceneIds.add(sceneId);
                const scene = App.state.storyData.scenes[sceneId];
                if (scene?.choices) {
                    scene.choices.forEach(choice => traverse(choice.action.target));
                }
            };

            traverse(App.state.storyData.meta.startSceneId);
            App.state.orphanSceneIds = new Set([...allSceneIds].filter(id => !linkedSceneIds.has(id)));
        },

        async renameScene() {
            const oldId = App.state.currentSceneId;
            if (!oldId) { App.ui.showNotification("No scene selected to rename."); return; }

            App.ui.showCustomPrompt({
                text: "Enter the new ID for this scene:",
                value: oldId,
                callback: (newId) => {
                    if (!newId || newId === oldId) return;
                    newId = newId.trim().replace(/\s+/g, '_');
                    if (!newId.length || App.state.storyData.scenes[newId] || App.state.storyData.meta.variables.includes(newId)) {
                        App.ui.showNotification(`Scene ID "${newId}" is invalid or already in use.`); return;
                    }

                    const sceneData = App.state.storyData.scenes[oldId]; sceneData.id = newId; sceneData.lastModified = Date.now();
                    App.state.storyData.scenes[newId] = sceneData; delete App.state.storyData.scenes[oldId];
                    Object.values(App.state.storyData.scenes).forEach(scene => scene.choices?.forEach(choice => { if (choice.action?.target === oldId) choice.action.target = newId; }));
                    if (App.state.storyData.meta.startSceneId === oldId) App.state.storyData.meta.startSceneId = newId;

                    App.state.currentSceneId = newId; App.setDirty(true); App.ui.invalidateNavViews(); App.ui.setViewMode(App.state.currentNavView).then(() => App.editor.render());
                }
            });
        },
        async deleteCurrentScene(fromContextMenu = false) {
            const sceneId = fromContextMenu ? App.state.contextSceneId : App.state.currentSceneId;
            if (!sceneId) { App.ui.showNotification("No scene selected to delete."); return; }
            if (sceneId === App.state.storyData.meta.startSceneId) { App.ui.showNotification("Cannot delete the start scene. Set another scene as the start scene first."); return; }
            if (!confirm(`Are you sure you want to permanently delete scene "${sceneId}"? This cannot be undone.`)) return;

            delete App.state.storyData.scenes[sceneId];
            Object.values(App.state.storyData.scenes).forEach(scene => scene.choices?.forEach(choice => { if (choice.action?.target === sceneId) choice.action.target = ''; }));

            App.setDirty(true);
            if (App.state.currentSceneId === sceneId) {
                App.state.currentSceneId = null;
            }
            App.ui.invalidateNavViews();
            await App.ui.setViewMode(App.state.currentNavView);
            App.ui.selectScene(App.state.storyData.meta.startSceneId);
        },
		async setAsStartScene() {
            const sceneId = App.state.contextSceneId;
            if (sceneId) {
                App.state.storyData.meta.startSceneId = sceneId;
                App.setDirty(true);
                App.ui.invalidateNavViews();
                await App.ui.setViewMode(App.state.currentNavView);
            }
        }
    },

        editor: {
        render() {
            const scenes = App.state.storyData?.scenes;
            const scene = scenes ? scenes[App.state.currentSceneId] : null;
            const isPlayerActive = App.elements['player-container'].style.display === 'flex';
            const aiGeneratorPanel = document.getElementById('ai-image-generator').parentElement;

            if (isPlayerActive && aiGeneratorPanel) {
                aiGeneratorPanel.style.display = 'none';
            } else if (aiGeneratorPanel) {
                aiGeneratorPanel.style.display = 'block';
            }

            const editorPanel = document.getElementById('editor-panel');
            const previewWrapper = App.elements['scene-editor-preview-wrapper'];
            // FIX: Remove "Scene Editor" text and underline
            const headerH1 = document.querySelector('#editor-container .header h1');
            if(headerH1) {
                // Clear existing text nodes, but keep the button
                Array.from(headerH1.childNodes).forEach(node => {
                    if (node.nodeType === Node.TEXT_NODE) {
                        node.textContent = '';
                    }
                });
            }

            if (!scene) {
                editorPanel.style.display = 'none';
                if(previewWrapper) previewWrapper.style.display = 'none';
                return;
            }
            editorPanel.style.display = 'block';
            if(previewWrapper) previewWrapper.style.display = 'block';

            App.elements['scene-id'].value = App.state.currentSceneId;
            App.elements['scene-text'].value = scene.text || '';
            App.elements['choices-container'].innerHTML = '';
            (scene.choices || []).forEach(choice => this.addChoiceToDOM(choice));
            App.elements['scene-image'].value = scene.image || '';
            App.ui.updateImageThumbnail(scene.image);
            App.elements['scene-image-prompt'].value = scene.imagePrompt || '';
            App.elements['scene-sound'].value = scene.ambienceSound || '';
            App.elements['toggle-loop-btn'].classList.toggle('active', scene.ambienceLoop ?? true);
            App.elements['manage-variables-btn'].innerHTML = App.editor.ui.iconManageVariables;
            this.ui.updateMediaButtonStates();
            App.player.updateAmbienceButton(false); // Reset ambience button to "Play" icon

            // Video specific UI
            App.elements['toggle-video-loop-btn'].classList.toggle('active', scene.videoLoop ?? true);
            const isMuted = scene.videoMuted ?? true;
            App.elements['toggle-video-mute-btn'].classList.toggle('active', isMuted);
            this.ui.updateVideoMuteButton(isMuted);

            this.ui.updateVideoControlsVisibility();

            App.ui.updateAiImagePreview(null); App.state.aiImageUrl = null;
        },
        renderPreview() {
            const previewContainer = App.elements['scene-editor-preview'];
            const previewWrapper = App.elements['scene-editor-preview-wrapper'];
            if (!previewContainer || !previewWrapper || previewWrapper.style.display === 'none') return;

            const textEl = document.getElementById('preview-player-text');
            const choicesEl = document.getElementById('preview-player-choices');

            const sceneText = App.elements['scene-text'].value;
            choicesEl.innerHTML = '';

            Array.from(App.elements['choices-container'].querySelectorAll('.choice-editor')).forEach(div => {
                const isConditional = div.classList.contains('is-conditional');
                const view = isConditional ? div.querySelector('.condition-view') : div.querySelector('.default-view');
                const textInput = view.querySelector('.action-text-input');

                if (textInput && !textInput.classList.contains('display-none') && textInput.value) {
                    const button = document.createElement('button');
                    button.className = 'choice-btn';
                    button.textContent = textInput.value;
                    choicesEl.appendChild(button);
                }
            });

            App.styles.applyToContainer(previewContainer);
            textEl.innerHTML = App.markdown.parse(sceneText);

            this.updatePreviewMedia();
        },
        async updatePreviewMedia() {
			App.state.previewLoadId++;
			const currentLoadId = App.state.previewLoadId;

			const previewWrapper = App.elements['scene-editor-preview-wrapper'];
			const imageEl = document.getElementById('preview-player-image');
			const videoBgEl = App.elements['preview-player-video'];
			const videoFgEl = document.getElementById('preview-player-video-fg');
			const imageContainerEl = document.getElementById('preview-player-image-container');
			const previewContainer = App.elements['scene-editor-preview'];

			previewWrapper.classList.add('is-loading');

			try {
				const sceneImage = App.elements['scene-image'].value;
				const meta = App.state.storyData.meta;
				const isMediaVideo = App.assets.isVideo(sceneImage);
				const sceneMediaUrl = await App.io.getAssetDataUrl(sceneImage);

				if (currentLoadId !== App.state.previewLoadId) return;

				// Reset all media displays
				imageEl.style.display = 'none';
				imageContainerEl.style.display = 'none';
				[videoBgEl, videoFgEl].forEach(v => {
					v.style.display = 'none';
					if (v && !v.paused) {
						v.pause();
						v.removeAttribute('src');
						v.load();
					}
				});
                previewContainer.style.backgroundImage = 'none'; // Clear background image

                const isPanelLayout = meta.layout === 'layout-panel-bottom' || meta.layout === 'layout-panel-left' || meta.layout === 'layout-panel-right';

				if (isMediaVideo && sceneMediaUrl) {
					let activeVideoEl = isPanelLayout ? videoBgEl : videoFgEl;
                    if (!isPanelLayout) imageContainerEl.style.display = 'block';

                    activeVideoEl.src = sceneMediaUrl;
                    activeVideoEl.loop = App.elements['toggle-video-loop-btn'].classList.contains('active');
                    activeVideoEl.muted = App.elements['toggle-video-mute-btn'].classList.contains('active');
                    activeVideoEl.volume = parseFloat(App.state.storyData.meta.styles['--video-volume'] || 1.0);
                    activeVideoEl.style.display = 'block';
                    activeVideoEl.load();
                    App.editor.ui.updateVideoPlaybackButton(false);

				} else { // This is an image or no media
					if (isPanelLayout && sceneMediaUrl) {
                        previewContainer.style.backgroundImage = `url('${sceneMediaUrl}')`;
                    } else if (sceneMediaUrl) { // Top-down or Side-by-side
                        imageEl.src = sceneMediaUrl;
                        imageEl.style.display = 'block';
                        imageContainerEl.style.display = 'block';
					}
				}
			} catch (error) {
				console.error("Failed to update preview media:", error);
			} finally {
				if (currentLoadId === App.state.previewLoadId) {
					previewWrapper.classList.remove('is-loading');
				}
			}
		},
        saveCurrentScene() {
            if (!App.state.currentSceneId) return;
            const scene = App.state.storyData.scenes[App.state.currentSceneId];
            if (!scene) return;
        
            const newChoices = Array.from(App.elements['choices-container'].querySelectorAll('.choice-editor')).map(div => {
                const isConditional = div.classList.contains('is-conditional');
                const view = isConditional ? div.querySelector('.condition-view') : div.querySelector('.default-view');
                
                const actionText = view.querySelector('.action-text-input').value;
                const destSelectVal = view.querySelector('.destination-select').value;
                const actionBool = view.querySelector('.action-boolean-select').value === 'true';

                const choice = { 
                    condition: null, 
                    action: { text: actionText, target: null, set_variable: null, set_value: false } 
                };

                if (isConditional) {
                    const condVar = view.querySelector('.condition-select').value;
                    if(condVar) {
                        choice.condition = {
                            variable: condVar,
                            value: view.querySelector('.condition-boolean-select').value === 'true'
                        };
                    }
                }

                if (destSelectVal.startsWith('scene_')) {
                    choice.action.target = destSelectVal.substring(6);
                } else if (destSelectVal.startsWith('var_')) {
                    choice.action.set_variable = destSelectVal.substring(4);
                    choice.action.set_value = actionBool;
                }
                
                return choice;
            });
            
            const newText = App.elements['scene-text'].value;
            let textChanged = false;
            if (scene.text !== newText) {
                scene.text = newText;
                textChanged = true;
            }

            scene.image = App.elements['scene-image'].value.trim();
            scene.imagePrompt = App.elements['scene-image-prompt'].value.trim();
            scene.ambienceSound = App.elements['scene-sound'].value.trim();
            scene.ambienceLoop = App.elements['toggle-loop-btn'].classList.contains('active');
            scene.videoLoop = App.elements['toggle-video-loop-btn'].classList.contains('active');
            scene.videoMuted = App.elements['toggle-video-mute-btn'].classList.contains('active');
            scene.choices = newChoices;
            scene.lastModified = Date.now();
        
            App.setDirty(true);
            
            if (textChanged) {
                const nodeTextDisplay = document.querySelector(`.node-editor-node[data-scene-id="${App.state.currentSceneId}"] .node-text-display`);
                if (nodeTextDisplay) {
                    nodeTextDisplay.textContent = newText.substring(0, 150) + (newText.length > 150 ? '...' : '');
                }
                const sceneCardTextDisplay = document.querySelector(`.scene-card[data-scene-id="${App.state.currentSceneId}"] .scene-card-text`);
                if (sceneCardTextDisplay) {
                    sceneCardTextDisplay.textContent = newText ? (newText.substring(0, 100).replace(/\n/g, ' ') + (newText.length > 100 ? '...' : '')) : 'No text content.';
                }
            }

            App.ui.invalidateNavViews();
         },
        addChoiceToDOM(choice = {}) {
            const container = App.elements['choices-container'];
            const choiceDiv = document.createElement('div');
            choiceDiv.className = 'choice-editor';
            choiceDiv.innerHTML = this.ui.getChoiceHTML();
            
            this.ui.repopulateAllChoiceDropdowns(choiceDiv);
            
            const action = choice.action || {};
            const view = choice.condition ? choiceDiv.querySelector('.condition-view') : choiceDiv.querySelector('.default-view');
            
            if (choice.condition) {
                choiceDiv.classList.add('is-conditional');
                choiceDiv.querySelector('.toggle-condition-btn').innerHTML = App.editor.ui.iconRemoveCondition;
                const cView = choiceDiv.querySelector('.condition-view');
                cView.querySelector('.condition-select').value = choice.condition.variable;
                cView.querySelector('.condition-boolean-select').value = String(choice.condition.value);
            } else {
                choiceDiv.querySelector('.toggle-condition-btn').innerHTML = App.editor.ui.iconAddCondition;
            }
            
            if (action.set_variable) {
                view.querySelector('.destination-select').value = 'var_' + action.set_variable;
                view.querySelector('.action-boolean-select').value = String(action.set_value);
            } else if (action.target) {
                view.querySelector('.destination-select').value = 'scene_' + action.target;
            }

            view.querySelector('.action-text-input').value = action.text || '';
            this.ui.handleDropdownChange(view.querySelector('.destination-select'));
            container.appendChild(choiceDiv);
        },
        ui: {
            iconAddCondition: `<svg viewBox="0 0 24 24"><path d="M11 12L19 8 M11 12L19 16 M3 12h8"/><circle cx="3" cy="12" r="2"/><circle cx="19" cy="8" r="2"/><circle cx="19" cy="16" r="2"/></svg>`,
            iconRemoveCondition: `<svg viewBox="0 0 24 24"><path d="M4 12h16"/><circle cx="4" cy="12" r="2"/><circle cx="20" cy="12" r="2"/></svg>`,
            iconManageVariables: `<svg viewBox="0 0 24 24"><path d="M5 7 V17 M19 7 V17 M8 12 L12 8 L16 12 L12 16 Z" stroke-width="2" /></svg>`,
            
            getChoiceHTML() {
                return `
                    <button class="icon-btn toggle-condition-btn" onclick="App.editor.ui.toggleCondition(this)" title="Add a condition"></button>
                    <div class="default-view">
                        <div class="ui-box">
                            <input type="text" class="action-text-input" placeholder="Button text...">
                            <select class="destination-select" onchange="App.editor.ui.handleDropdownChange(this)"></select>
                            <div class="set-variable-ui display-none">
                                <svg class="icon-symbol" viewBox="0 0 24 24"><path d="M5 9h14M5 15h14"></path></svg>
                                <select class="action-boolean-select"><option value="true">True</option><option value="false">False</option></select>
                            </div>
                        </div>
                    </div>
                    <div class="condition-view">
                        <div class="ui-box">
                            <svg class="icon-symbol" viewBox="0 0 24 24"><path d="M8 8a3.5 3 0 0 1 3.5 -3h1a3.5 3 0 0 1 3.5 3a3 3 0 0 1 -2 3a3 4 0 0 0 -2 4" /><line x1="12" y1="19" x2="12" y2="19.01" /></svg>
                            <select class="condition-select"></select>
                            <svg class="icon-symbol" viewBox="0 0 24 24"><path d="M5 9h14M5 15h14"></path></svg>
                            <select class="condition-boolean-select"><option value="true">True</option><option value="false">False</option></select>
                            <svg class="icon-symbol" viewBox="0 0 24 24"><path d="M5 12l14 0l-4 -4m4 4l-4 4"></path></svg>
                            <input type="text" class="action-text-input" placeholder="Button text...">
                            <select class="destination-select" onchange="App.editor.ui.handleDropdownChange(this)"></select>
                            <div class="set-variable-ui display-none">
                                <svg class="icon-symbol" viewBox="0 0 24 24"><path d="M5 9h14M5 15h14"></path></svg>
                                <select class="action-boolean-select"><option value="true">True</option><option value="false">False</option></select>
                            </div>
                        </div>
                    </div>
                    <button class="btn-success go-to-scene-btn display-none" title="Go to selected scene">▶</button>
                    <button class="icon-btn delete-choice-btn" onclick="this.parentElement.remove()" title="Delete Choice">&times;</button>
                `;
            },
            populateDropdowns(selectElement, includeScenes, includeVariables, includeVisited) {
                if (!selectElement) return;
                const scenes = Object.keys(App.state.storyData.scenes).sort();
                const variables = App.state.storyData.meta.variables || [];
                const currentValue = selectElement.value;
                selectElement.innerHTML = '';

                const defaultOption = new Option('-- Select --', '');
                selectElement.appendChild(defaultOption);
                
                if (includeVisited) {
                    const sceneGroup = document.createElement('optgroup');
                    sceneGroup.label = 'Scenes (Visited?)';
                    scenes.forEach(sceneId => { const option = new Option(sceneId, `visited_scene_${sceneId}`); sceneGroup.appendChild(option); });
                    selectElement.appendChild(sceneGroup);
                }
                if (includeScenes) {
                    const sceneGroup = document.createElement('optgroup');
                    sceneGroup.label = 'Scenes (Go To)';
                    scenes.forEach(sceneId => { const option = new Option(sceneId, `scene_${sceneId}`); sceneGroup.appendChild(option); });
                    selectElement.appendChild(sceneGroup);
                }
                if (includeVariables) {
                    const variableGroup = document.createElement('optgroup');
                    variableGroup.label = 'Variables';
                    variables.forEach(variable => { const option = new Option(variable, `var_${variable}`); variableGroup.appendChild(option); });
                    selectElement.appendChild(variableGroup);
                }
                selectElement.value = currentValue;
            },
            repopulateAllChoiceDropdowns(context = document) {
                context.querySelectorAll('.destination-select').forEach(sel => this.populateDropdowns(sel, true, true, false));
                context.querySelectorAll('.condition-select').forEach(sel => this.populateDropdowns(sel, false, true, true));
            },
            handleDropdownChange(selectElement) {
                const choiceEditor = selectElement.closest('.choice-editor');
                const parentBox = selectElement.closest('.ui-box');
                const textInput = parentBox.querySelector('.action-text-input');
                const setVariableUI = parentBox.querySelector('.set-variable-ui');
                const goToBtn = choiceEditor.querySelector('.go-to-scene-btn');
                
                const isVarSelected = selectElement.value.startsWith('var_');
                const isSceneSelected = selectElement.value.startsWith('scene_');

                textInput.classList.toggle('display-none', isVarSelected);
                setVariableUI.classList.toggle('display-none', !isVarSelected);
                goToBtn.classList.toggle('display-none', !isSceneSelected);

                if(isSceneSelected) {
                    goToBtn.onclick = () => App.ui.selectScene(selectElement.value.substring(6));
                }
            },
            toggleCondition(button) {
                const choiceDiv = button.closest('.choice-editor');
                choiceDiv.classList.toggle('is-conditional');
                button.innerHTML = choiceDiv.classList.contains('is-conditional') ? this.iconRemoveCondition : this.iconAddCondition;
                button.title = choiceDiv.classList.contains('is-conditional') ? 'Remove condition' : 'Add a condition';
                App.editor.saveCurrentScene();
                App.editor.renderPreview();
            },
            updateVideoControlsVisibility() {
				const path = App.elements['scene-image'].value;
				const isVideo = App.assets.isVideo(path);
				App.elements['video-controls'].style.display = isVideo ? 'flex' : 'none';

                const scene = App.state.storyData.scenes[App.state.currentSceneId];
                if(scene) {
                    scene.mediaType = isVideo ? 'video' : (path ? 'image' : 'none');
                }

				if (isVideo) {
					App.elements['media-icon-image'].classList.add('hidden');
					App.elements['media-icon-video'].classList.remove('hidden');
				} else {
					App.elements['media-icon-image'].classList.remove('hidden');
					App.elements['media-icon-video'].classList.add('hidden');
				}
			},
            updateVideoPlaybackButton(isPlaying) {
                App.elements['video-play-icon'].classList.toggle('hidden', isPlaying);
                App.elements['video-pause-icon'].classList.toggle('hidden', !isPlaying);
            },
            updateVideoMuteButton(isMuted) {
                App.elements['video-unmute-icon'].classList.toggle('hidden', isMuted);
                App.elements['video-mute-icon'].classList.toggle('hidden', !isMuted);
            },
            updateMediaButtonStates() {
				const hasSound = !!App.elements['scene-sound'].value;
				const ambienceBtn = App.elements['toggle-ambience-btn'];
				ambienceBtn.classList.toggle('btn-success', hasSound);
				ambienceBtn.classList.toggle('btn-secondary', !hasSound);

				const hasVideo = App.assets.isVideo(App.elements['scene-image'].value);
				const videoBtn = App.elements['toggle-video-playback-btn'];
				videoBtn.classList.toggle('btn-success', hasVideo);
				videoBtn.classList.toggle('btn-secondary', !hasVideo);
			}
        },
        variables: {
            showModal() {
                App.modals.show('variable-manager-modal');
                this.renderList();
            },
            renderList() {
                const list = document.getElementById('variable-list');
                list.innerHTML = '';
                (App.state.storyData.meta.variables || []).forEach((variable, index) => {
                    const li = document.createElement('li');
                    li.innerHTML = `<span>${variable}</span><button class="remove-var-btn" onclick="App.editor.variables.remove(${index})">✕</button>`;
                    list.appendChild(li);
                });
            },
            add() {
                const input = document.getElementById('new-variable-name');
                const newVar = input.value.trim().replace(/[^A-Za-z0-9_]/g, '');
                if (newVar && !App.state.storyData.meta.variables.includes(newVar) && !App.state.storyData.scenes[newVar]) {
                    App.state.storyData.meta.variables.push(newVar);
                    App.state.storyData.meta.variables.sort();
                    this.renderList();
                    App.editor.ui.repopulateAllChoiceDropdowns();
                    App.setDirty(true);
                    input.value = '';
                } else if(newVar) {
                     App.ui.showNotification("This name is already in use by a scene or variable.");
                }
            },
            remove(index) {
                App.state.storyData.meta.variables.splice(index, 1);
                this.renderList();
                App.editor.ui.repopulateAllChoiceDropdowns();
                App.setDirty(true);
            }
        }
    },

    assets: {
        isVideo(path) {
            return path && App.constants.VIDEO_EXTENSIONS.some(ext => path.toLowerCase().endsWith(ext));
        },
		async getVideoThumbnail(path) {
			return new Promise(async (resolve) => {
				const file = await App.io.getAssetFile(path);
				if (!file) {
					return resolve(null);
				}

				const video = document.createElement('video');
				video.preload = 'metadata';
				video.muted = true;
				video.playsInline = true;

				const canvas = document.createElement('canvas');
				const context = canvas.getContext('2d');
				const url = URL.createObjectURL(file);

				const cleanup = () => {
					clearTimeout(timeoutId);
					video.onerror = null;
					video.onloadedmetadata = null;
					video.onseeked = null;
					video.src = ''; 
					URL.revokeObjectURL(url); 
				};

				const fail = (reason) => {
					console.warn(`Thumbnail generation failed for ${path}: ${reason}`);
					cleanup();
					resolve(null);
				};

				const timeoutId = setTimeout(() => fail('Timeout'), 5000);

				video.onerror = () => fail('Video element error');
				
				video.onseeked = () => {
					clearTimeout(timeoutId);

					if (video.videoWidth > 0 && video.videoHeight > 0) {
						canvas.width = video.videoWidth;
						canvas.height = video.videoHeight;
						context.drawImage(video, 0, 0, canvas.width, canvas.height);
						const dataUrl = canvas.toDataURL('image/jpeg');
						cleanup();
						resolve(dataUrl); 
					} else {
						fail('Video dimensions were not available after seek.');
					}
				};

				video.onloadedmetadata = () => {
					video.currentTime = video.duration > 1 ? 1 : video.duration / 2;
				};

				video.src = url;
			});
		},
        async selectFile(assetType, targetInputId) {
            const fileInput = document.getElementById(assetType === 'images' ? 'image-file-input' : 'sound-file-input');
            const handleFile = async (file) => {
                if (!file) return;
                const assetTypeFolder = this.isVideo(file.name) ? 'videos' : (assetType === 'sounds' ? 'sounds' : 'images');
                const destinationPath = `${assetTypeFolder}/${file.name}`;
                App.state.pendingAssetCopies.set(destinationPath, file);
                const inputElement = document.getElementById(targetInputId);
                if (inputElement) {
                    inputElement.value = destinationPath;
                    inputElement.dispatchEvent(new Event('input', { bubbles: true }));
                }
                App.setDirty(true);
            };

            if (window.showOpenFilePicker) {
                try {
                    const options = {
                        types: [{
                            description: assetType === 'images' ? 'Images/Videos' : 'Sounds',
                            accept: assetType === 'images'
                                ? {'media/*': ['.png', '.gif', '.jpeg', '.jpg', '.webp', ...App.constants.VIDEO_EXTENSIONS]}
                                : {'audio/*': ['.mp3', '.wav', '.ogg', '.m4a']}
                        }],
                        multiple: false,
                        startIn: App.state.lastAssetHandles[assetType] || App.state.projectDirectoryHandle || 'pictures'
                    };
                    const [fileHandle] = await window.showOpenFilePicker(options);
                    App.state.lastAssetHandles[assetType] = fileHandle;
                    const file = await fileHandle.getFile();
                    await handleFile(file);
                } catch (err) {
                    if (err.name !== 'AbortError') console.error('Error picking file:', err);
                }
            } else {
                fileInput.onchange = async (e) => await handleFile(e.target.files[0]);
                fileInput.click();
            }
        },
        handleDragOver(e) { e.preventDefault(); e.stopPropagation(); e.target.classList.add('drag-over'); },
        handleDragLeave(e) { e.preventDefault(); e.stopPropagation(); e.target.classList.remove('drag-over'); },
		handleFileDrop(e) {
			e.preventDefault();
			e.stopPropagation();
			const targetInput = e.target;
			targetInput.classList.remove('drag-over');
			if (e.dataTransfer.files?.length > 0) {
				const file = e.dataTransfer.files[0];
				const assetTypeFolder = targetInput.dataset.assetType === 'sounds' ? 'sounds' : (App.assets.isVideo(file.name) ? 'videos' : 'images');
				const destinationPath = `${assetTypeFolder}/${file.name}`;
				App.state.pendingAssetCopies.set(destinationPath, file);
				targetInput.value = destinationPath;
				targetInput.dispatchEvent(new Event('input', { bubbles: true }));
				App.setDirty(true);
			}
		},
        renderPollinationImage() {
            const promptText = App.elements['scene-image-prompt'].value.trim();
            if (!promptText) { App.ui.showNotification("Please enter a prompt first."); return; }
            App.state.aiImageUrl = null; App.ui.updateAiImagePreview(null, 'Rendering...');

			const randomSeed = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
            const layout = App.state.storyData.meta.layout;
            let urlSuffix = (layout.startsWith('layout-panel') || layout === 'layout-top-down') ? '&width=1280&height=720' : '&width=1024&height=1024';
            const url = "https://image.pollinations.ai/prompt/" + encodeURIComponent(promptText) + `?seed=${randomSeed}&safe=true&nologo=true&enhance=true&model=flux` + urlSuffix;

            const tempImg = new Image();
            tempImg.onload = () => { App.state.aiImageUrl = url; App.ui.updateAiImagePreview(url); };
            tempImg.onerror = () => { App.ui.updateAiImagePreview(null, 'Render failed.'); App.state.aiImageUrl = null; };
            tempImg.src = url;
        },
        async addPollinationImageToScene() {
            if (!App.state.aiImageUrl) { App.ui.showNotification("Please render an image first."); return; }
            App.ui.updateAiImagePreview(null, 'Downloading...');
            try {
                const response = await fetch(App.state.aiImageUrl + '&t=' + Date.now());
                if (!response.ok) throw new Error(`Fetch failed: ${response.statusText}`);
                const imageBlob = await response.blob();
                const filename = `${App.state.currentSceneId || 'image'}_${Date.now()}.jpg`;
                const destinationPath = `images/${filename}`;
                App.state.pendingAssetCopies.set(destinationPath, imageBlob);
                App.elements['scene-image'].value = destinationPath;
                App.elements['scene-image'].dispatchEvent(new Event('input', { bubbles: true }));
                App.ui.updateAiImagePreview(null, 'Ready');
            } catch (err) {
                console.error("Error adding AI image:", err);
                App.ui.showNotification("Could not download or save the image.");
                App.ui.updateAiImagePreview(App.state.aiImageUrl);
            }
        },
        async processTextWithPollinations() {
            const instruction = App.elements['pollinations-instruction'].value.trim();
            const sceneText = App.elements['scene-text'].value.trim();
            if (!instruction || !sceneText) { App.ui.showNotification("Both an instruction and scene text are required."); return; }
            App.modals.hide(App.elements['pollinations-text-modal']); App.ui.showNotification("Processing text with AI...");
            const url = "https://text.pollinations.ai/" + encodeURIComponent(`${instruction}: ${sceneText}`);
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const doc = new DOMParser().parseFromString(await response.text(), 'text/html');
                const processedText = doc.body.innerText.trim();
                if (processedText) {
                    App.elements['scene-text'].value += '\n\n' + processedText;
                    App.elements['scene-text'].dispatchEvent(new Event('input', { bubbles: true }));
                    App.setDirty(true); App.ui.showNotification("Text processing complete!");
                } else { throw new Error("No text found in the response."); }
            } catch (error) { console.error("Error processing text:", error); App.ui.showNotification("Failed to process text. Check console."); }
        }
    },
	player: {
        pauseAllEditorMedia() {
			const ambiencePlayer = App.elements['ambience-player'];
			const previewVideo = App.elements['preview-player-video'];
			if (ambiencePlayer && !ambiencePlayer.paused) {
				ambiencePlayer.pause();
			}
			if (previewVideo && !previewVideo.paused) {
				previewVideo.pause();
			}
		},
        async play(sceneId, fromStart = false) {
            if (!sceneId || !App.state.storyData.scenes[sceneId]) { App.ui.showNotification("Cannot play. Invalid start scene."); return; }
            this.pauseAllEditorMedia();

            const isPlayerAlreadyActive = App.elements['player-container'].style.display === 'flex';
            const isLoopingBackToStart = isPlayerAlreadyActive && sceneId === App.state.storyData.meta.startSceneId;

            if (fromStart || isLoopingBackToStart) {
                this.initializeGameState();
            } else if (!this.gameState) {
                this.initializeGameState();
            }
            
            App.elements['player-container'].style.display = 'flex';
            App.editor.render();

            await this.renderScene(sceneId);
        },
        initializeGameState() {
            this.gameState = { variables: {}, visited: {} };
            (App.state.storyData.meta.variables || []).forEach(varName => {
                this.gameState.variables[varName] = false;
            });
        },
        processChoice(choice) {
            const action = choice.action;
            if (action.set_variable) {
                this.gameState.variables[action.set_variable] = action.set_value;
            }
            if (action.target) {
                this.renderScene(action.target);
            }
        },
        typeWriter(text, choices) {
			const { 'player-text': textEl, 'player-choices': choicesEl, 'player-content-container': contentContainer, 'player-container': playerContainer } = App.elements;

			if (App.state.player.typewriter.intervalId) clearInterval(App.state.player.typewriter.intervalId);
			if (App.state.player.typewriter.skipListener) playerContainer.removeEventListener('click', App.state.player.typewriter.skipListener);

			const originalMinHeight = contentContainer.style.minHeight;
			contentContainer.style.minHeight = '';
			textEl.innerHTML = App.markdown.parse(text);
			choicesEl.innerHTML = '';
			choices.forEach(choice => {
				const button = document.createElement('button');
				button.className = 'choice-btn';
				button.textContent = choice.action.text;
				choicesEl.appendChild(button);
			});
			const finalHeight = contentContainer.offsetHeight;
			contentContainer.style.minHeight = `${finalHeight}px`;

			choicesEl.innerHTML = '';
			textEl.innerHTML = '';
			let i = 0;

			const showChoices = () => {
				choicesEl.innerHTML = '';
				choices.forEach((choice, index) => {
					const button = document.createElement('button');
					button.className = 'choice-btn fade-in';
					button.textContent = choice.action.text;
					button.style.animationDelay = (index * 0.2) + 's';
					button.onclick = (e) => { e.stopPropagation(); this.processChoice(choice); };
					choicesEl.appendChild(button);
				});
			};

			const skipTyping = (e) => {
				if(e) e.stopPropagation();
				clearInterval(App.state.player.typewriter.intervalId);
				playerContainer.removeEventListener('click', App.state.player.typewriter.skipListener);
				textEl.innerHTML = App.markdown.parse(text);
				showChoices();
				contentContainer.style.minHeight = originalMinHeight;
				App.state.player.typewriter.intervalId = null;
				App.state.player.typewriter.skipListener = null;
			};

			App.state.player.typewriter.skipListener = skipTyping;
			playerContainer.addEventListener('click', skipTyping);

			App.state.player.typewriter.intervalId = setInterval(() => {
				if (i >= text.length) {
					skipTyping(null);
				} else {
					textEl.innerHTML = App.markdown.parse(text.substring(0, i + 1));
					i++;
				}
			}, 30);
		},
        async renderScene(sceneId) {
            const isLoopingBackToStart = sceneId === App.state.storyData.meta.startSceneId &&
                                         Object.keys(this.gameState.visited).length > 0;
            if (isLoopingBackToStart) {
                this.initializeGameState();
            }
            App.state.currentSceneId = sceneId;
            this.gameState.visited[sceneId] = true;

            const scene = App.state.storyData.scenes[sceneId];
            const { 'player-text': textEl, 'player-choices': choicesEl, 'ambience-player': audio, 'music-player': music, 'player-video-bg': videoBg, 'player-video-fg': videoFg, 'player-image': imageEl } = App.elements;
            const playerContainer = App.elements['player-container'];
            const playerInnerContainer = App.elements['player-inner-container'];
            const playerImageContainer = document.getElementById('player-image-container');

            if (!scene) { textEl.innerHTML = `Error: Scene "${sceneId}" not found.`; return; }

            App.styles.applyToContainer(playerContainer);
            App.styles.updateLivePlayerStyles();

            const styles = App.state.storyData.meta.styles;

            const [sceneMediaUrl] = await Promise.all([
                App.io.getAssetDataUrl(scene?.image),
            ]);

            const isMediaVideo = App.assets.isVideo(scene.image);
            const isPanelLayout = App.state.storyData.meta.layout.startsWith('layout-panel');

			playerImageContainer.style.display = 'none';
			imageEl.style.display = 'none';
			[videoBg, videoFg].forEach(v => {
				v.style.display = 'none';
				if (!v.paused) { v.pause(); v.removeAttribute('src'); v.load(); }
			});
			playerContainer.style.backgroundImage = 'var(--screen-bg-image)';
			playerContainer.style.backgroundColor = '';
			App.state.player.activeVideoElement = null;

			if (sceneMediaUrl) {
				if (isMediaVideo) {
					App.state.player.activeVideoElement = isPanelLayout ? videoBg : videoFg;
					if (!isPanelLayout) playerImageContainer.style.display = 'block';

					App.state.player.activeVideoElement.src = sceneMediaUrl;
					App.state.player.activeVideoElement.loop = scene.videoLoop ?? true;
					App.state.player.activeVideoElement.muted = scene.videoMuted ?? true;
					App.state.player.activeVideoElement.volume = parseFloat(styles['--video-volume'] || 1.0);
					App.state.player.activeVideoElement.style.display = 'block';
					App.state.player.activeVideoElement.play().catch(e => console.warn("In-editor player video playback failed.", e));
				} else {
					if (isPanelLayout) {
						playerContainer.style.backgroundImage = `url('${sceneMediaUrl}')`;
					} else {
						imageEl.src = sceneMediaUrl;
						imageEl.style.display = 'block';
						playerImageContainer.style.display = 'block';
					}
				}
			} else {
            playerContainer.style.backgroundImage = 'none';
            playerContainer.style.backgroundColor = styles['--bg-color'] || App.styles.getDefaults()['--bg-color'];
			}

            let visibleChoices = [];
            for(const choice of (scene.choices || [])) {
                let conditionMet = true;
                if(choice.condition) {
                    const varName = choice.condition.variable;
                    if(varName.startsWith('visited_scene_')) {
                        conditionMet = !!this.gameState.visited[varName.substring(14)] === choice.condition.value;
                    } else {
                        conditionMet = this.gameState.variables[varName.substring(4)] === choice.condition.value;
                    }
                }

                if (conditionMet) {
                    if (!choice.action.text && choice.action.target) {
                        if (choice.action.target === sceneId) {
                            console.error(`Infinite loop detected in scene '${sceneId}'. A silent action is targeting itself.`);
                            continue;
                        }
                        this.processChoice(choice);
                        return;
                    }
                    if (choice.action.text) {
                        visibleChoices.push(choice);
                    } else if (choice.action.set_variable) {
                         this.gameState.variables[choice.action.set_variable] = choice.action.set_value;
                    }
                }
            }

            if (styles['--typewriter-effect'] === 'on') {
                this.typeWriter(scene.text, visibleChoices);
            } else {
                textEl.innerHTML = App.markdown.parse(scene.text);
                choicesEl.innerHTML = '';
                visibleChoices.forEach(choice => {
                    const button = document.createElement('button');
                    button.className = 'choice-btn';
                    button.textContent = choice.action.text;
                    button.onclick = () => this.processChoice(choice);
                    choicesEl.appendChild(button);
                });
            }

            audio.loop = scene.ambienceLoop ?? true;
            const soundUrl = await App.io.getAssetDataUrl(scene.ambienceSound);
            if (soundUrl) { if(audio.src !== soundUrl) audio.src = soundUrl; audio.play().catch(e=>console.warn("Audio autoplay blocked.")); }
            else { audio.pause(); }
        },
        stop() {
            App.elements['player-container'].style.display = 'none';

            App.elements['ambience-player'].pause(); App.elements['music-player'].pause();
            App.elements['ambience-player'].src = ''; App.elements['music-player'].src = '';

            const videos = [App.elements['player-video-bg'], App.elements['player-video-fg']];
            videos.forEach(playerVideo => {
                if(playerVideo) {
                    playerVideo.pause();
                    playerVideo.removeAttribute('src');
                    playerVideo.load();
                    playerVideo.style.display = 'none';
                }
            });
            App.state.player.activeVideoElement = null;
            App.editor.render();

            if (App.state.currentSceneId) App.ui.selectScene(App.state.currentSceneId);
        },
        async toggleAmbienceSound() {
			const audio = App.elements['ambience-player'];
            const soundPath = App.elements['scene-sound'].value;
            if (!soundPath) return;

            const scene = App.state.storyData.scenes[App.state.currentSceneId];
            if (scene) audio.loop = scene.ambienceLoop ?? true;

            const soundUrl = await App.io.getAssetDataUrl(soundPath);
            if (!soundUrl) { App.ui.showNotification("Audio file not found in project."); return; }

            if (!audio.paused && audio.src.endsWith(soundUrl)) {
                audio.pause();
            } else {
                audio.src = soundUrl;
                audio.play().catch(e => console.warn("Audio playback failed.", e));
            }
        },
        updateAmbienceButton(isPlaying) {
            App.elements['ambience-play-icon'].classList.toggle('hidden', isPlaying);
            App.elements['ambience-pause-icon'].classList.toggle('hidden', !isPlaying);
        }
    },

    styles: {
        open() {
            App.modals.hide(document.getElementById('project-menu-modal'));

            const sidebar = document.getElementById('left-panel-container');
            const rect = sidebar.getBoundingClientRect();
            const modalContent = document.querySelector('#style-editor-modal .modal-content');

            modalContent.style.top = `${rect.top}px`;
            modalContent.style.left = `${rect.left}px`;
            modalContent.style.width = `${rect.width - (sidebar.offsetWidth - sidebar.clientWidth)}px`;
            modalContent.style.height = `${rect.height}px`;

            const grid = document.getElementById('style-editor-grid');
            const styles = App.state.storyData.meta.styles;
            const defaults = this.getDefaults();

            const fontOptions = App.constants.GOOGLE_FONTS.map(font => `<option value="${font.value}">${font.name}</option>`).join('');

            grid.innerHTML = `
                <div class="grid-full-width"> <label>Layout <select id="style-layout">
                    <option value="layout-top-down">Image on Top</option>
                    <option value="layout-side-by-side">Image on Side</option>
                    <option value="layout-panel-bottom">Panel Bottom</option>
                    <option value="layout-panel-left">Panel Left</option>
                    <option value="layout-panel-right">Panel Right</option>
                </select></label> </div>
                <div class="grid-span-2"> <label>Font Family <select id="style-font-family">${fontOptions}</select></label> <label>Font Size (px) <input type="number" id="style-font-size" min="8" max="48" step="1"></label> </div>
                <div class="grid-span-2"> <label>Text Color <input type="color" id="style-text-color"></label> <label>Typewriter Effect <select id="style-typewriter-effect"><option value="off">Off</option><option value="on">On</option></select></label> </div>
                <hr class="grid-separator">
                <label>Page BG Color <input type="color" id="style-bg-color"></label>
                <div class="grid-full-width"> <label>Page BG Image <div class="form-group inline" style="margin:0;"><input type="text" id="style-screen-bg-image" class="path-input" data-asset-type="images" placeholder="images/bg.jpg"><button class="btn-warning file-icon-btn" title="Select Screen Background">📁</button></div></label> </div>
                <hr class="grid-separator">
                <div class="grid-full-width"> <label>Container Padding (px) <input type="number" id="style-padding" min="0"></label> </div>
                <div class="grid-span-2"> <label>Container Effect <select id="style-container-effect"><option value="none">None</option><option value="shadow">Shadow</option><option value="outline">Outline</option></select></label> <label id="outline-color-label">Outline Color <input type="color" id="style-container-outline-color"></label></div>
                <div class="grid-span-2"> <label>Container BG Color <input type="color" id="style-container-bg-color"></label> <label>Container BG Opacity <input type="range" id="style-container-bg-opacity" min="0" max="1" step="0.01"></label> </div>
                <hr class="grid-separator">
                <div class="grid-span-2"> <label>Button Color <input type="color" id="style-btn-color"></label> <label>Button Opacity <input type="range" id="style-btn-opacity" min="0" max="1" step="0.01" value="1"></label> </div>
                <div class="grid-span-2"> <label>Button Hover Color <input type="color" id="style-btn-hover-color"></label> <label>Button Text Color <input type="color" id="style-btn-text-color"></label> </div>
                <hr class="grid-separator">
                <div class="grid-full-width"> <label>Background Music <div class="form-group inline" style="margin:0;"><input type="text" id="style-music-path" class="path-input" data-asset-type="sounds" placeholder="sounds/music.mp3"><button class="btn-warning file-icon-btn" title="Select Music File">📁</button></div></label> </div>
                <div class="grid-span-2"> <label>Music Volume <input type="range" id="style-music-volume" min="0" max="1" step="0.01"></label> <label>Ambience Volume <input type="range" id="style-ambience-volume" min="0" max="1" step="0.01"></label> </div>
                <div class="grid-full-width"> <label>Video Volume <input type="range" id="style-video-volume" min="0" max="1" step="0.01"></label> </div>
            `;

            Object.keys(defaults).forEach(key => { const el = grid.querySelector(`#style-${key.replace(/--/g, '')}`); if(el) el.value = (el.type === 'number' || key.endsWith('-volume')) ? parseFloat(styles[key] || defaults[key]) : (styles[key] || defaults[key]).replace('px', ''); });
            grid.querySelector('#style-layout').value = App.state.storyData.meta.layout;

            const parseAndSetColor = (colorVar, hexId, opacityId = null) => {
                const colorVal = styles[colorVar] || defaults[colorVar]; const match = colorVal.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/); const toHex = c => ('0' + parseInt(c).toString(16)).slice(-2);
                if (match) { grid.querySelector(`#${hexId}`).value = `#${toHex(match[1])}${toHex(match[2])}${toHex(match[3])}`; if (opacityId) grid.querySelector(`#${opacityId}`).value = match[4] ?? 1; }
                else { grid.querySelector(`#${hexId}`).value = colorVal; if (opacityId) grid.querySelector(`#${opacityId}`).value = 1; }
            };
            parseAndSetColor('--bg-color', 'style-bg-color'); parseAndSetColor('--text-color', 'style-text-color'); parseAndSetColor('--btn-text-color', 'style-btn-text-color');
            parseAndSetColor('--container-bg-color', 'style-container-bg-color', 'style-container-bg-opacity'); parseAndSetColor('--btn-color', 'style-btn-color', 'style-btn-opacity'); parseAndSetColor('--btn-hover-color', 'style-btn-hover-color');

            grid.oninput = (e) => this.handleUpdate(e);
            grid.querySelectorAll('.file-icon-btn').forEach(btn => { const input = btn.previousElementSibling; btn.onclick = () => App.assets.selectFile(input.dataset.assetType, input.id); });
            grid.querySelectorAll('.path-input').forEach(input => { input.addEventListener('dragover', App.assets.handleDragOver); input.addEventListener('dragleave', App.assets.handleDragLeave); input.addEventListener('drop', App.assets.handleFileDrop); });
            this.handleUpdate({target: grid.querySelector('#style-container-effect')}); // Initial setup for outline visibility
            App.modals.show('style-editor-modal');
        },
        handleUpdate(e) {
            const el = e.target;
            const key = `--${el.id.replace('style-', '')}`;
            const meta = App.state.storyData.meta;
        
            if (el.id === 'style-layout') {
                meta.layout = el.value;
            } else if (el.id === 'style-container-bg-opacity' || el.id === 'style-btn-opacity') {
                const colorKey = el.id === 'style-container-bg-opacity' ? '--container-bg-color' : '--btn-color';
                const colorInputId = el.id === 'style-container-bg-opacity' ? 'style-container-bg-color' : 'style-btn-color';
                const hex = document.getElementById(colorInputId).value; // FIX: Read current color from picker
                const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
                meta.styles[colorKey] = `rgba(${r},${g},${b},${el.value})`;
            } else if (el.type === 'color') {
                const opacityKey = el.id === 'style-container-bg-color' ? 'style-container-bg-opacity' : (el.id === 'style-btn-color' ? 'style-btn-opacity' : null);
                if (opacityKey) {
                    const opacity = document.getElementById(opacityKey).value;
                    const r = parseInt(el.value.slice(1, 3), 16), g = parseInt(el.value.slice(3, 5), 16), b = parseInt(el.value.slice(5, 7), 16);
                    meta.styles[key] = `rgba(${r},${g},${b},${opacity})`;
                } else {
                    meta.styles[key] = el.value;
                }
            } else if (el.id === 'style-container-effect') {
                document.getElementById('outline-color-label').style.display = el.value === 'outline' ? 'block' : 'none';
                meta.styles[key] = el.value; // Save the effect type
            } else if (el.id.endsWith('-size') || el.id.endsWith('-padding')) {
                meta.styles[key] = `${el.value}px`;
            } else {
                meta.styles[key] = el.value;
            }
            
            if (key === '--font-family') {
                this.loadGoogleFont(el.value);
            }
            
            App.setDirty(true);
            App.editor.renderPreview();
            this.updateLivePlayerStyles();
        },
        async updateLivePlayerStyles() {
            if (App.elements['player-container'].style.display !== 'flex') {
                return;
            }
        
            const playerContainer = App.elements['player-container'];
            const meta = App.state.storyData.meta;
            const styles = meta.styles;
        
            // 1. Apply all CSS variable-driven styles
            this.applyToContainer(playerContainer);
        
            // 2. Handle layout change
            const currentLayout = meta.layout;
            playerContainer.className = currentLayout;
            App.elements['player-inner-container'].className = currentLayout;
        
            // Re-evaluate media display based on the new layout
            const scene = App.state.storyData.scenes[App.state.currentSceneId];
            if (scene) {
                const isMediaVideo = App.assets.isVideo(scene.image);
                const sceneMediaUrl = await App.io.getAssetDataUrl(scene.image);
                const isPanelLayout = currentLayout.startsWith('layout-panel');
                
                // Stop and hide all media first
                App.elements['player-image'].style.display = 'none';
                [App.elements['player-video-bg'], App.elements['player-video-fg']].forEach(v => {
                    if (!v.paused) v.pause();
                    v.style.display = 'none';
                });
                playerContainer.style.backgroundImage = 'none';
        
                if (sceneMediaUrl) {
                    if (isMediaVideo) {
                        const videoEl = isPanelLayout ? App.elements['player-video-bg'] : App.elements['player-video-fg'];
                        videoEl.style.display = 'block';
                        if (videoEl.src !== sceneMediaUrl) videoEl.src = sceneMediaUrl;
                        if (videoEl.paused) videoEl.play().catch(e => console.warn(e));
                    } else {
                        if (isPanelLayout) {
                            playerContainer.style.backgroundImage = `url('${sceneMediaUrl}')`;
                        } else {
                            App.elements['player-image'].src = sceneMediaUrl;
                            App.elements['player-image'].style.display = 'block';
                        }
                    }
                }
            }
        
            // 3. Update Audio Volumes
            App.elements['music-player'].volume = parseFloat(styles['--music-volume'] || 0.4);
            App.elements['ambience-player'].volume = parseFloat(styles['--ambience-volume'] || 0.4);
            if (App.state.player.activeVideoElement) {
                App.state.player.activeVideoElement.volume = parseFloat(styles['--video-volume'] || 1.0);
            }
        
            // 4. Handle Music Path Change
            const musicPath = styles['--music-path'];
            const musicUrl = await App.io.getAssetDataUrl(musicPath);
            const musicPlayer = App.elements['music-player'];
            if (musicUrl) {
                if (musicPlayer.src !== musicUrl) musicPlayer.src = musicUrl;
                if (musicPlayer.paused) musicPlayer.play().catch(e => console.warn(e));
            } else {
                musicPlayer.pause();
                musicPlayer.src = '';
            }
        
            // 5. Handle Typewriter Effect (This will only apply on the next scene render)
            // No direct action can be taken here to change text already on screen without re-rendering it,
            // but the setting is saved, and the player logic will pick it up on the next scene.
        },
        loadGoogleFont(fontFamily) {
            const fontName = fontFamily.split(',')[0].replace(/'/g, '').trim();
            const isGoogleFont = App.constants.GOOGLE_FONTS.find(f => f.name === fontName && !f.value.startsWith('-'));

            const existingLink = document.getElementById('google-font-stylesheet');
            if (!isGoogleFont) {
                if (existingLink) existingLink.remove();
                return;
            }

            const formattedFontName = fontName.replace(/ /g, '+');
            const fontUrl = `https://fonts.googleapis.com/css2?family=${formattedFontName}:wght@400;700&display=swap`;

            let link = existingLink;
            if (!link) {
                link = document.createElement('link');
                link.id = 'google-font-stylesheet';
                link.rel = 'stylesheet';
                document.head.appendChild(link);
            }
            if (link.href !== fontUrl) {
                link.href = fontUrl;
            }
        },
        applyToContainer(container) {
			const meta = App.state.storyData.meta;
			const styles = meta.styles;
			const defaults = this.getDefaults();
			const innerContainer = container.querySelector('#preview-player-inner-container, #player-inner-container');

			Object.keys(defaults).forEach(key => {
				let value = styles[key] || defaults[key];
					if (key.includes('-image') && value && value && !value.startsWith('url(')) {
						value = `url('${value}')`;
				}
				container.style.setProperty(key, value);
			});

			container.className = meta.layout;
			if (innerContainer) {
				innerContainer.className = meta.layout;
				innerContainer.style.setProperty('--container-bg-color', styles['--container-bg-color'] || defaults['--container-bg-color']);

				// Handle Shadow vs Outline
				const effect = styles['--container-effect'] || defaults['--container-effect'];
				if (effect === 'outline') {
					innerContainer.style.setProperty('--container-shadow', 'none');
					innerContainer.style.setProperty('--container-outline-width', '2px');
					innerContainer.style.setProperty('--container-outline-color', styles['--container-outline-color'] || defaults['--container-outline-color']);
				} else if (effect === 'shadow') { // Shadow
					innerContainer.style.setProperty('--container-shadow', '0 5px 20px rgba(0,0,0,.5)');
					innerContainer.style.setProperty('--container-outline-width', '0px');
                    innerContainer.style.setProperty('--container-outline-color', 'transparent');
				} else { // None
                    innerContainer.style.setProperty('--container-shadow', 'none');
                    innerContainer.style.setProperty('--container-outline-width', '0px');
                    innerContainer.style.setProperty('--container-outline-color', 'transparent');
                }
			}
		},
        generateCSS(stylesOverride) {
			const styles = stylesOverride || App.state.storyData.meta.styles;
			const defaults = this.getDefaults();
			let rootVars = '';
			Object.keys(defaults).forEach(key => {
				let value = styles[key] || defaults[key];
				if (key.includes('-image') && value) {
					value = `url('${value}')`;
				}
				if (!key.includes('path')) { // Keep all CSS vars
					rootVars += `    ${key}: ${value};\n`;
				}
			});

			// Add container effect variables
			const effect = styles['--container-effect'] || defaults['--container-effect'];
			if (effect === 'outline') {
				rootVars += `    --container-shadow: none;\n`;
				rootVars += `    --container-outline-width: 2px;\n`;
			} else if (effect === 'shadow') {
				rootVars += `    --container-shadow: 0 5px 20px rgba(0,0,0,.5);\n`;
				rootVars += `    --container-outline-width: 0px;\n`;
                rootVars += `    --container-outline-color: transparent;\n`;
			} else { // None
                rootVars += `    --container-shadow: none;\n`;
                rootVars += `    --container-outline-width: 0px;\n`;
                rootVars += `    --container-outline-color: transparent;\n`;
            }

			return `:root {\n${rootVars}} body { background-image: var(--screen-bg-image); background-color: var(--bg-color); color: var(--text-color); font-family: var(--font-family); } #game-container { font-size: var(--font-size); background-color: var(--container-bg-color); } .choice-btn { font-family: var(--font-family); background-color: var(--btn-color); color: var(--btn-text-color); border-width: var(--container-outline-width, 0px); border-style: solid; border-color: var(--container-outline-color, transparent); } .choice-btn:hover { background-color: var(--btn-hover-color); }`;
		},
        getDefaults() { return { '--bg-color': '#212529', '--text-color': '#f8f9fa', '--btn-color': 'rgba(108, 117, 125, 1)', '--btn-text-color': '#ffffff', '--btn-hover-color': 'rgba(90, 98, 104, 1)', '--font-family': '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif', '--font-size': '16px', '--padding': '30px', '--screen-bg-image': '', '--container-bg-color': 'rgba(0,0,0,0.15)', '--container-effect': 'shadow', '--container-outline-color': '#FFFFFF', '--music-path': '', '--music-volume': '0.4', '--ambience-volume': '0.4', '--video-volume': '1.0', '--typewriter-effect': 'on' }; }
    },

    modals: {
        show(modalId) { document.getElementById(modalId).classList.add('visible'); },
        hide(modal) {
            if (modal) {
                if (modal.id === 'batch-image-modal' && App.batch.isGenerating) { App.batch.logInfo("Cannot close while generation is running. Please Abort first."); return; }
                modal.classList.remove('visible');
            }
        },
        hideAll() { document.querySelectorAll('.modal').forEach(m => this.hide(m)); }
    },

    batch: {
        isGenerating: false, abortRequested: false,

        open() {
            App.modals.hide(document.getElementById('project-menu-modal'));
            const sidebar = document.getElementById('left-panel-container');
            const rect = sidebar.getBoundingClientRect();
            const modalContent = document.querySelector('#batch-image-modal .modal-content');
            modalContent.style.top = `${rect.top}px`;
            modalContent.style.left = `${rect.left}px`;
            modalContent.style.width = `${rect.width - (sidebar.offsetWidth - sidebar.clientWidth)}px`;
            modalContent.style.height = `${rect.height}px`;
            App.modals.show('batch-image-modal');
        },
        logInfo(message) {
            const logEl = document.getElementById('batch-info-log');
            logEl.textContent += `[${new Date().toLocaleTimeString()}] ${message}\n`;
            logEl.scrollTop = logEl.scrollHeight;
        },
        removeAllImages() {
            if (!confirm("Delete image/video paths from ALL scenes? This cannot be undone.")) return;
            let count = 0; Object.values(App.state.storyData.scenes).forEach(scene => { if (scene.image) { scene.image = ''; scene.mediaType = 'none'; count++; } });
            App.setDirty(true); App.editor.render(); App.ui.invalidateNavViews(); App.ui.setViewMode(App.state.currentNavView); App.ui.showNotification(`${count} image/video paths deleted.`);
        },
        removeAllImagePrompts() {
            if (!confirm("Delete image prompts from ALL scenes? This cannot be undone.")) return;
            let count = 0; Object.values(App.state.storyData.scenes).forEach(scene => { if (scene.imagePrompt) { scene.imagePrompt = ''; count++; } });
            App.setDirty(true); App.editor.render(); App.ui.showNotification(`${count} image prompts deleted.`);
        },
        async startGeneration() {
            if (this.isGenerating) { this.abortRequested = true; this.logInfo("Abort requested..."); document.getElementById('batch-generate-btn').disabled = true; return; }
            const rewrite = document.getElementById('batch-rewrite-prompt-checkbox').checked;
            const overwrite = document.getElementById('batch-overwrite-checkbox').checked;
            let confirmMsg = overwrite ? (rewrite ? "Overwrite existing prompts AND images for all scenes?" : "Overwrite existing images for all scenes with prompts?") : null;
            if (confirmMsg && !confirm(confirmMsg + "\nAre you sure?")) { this.logInfo("Overwrite cancelled."); return; }

            this.isGenerating = true; this.abortRequested = false;
            const btn = document.getElementById('batch-generate-btn'); const fieldset = document.getElementById('batch-fieldset');
            document.getElementById('batch-info-log').textContent = ''; this.logInfo("Starting batch generation...");
            fieldset.disabled = true; btn.innerHTML = `<svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z"/></svg> Abort`;

            const suffix = document.getElementById('batch-suffix-input').value.trim();
            const cooldown = parseInt(document.getElementById('batch-cooldown-input').value, 10) * 1000;
            let generatedCount = 0;

            for (const sceneId of Object.keys(App.state.storyData.scenes)) {
                if (this.abortRequested) break;
                const scene = App.state.storyData.scenes[sceneId];
                this.logInfo(`--- Processing: ${sceneId} ---`);
                if (scene.image && !overwrite) { this.logInfo("Has image, skipping."); continue; }

                let prompt = scene.imagePrompt;
                if (rewrite && (!prompt || overwrite)) {
                    this.logInfo("AI rewriting prompt...");
                    const newPrompt = await this.generatePromptForScene(scene);
                    if (newPrompt) { prompt = newPrompt; scene.imagePrompt = prompt; App.setDirty(true); this.logInfo(`New prompt: "${prompt}"`); }
                    else { this.logInfo("Failed to rewrite prompt."); }
                }

                if (!prompt) { this.logInfo("No prompt, skipping."); continue; }
                const success = await this.generateAndSaveImage(scene, prompt, suffix);
                if (!success) { this.logInfo("Error during image generation. ABORTING."); break; }

                App.ui.selectScene(sceneId); generatedCount++;
                if (this.abortRequested) break;
                if (cooldown > 0) { this.logInfo(`Cooldown ${cooldown/1000}s...`); await new Promise(r => setTimeout(r, cooldown)); }
            }

            this.logInfo("-----------------------------------");
            this.logInfo(this.abortRequested ? "Batch process aborted by user." : `Finished. Generated ${generatedCount} new images.`);
            if (generatedCount > 0) this.logInfo("IMPORTANT: Remember to Save Project!");

            this.isGenerating = false; this.abortRequested = false; fieldset.disabled = false; btn.disabled = false;
            btn.innerHTML = `<svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M7.657 6.247c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937z"/></svg> Generate`;
            App.editor.render(); App.ui.invalidateNavViews(); await App.ui.setViewMode(App.state.currentNavView);
        },

        async generatePromptForScene(scene) {
            if (!scene.text) return null;
            const instruction = "Analyze the text like a cinematographer. Create a vivid, cinematic image prompt. Structure: camera angle, subject, action, setting, location, year, lighting, colors, mood. Combine related details into evocative concepts. Output as comma-separated nouns and adjectives. No labels or comments in the result.";
            const combinedText = `${instruction}: ${scene.text}`;
            const url = "https://text.pollinations.ai/" + encodeURIComponent(combinedText);
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const htmlString = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlString, 'text/html');
                const processedText = doc.body.innerText.trim();
                return processedText || null;
            } catch (error) {
                console.error("Error generating prompt:", error);
                this.logInfo(`Error generating prompt: ${error.message}`);
                return null;
            }
        },

        async generateAndSaveImage(scene, prompt, suffix) {
            const fullPrompt = (prompt + ' ' + suffix).trim();
            this.logInfo(`Generating image with prompt: "${fullPrompt}"`);

            const layout = App.state.storyData.meta.layout;
            let urlSuffix = (layout.startsWith('layout-panel') || layout === 'layout-top-down')
                ? '&width=1280&height=720'
                : '&width=1024&height=1024';

            const randomSeed = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
            const url = "https://image.pollinations.ai/prompt/" + encodeURIComponent(fullPrompt) + `?seed=${randomSeed}&safe=true&nologo=true&enhance=true&model=flux` + urlSuffix;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Fetch failed: ${response.status} ${response.statusText}`);
                const imageBlob = await response.blob();
                const filename = `${scene.id}_${Date.now()}.jpg`;
                const destinationPath = `images/${filename}`;

                App.state.pendingAssetCopies.set(destinationPath, imageBlob);
                scene.image = destinationPath;
                scene.mediaType = 'image'; // Set mediaType when adding an image
                App.setDirty(true);

                this.logInfo(`Image successfully generated and queued for saving: ${destinationPath}`);
                return true;
            } catch (err) {
                console.error("Error generating/saving AI image:", err);
                this.logInfo(`Error: ${err.message}`);
                return false;
            }
        }
    },

    // --- NODE EDITOR ---
    nodeEditor: {
        state: {
            pan: { x: 0, y: 0 },
            zoom: 1,
            isPanning: false,
            panStart: { x: 0, y: 0 },
            draggedNode: null,
            dragOffset: { x: 0, y: 0 },
            orphanIndex: -1,
            contextMenuPos: { x: 0, y: 0 },
            edgeContextMenuData: null,
            isConnecting: false,
            connectionStart: null,
        },

        init() {
            const view = App.elements['node-editor-view'];
            view.addEventListener('mousedown', this.handleMouseDown.bind(this));
            view.addEventListener('mousemove', this.handleMouseMove.bind(this));
            view.addEventListener('mouseup', this.handleMouseUp.bind(this));
            view.addEventListener('mouseleave', this.handleMouseUp.bind(this));
            view.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });
            view.addEventListener('contextmenu', this.handleContextMenu.bind(this));
        },

        onResize() {
            this.updateTransform();
        },

		handleMouseDown(e) {
			const target = e.target;
			const nodeEl = target.closest('.node-editor-node');
			
			if (e.button === 0) { // Left mouse button
				if (target.classList.contains('node-handle-bottom')) {
					e.preventDefault();
					e.stopPropagation();
					this.state.isConnecting = true;
					this.state.connectionStart = { sceneId: nodeEl.dataset.sceneId };
					App.elements['temp-edge'].setAttribute('visibility', 'visible');
				} else if (nodeEl && target.closest('.node-header')) {
					this.state.draggedNode = nodeEl;
					const scene = App.state.storyData.scenes[nodeEl.dataset.sceneId];
					const viewRect = App.elements['node-editor-view'].getBoundingClientRect();
					const mouseX = (e.clientX - viewRect.left);
					const mouseY = (e.clientY - viewRect.top);

					const transformedMouseX = (mouseX - this.state.pan.x) / this.state.zoom;
					const transformedMouseY = (mouseY - this.state.pan.y) / this.state.zoom;

					this.state.dragOffset = {
						x: transformedMouseX - scene.position.x,
						y: transformedMouseY - scene.position.y
					};
					nodeEl.style.zIndex = 1000;
				} else if (nodeEl) {
					App.ui.selectScene(nodeEl.dataset.sceneId);
					if (e.detail === 2) { // Double-click
						this.editNodeText(nodeEl);
					}
				} else {
					this.state.isPanning = true;
					App.elements['node-editor-view'].classList.add('grabbing');
					this.state.panStart = { x: e.clientX, y: e.clientY };
				}
			}
		},

        handleMouseMove(e) {
            const viewRect = App.elements['node-editor-view'].getBoundingClientRect();
            const mouseX = e.clientX - viewRect.left;
            const mouseY = e.clientY - viewRect.top;
            const transformedMouseX = (mouseX - this.state.pan.x) / this.state.zoom;
            const transformedMouseY = (mouseY - this.state.pan.y) / this.state.zoom;

            if (this.state.isPanning) {
                const dx = e.clientX - this.state.panStart.x;
                const dy = e.clientY - this.state.panStart.y;
                this.state.pan.x += dx;
                this.state.pan.y += dy;
                this.state.panStart = { x: e.clientX, y: e.clientY };
                this.updateTransform();
            } else if (this.state.draggedNode) {
                const newX = transformedMouseX - this.state.dragOffset.x;
                const newY = transformedMouseY - this.state.dragOffset.y;

                const scene = App.state.storyData.scenes[this.state.draggedNode.dataset.sceneId];
                if(scene) {
                    scene.position.x = newX;
                    scene.position.y = newY;
                    this.state.draggedNode.style.transform = `translate(${newX}px, ${newY}px)`;
                    this.renderEdges();
                }
            } else if (this.state.isConnecting) {
                const sourceNodeEl = document.querySelector(`.node-editor-node[data-scene-id="${this.state.connectionStart.sceneId}"]`);
                const sourceScene = App.state.storyData.scenes[this.state.connectionStart.sceneId];
                const startX = sourceScene.position.x + sourceNodeEl.offsetWidth / 2;
                const startY = sourceScene.position.y + sourceNodeEl.offsetHeight;
                const pathData = `M ${startX} ${startY} L ${transformedMouseX} ${transformedMouseY}`;
                App.elements['temp-edge'].setAttribute('d', pathData);
            }
        },

        handleMouseUp(e) {
            if (this.state.isConnecting) {
                const targetHandle = e.target.closest('.node-handle-top');
                if (targetHandle) {
                    const targetNode = targetHandle.closest('.node-editor-node');
                    const targetSceneId = targetNode.dataset.sceneId;
                    const sourceSceneId = this.state.connectionStart.sceneId;
                    if (sourceSceneId !== targetSceneId) {
                         App.ui.showCustomPrompt({
                            text: "Enter text for this choice:",
                            value: `Go to ${targetSceneId}`,
                            event: e,
                            callback: (choiceText) => {
                                if (choiceText !== null) {
                                    const sourceScene = App.state.storyData.scenes[sourceSceneId];
                                    sourceScene.choices.push({
                                        condition: null,
                                        action: { text: choiceText, target: targetSceneId, set_variable: null, set_value: false }
                                    });
                                    App.setDirty(true);
                                    this.renderEdges();
                                    if (App.state.currentSceneId === sourceSceneId) {
                                        App.editor.render();
                                    }
                                }
                            }
                        });
                    }
                }
                App.elements['temp-edge'].setAttribute('visibility', 'hidden');
                this.state.isConnecting = false;
                this.state.connectionStart = null;
            }
            if (this.state.isPanning) {
                this.state.isPanning = false;
                App.elements['node-editor-view'].classList.remove('grabbing');
            } else if (this.state.draggedNode) {
                const sceneId = this.state.draggedNode.dataset.sceneId;
                const scene = App.state.storyData.scenes[sceneId];
                if (scene) {
                    App.setDirty(true);
                }
                this.state.draggedNode.style.zIndex = '';
                this.state.draggedNode = null;
            }
        },

        handleWheel(e) {
            e.preventDefault();
            this.zoom(e.deltaY > 0 ? 1 / 1.05 : 1.05, e.clientX, e.clientY);
        },

        handleContextMenu(e) {
            e.preventDefault();
            const edgeGroup = e.target.closest('.edge-group');
            if (edgeGroup) {
                 this.state.edgeContextMenuData = {
                    sourceId: edgeGroup.dataset.sourceId,
                    choiceIndex: parseInt(edgeGroup.dataset.choiceIndex)
                };
            } else {
                 this.state.edgeContextMenuData = null;
            }

            const nodeEl = e.target.closest('.node-editor-node');
            App.state.contextSceneId = nodeEl ? nodeEl.dataset.sceneId : null;

            const viewRect = App.elements['node-editor-view'].getBoundingClientRect();
            const canvasX = (e.clientX - viewRect.left - this.state.pan.x) / this.state.zoom;
            const canvasY = (e.clientY - viewRect.top - this.state.pan.y) / this.state.zoom;
            this.state.contextMenuPos = { x: canvasX, y: canvasY };

            const menu = App.elements['editor-context-menu'];
            this.showContextMenu(e, menu);
        },

        updateTransform() {
            const { pan, zoom } = this.state;
            const transformPane = App.elements['transform-pane'];
            if(transformPane) {
                transformPane.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`;
            }
            const nodeEditorView = App.elements['node-editor-view'];
            if(nodeEditorView) {
                const gridSize = 20;
                const dotSize = 0.5;
                const scaledGridSize = gridSize * zoom;
                
                const opacity = Math.min(1, Math.max(0, (scaledGridSize - 2) / 4));

                nodeEditorView.style.backgroundImage = `radial-gradient(rgba(60, 61, 64, ${opacity * 0.7}) ${dotSize}px, transparent 0)`;
                nodeEditorView.style.backgroundSize = `${scaledGridSize}px ${scaledGridSize}px`;
                nodeEditorView.style.backgroundPosition = `${pan.x}px ${pan.y}px`;
            }
        },

		async render(filterTerm = '') {
			if (!App.state.storyData?.scenes) {
				App.elements['node-element-container'].innerHTML = '';
				this.renderEdges();
				return;
			}
			const container = App.elements['node-element-container'];
			container.innerHTML = '';
			const fragment = document.createDocumentFragment();
			App.tree.findAllSceneLinks();

			const searchText = filterTerm.trim().toLowerCase();

			const scenesWithInputs = new Set();
			const scenesWithOutputs = new Set();
			Object.values(App.state.storyData.scenes).forEach(scene => {
				if (scene.choices && scene.choices.some(c => c.action.target)) {
					scenesWithOutputs.add(scene.id);
					scene.choices.forEach(c => {
						if (c.action.target) {
							scenesWithInputs.add(c.action.target);
						}
					});
				}
			});
			const connectionData = { scenesWithInputs, scenesWithOutputs };

			for (const scene of Object.values(App.state.storyData.scenes)) {
				const isFiltered = searchText && !scene.id.toLowerCase().includes(searchText) && !(scene.text || '').toLowerCase().includes(searchText);
				const nodeEl = await this.createNodeElement(scene, isFiltered, connectionData);
				fragment.appendChild(nodeEl);
			}
			container.appendChild(fragment);
			this.updateSelection();
			this.renderEdges();
		},

		async createNodeElement(scene, isFiltered, connectionData) {
			const { scenesWithInputs, scenesWithOutputs } = connectionData;
			const nodeEl = document.createElement('div');
			nodeEl.className = 'node-editor-node';
			nodeEl.dataset.sceneId = scene.id;
			nodeEl.style.transform = `translate(${scene.position.x}px, ${scene.position.y}px)`;

            if (isFiltered) nodeEl.classList.add('is-filtered-out');

            const brokenLinks = App.state.brokenAssetLinks.get(scene.id);
            if (brokenLinks) {
                nodeEl.classList.add('has-broken-link');
                nodeEl.title = `Broken Asset Links:\n${brokenLinks.join('\n')}`;
            }

            const isStart = scene.id === App.state.storyData.meta.startSceneId;
            const hasSound = !!scene.ambienceSound;
            const hasConditions = (scene.choices || []).some(c => c.condition);
            const choicesWithTargets = (scene.choices || []).filter(c => c.action?.target);
            const isDeadEnd = choicesWithTargets.length === 0;
            
            if (scene.image) {
                scene.mediaType = App.assets.isVideo(scene.image) ? 'video' : 'image';
            } else if (scene.mediaType === 'image' || scene.mediaType === 'video') {
                scene.mediaType = 'none';
            }
            const mediaType = scene.mediaType || 'none';
            
            const nodeBodyStyle = scene.color ? `border-left: 5px solid ${scene.color}; padding-left: 7px;` : '';
            
            const placeholderIcon = mediaType === 'image' 
                ? `<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25z"></path></svg>` 
                : `<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M15.91 11.672a.375.375 0 010 .656l-5.603 3.113a.375.375 0 01-.557-.328V8.887c0-.286.307-.466.557-.327l5.603 3.112z"></path></svg>`;

            let thumbnailHTML = mediaType !== 'none' ? `<div class="node-thumbnail" data-thumbnail-for="${scene.id}">${scene.image ? '<span>Loading...</span>' : placeholderIcon}</div>` : '';

            let iconsHTML = `
                <div class="node-icons">
                    ${mediaType === 'image' ? `<span class="icon-group" title="Has Image">${App.sceneList.ICONS.image}</span>` : ''}
                    ${mediaType === 'video' ? `<span class="icon-group" title="Has Video">${App.sceneList.ICONS.video} ${scene.videoLoop ? App.sceneList.ICONS.videoLoop : ''}</span>` : ''}
                    ${hasSound ? `<span class="icon-group" title="Has Sound">${App.sceneList.ICONS.audio} ${scene.ambienceLoop ? App.sceneList.ICONS.audioLoop : ''}</span>` : ''}
                    ${hasConditions ? `<span title="Has Conditions">${App.sceneList.ICONS.condition}</span>` : ''}
                    ${isDeadEnd ? `<span title="Dead End">${App.sceneList.ICONS.end}</span>` : ''}
                </div>
                ${choicesWithTargets.length > 0 ? `<span class="choice-count-icon">${choicesWithTargets.length}</span>` : ''}
            `;

			nodeEl.innerHTML = `
				<div class="node-handle node-handle-top"></div>
				<div class="node-header media-${mediaType}">
					<span>${scene.id}</span>
					${isStart ? `<span title="Start Scene">${App.sceneList.ICONS.start}</span>` : ''}
				</div>
				<div class="node-body" style="${nodeBodyStyle}">
					${thumbnailHTML}
					<div class="node-text-display">${scene.text ? scene.text.substring(0, 150) + (scene.text.length > 150 ? '...' : '') : '...'}</div>
				</div>
				<div class="node-footer">${iconsHTML}</div>
				<div class="node-handle node-handle-bottom"></div>
			`;
            
            if (mediaType !== 'none' && scene.image) {
                const thumbDiv = nodeEl.querySelector('.node-thumbnail');
                try {
                    const url = mediaType === 'video' ? await App.assets.getVideoThumbnail(scene.image) : await App.io.getAssetDataUrl(scene.image);
                    if (url) {
                        thumbDiv.innerHTML = '';
                        const mediaEl = mediaType === 'video' ? document.createElement('canvas') : document.createElement('img');
                        if (mediaType === 'video') {
                            const img = new Image();
                            img.onload = () => { mediaEl.width = img.width; mediaEl.height = img.height; mediaEl.getContext('2d').drawImage(img, 0, 0); };
                            img.src = url;
                        } else {
                            mediaEl.src = url;
                        }
                        thumbDiv.appendChild(mediaEl);
                    } else {
                         thumbDiv.querySelector('span').textContent = 'Broken';
                    }
                } catch(e) {
                     thumbDiv.querySelector('span').textContent = 'Error';
                }
            }
            const hasConnections = scene.choices.some(c => c.action.target);
            if (!hasConnections) {
                nodeEl.querySelector('.node-handle-bottom').style.background = '#6c757d';
            }
			if (scenesWithInputs.has(scene.id)) {
				nodeEl.querySelector('.node-handle-top').classList.add('is-connected');
			}
			if (scenesWithOutputs.has(scene.id)) {
				nodeEl.querySelector('.node-handle-bottom').classList.add('is-connected');
			}
            return nodeEl;
        },

		renderEdges() {
			const svg = App.elements['node-svg-layer'];
			const container = App.elements['edge-group-container'];
			container.innerHTML = '';
			
			const scenes = App.state.storyData?.scenes;
			if (!scenes) return;

			const fragment = document.createDocumentFragment();
			
			const allConnections = [];
			for (const scene of Object.values(scenes)) {
				if (scene.choices) {
					scene.choices.forEach((choice, choiceIndex) => {
						const targetId = choice.action?.target;
						if (targetId && scenes[targetId]) {
							const targetScene = scenes[targetId];
							const sourceLevel = Math.round(scene.position.y / 450);
							const targetLevel = Math.round(targetScene.position.y / 450);
							
							if (targetLevel < sourceLevel) {
								 allConnections.push({ source: scene, target: targetScene, choice, choiceIndex, isLoopback: true });
								 return;
							}

							allConnections.push({
								source: scene,
								target: targetScene,
								choice,
								choiceIndex,
								isLoopback: false,
								start: Math.min(scene.position.x, targetScene.position.x),
								end: Math.max(scene.position.x, targetScene.position.x),
								sourceLevel,
								targetLevel
							});
						}
					});
				}
			}

			const lanesByChannel = []; 
			
			allConnections.sort((a, b) => (b.end - b.start) - (a.end - a.start));

			allConnections.forEach(conn => {
				if (conn.isLoopback) return;

				let laneIndex = 0;
				while (true) {
					let isLaneFree = true;
					for (let level = conn.sourceLevel; level < conn.targetLevel; level++) {
						if (!lanesByChannel[level]) lanesByChannel[level] = [];
						if (!lanesByChannel[level][laneIndex]) lanesByChannel[level][laneIndex] = [];

						const hasCollision = lanesByChannel[level][laneIndex].some(existingConn => {
							return Math.max(conn.start, existingConn.start) < Math.min(conn.end, existingConn.end);
						});

						if (hasCollision) {
							isLaneFree = false;
							break;
						}
					}

					if (isLaneFree) {
						conn.laneIndex = laneIndex;
						for (let level = conn.sourceLevel; level < conn.targetLevel; level++) {
							lanesByChannel[level][laneIndex].push(conn);
						}
						break;
					} else {
						laneIndex++; 
					}
				}
			});

			allConnections.forEach(conn => {
				const { source, target, choice, choiceIndex, laneIndex, isLoopback } = conn;
				const sourceEl = document.querySelector(`.node-editor-node[data-scene-id="${source.id}"]`);
				const targetEl = document.querySelector(`.node-editor-node[data-scene-id="${target.id}"]`);
				if (!sourceEl || !targetEl) return; 
				
				const isFiltered = sourceEl.classList.contains('is-filtered-out') || targetEl.classList.contains('is-filtered-out');
				const pathData = this.calculateEdgePath(source.position, target.position, sourceEl.offsetHeight, isLoopback ? 0 : laneIndex);

				const edgeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
				edgeGroup.classList.add('edge-group');
				edgeGroup.dataset.sourceId = source.id;
				edgeGroup.dataset.choiceIndex = choiceIndex;
				edgeGroup.addEventListener('dblclick', (e) => {
					e.stopPropagation();
					App.nodeEditor.editEdgeText(source.id, choiceIndex, e);
				});
				edgeGroup.addEventListener('click', (e) => {
					e.stopPropagation();
					App.ui.selectScene(source.id);
				});

				const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
				path.setAttribute('d', pathData.path);
				path.classList.add('edge-path');
				if (isLoopback || target.id === App.state.storyData.meta.startSceneId) { path.classList.add('edge-path-loopback'); }
				if (isFiltered) path.classList.add('is-filtered-out');
				path.setAttribute('marker-end', 'url(#arrowhead)');

				const hitbox = document.createElementNS('http://www.w3.org/2000/svg', 'path');
				hitbox.setAttribute('d', pathData.path);
				hitbox.classList.add('edge-hitbox');

				const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
				text.setAttribute('x', pathData.labelPos.x);
				text.setAttribute('y', pathData.labelPos.y);
				text.setAttribute('text-anchor', 'middle'); 
				text.setAttribute('dominant-baseline', 'middle');
				text.setAttribute('dy', '1px');
				text.textContent = choice.action.text || '...';
				text.classList.add('edge-label');

				svg.appendChild(text);
				const clientRect = text.getBoundingClientRect(); 
				const zoom = App.nodeEditor.state.zoom;
				const correctWidth = clientRect.width / zoom;    
				const correctHeight = clientRect.height / zoom;
				svg.removeChild(text);

				const textBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
				const paddingX = 4;
				const paddingY = 2;
				textBg.setAttribute('x', pathData.labelPos.x - (correctWidth / 2) - paddingX);
				textBg.setAttribute('y', pathData.labelPos.y - (correctHeight / 2) - paddingY);
				textBg.setAttribute('width', correctWidth + (paddingX * 2));
				textBg.setAttribute('height', correctHeight + (paddingY * 2));
				textBg.setAttribute('rx', 3);
				textBg.classList.add('edge-label-bg');

				edgeGroup.appendChild(hitbox);
				edgeGroup.appendChild(path);
				edgeGroup.appendChild(textBg);
				edgeGroup.appendChild(text);
				fragment.appendChild(edgeGroup);

			});
			container.appendChild(fragment);
		},
		
        updateEdgeSelection(selectedSceneId) {
            const container = App.elements['edge-group-container'];
            if (!container) return;

            const allEdges = Array.from(container.querySelectorAll('.edge-group'));

            allEdges.forEach(edge => edge.classList.remove('is-selected-path'));

            if (!selectedSceneId) return;

            const selectedEdges = [];
            allEdges.forEach(edge => {
                const sourceId = edge.dataset.sourceId;
                const choiceIndex = parseInt(edge.dataset.choiceIndex, 10);
                const choice = App.state.storyData.scenes[sourceId]?.choices[choiceIndex];
                const targetId = choice?.action?.target;

                if (sourceId === selectedSceneId || targetId === selectedSceneId) {
                    selectedEdges.push(edge);
                }
            });
            
            selectedEdges.forEach(edge => {
                edge.classList.add('is-selected-path');
                container.appendChild(edge);
            });
        },
		
        updateSelection() {
            document.querySelectorAll('.node-editor-node.selected').forEach(n => n.classList.remove('selected'));
            if (App.state.currentSceneId) {
                const activeNode = document.querySelector(`.node-editor-node[data-scene-id="${App.state.currentSceneId}"]`);
                if (activeNode) activeNode.classList.add('selected');
            }
            this.updateEdgeSelection(App.state.currentSceneId);
        },

        addNewScene(position = null, event = null) {
            let finalPosition = position;
        
            if (event && App.state.currentNavView === 'nodes') {
                const viewRect = App.elements['node-editor-view'].getBoundingClientRect();
                const mouseX = event.clientX - viewRect.left;
                const mouseY = event.clientY - viewRect.top;
                finalPosition = {
                    x: (mouseX - this.state.pan.x) / this.state.zoom,
                    y: (mouseY - this.state.pan.y) / this.state.zoom
                };
            } else if (!finalPosition) {
                const sceneCount = Object.keys(App.state.storyData.scenes).length;
                finalPosition = { x: 100 + (sceneCount % 5) * 50, y: 100 + Math.floor(sceneCount / 5) * 50 };
            }

            App.ui.showCustomPrompt({
                text: "Enter a unique ID for the new scene:",
                value: `scene_${Object.keys(App.state.storyData.scenes).length + 1}`,
                event: event,
                callback: (newId) => {
                    if (!newId) return;
                    newId = newId.trim().replace(/\s+/g, '_');
                    if (!newId.length || App.state.storyData.scenes[newId] || App.state.storyData.meta.variables.includes(newId)) {
                        App.ui.showNotification("This name is already in use by a scene or variable.");
                        return;
                    }

                    const newScene = { id: newId, text: `This is the new scene '${newId}'.`, choices: [], position: finalPosition, lastModified: Date.now(), mediaType: 'none', color: null };
                    App.state.storyData.scenes[newId] = newScene;
                    App.setDirty(true);
                    App.ui.invalidateNavViews();
                    App.ui.renderCurrentView().then(() => { App.ui.selectScene(newId); });
                }
            });
        },

		autoArrange() {
			const scenes = App.state.storyData.scenes;
			const startId = App.state.storyData.meta.startSceneId;
			if (!scenes || !startId) return;

			const HORIZONTAL_GAP = 600;
			const VERTICAL_GAP = 500;
			const STAGGER_AMOUNT = 30;
			const graph = {};
			const sceneIds = Object.keys(scenes);

			sceneIds.forEach(id => {
				graph[id] = { children: new Set(), parents: new Set(), level: -1 };
			});
			sceneIds.forEach(id => {
				(scenes[id].choices || []).forEach(choice => {
					const targetId = choice.action.target;
					if (targetId && graph[targetId]) {
						graph[id].children.add(targetId);
						graph[targetId].parents.add(id);
					}
				});
			});

			const levels = [];
			const queue = [startId];
			const visited = new Set([startId]);
			graph[startId].level = 0;
			let head = 0;
			while (head < queue.length) {
				const u = queue[head++];
				if (!levels[graph[u].level]) levels[graph[u].level] = [];
				levels[graph[u].level].push(u);
				graph[u].children.forEach(v => {
					if (!visited.has(v)) {
						visited.add(v);
						graph[v].level = graph[u].level + 1;
						queue.push(v);
					}
				});
			}

			for (let i = 1; i < levels.length; i++) {
				levels[i].sort((a, b) => {
					const getParentAvgIndex = (nodeId) => {
						const parents = Array.from(graph[nodeId].parents);
						if (parents.length === 0) return -1;
						const sum = parents.reduce((acc, parentId) => acc + (levels[i - 1].indexOf(parentId) || 0), 0);
						return sum / parents.length;
					};
					return getParentAvgIndex(a) - getParentAvgIndex(b);
				});
			}

			const orphans = sceneIds.filter(id => !visited.has(id));
			if (orphans.length > 0) {
				levels.push(orphans);
			}

			const staggerMap = new Map();
			levels.forEach((levelNodes, levelIndex) => {
				levelNodes.forEach(parentId => {
					const childrenInNextLevel = Array.from(graph[parentId].children)
						.filter(childId => graph[childId].level === levelIndex + 1)
						.sort((a, b) => levels[levelIndex + 1].indexOf(a) - levels[levelIndex + 1].indexOf(b));

					childrenInNextLevel.forEach((childId, staggerIndex) => {
						staggerMap.set(childId, staggerIndex);
					});
				});
			});

			let levelMaxY = -VERTICAL_GAP; 

			levels.forEach((levelNodes, levelIndex) => {
				const levelWidth = (levelNodes.length - 1) * HORIZONTAL_GAP;
				const startX = -levelWidth / 2;
				
				const baseY = levelMaxY + VERTICAL_GAP;
				let currentLevelMaxY = baseY;

				levelNodes.forEach((nodeId, index) => {
					if (scenes[nodeId]) {
						const staggerIndex = staggerMap.get(nodeId) || 0;
						const nodeY = baseY + (staggerIndex * STAGGER_AMOUNT);

						scenes[nodeId].position = {
							x: startX + index * HORIZONTAL_GAP,
							y: nodeY
						};
						if (nodeY > currentLevelMaxY) {
							currentLevelMaxY = nodeY;
						}
					}
				});
				levelMaxY = currentLevelMaxY;
			});

			App.setDirty(true);
			this.render();
			this.fitView();
		},

		calculateEdgePath(sourcePos, targetPos, sourceHeight, laneIndex = 0) {
			const NODE_WIDTH = 240;
			const BEND_OFFSET = 70;      
			const LANE_HEIGHT = 35;      
			const TEXT_OFFSET_Y = 5; 
			const TEXT_OFFSET_X = 10;
			const LOOPBACK_SIDE_OFFSET = 120;
			const ARC_HEIGHT_ABOVE = 40;

			const startX = sourcePos.x + NODE_WIDTH / 2;
			const startY = sourcePos.y + sourceHeight;
			const endX = targetPos.x + NODE_WIDTH / 2;
			const endY = targetPos.y;

			let path, labelPos;

			if (endY < startY) {
				const sideX = Math.max(startX, endX) + LOOPBACK_SIDE_OFFSET;
				const topY = endY - ARC_HEIGHT_ABOVE;
				
				path = `M ${startX},${startY} V ${startY + 20} H ${sideX} V ${topY} H ${endX} V ${endY}`;
				
				labelPos = { x: sideX + TEXT_OFFSET_X, y: (startY + topY) / 2, anchor: 'start' };

			} else {
				const horizontalLineY = startY + BEND_OFFSET + (laneIndex * LANE_HEIGHT);
				path = `M ${startX} ${startY} V ${horizontalLineY} H ${endX} V ${endY}`;
				
				const textAnchor = (endX > startX) ? 'start' : 'end';
				const textX = startX + (Math.sign(endX - startX) * TEXT_OFFSET_X);
				labelPos = { x: textX, y: horizontalLineY - TEXT_OFFSET_Y, anchor: textAnchor };
			}

			return { path, labelPos };
		},

        findNextOrphan() {
            const orphans = Array.from(App.state.orphanSceneIds);
            if (orphans.length === 0) {
                App.ui.showNotification("No orphan scenes found.");
                this.state.orphanIndex = -1;
                return;
            }
            this.state.orphanIndex = (this.state.orphanIndex + 1) % orphans.length;
            const orphanId = orphans[this.state.orphanIndex];
            App.ui.selectScene(orphanId);
            this.centerOnNode(orphanId);
        },

        centerOnNode(sceneId) {
            const scene = App.state.storyData.scenes[sceneId];
            if (!scene?.position) return;
            const viewRect = App.elements['node-editor-view'].getBoundingClientRect();
            const nodeWidth = 240;
            const nodeHeight = 200;

            this.state.pan.x = -scene.position.x * this.state.zoom + (viewRect.width / 2) - (nodeWidth / 2 * this.state.zoom);
            this.state.pan.y = -scene.position.y * this.state.zoom + (viewRect.height / 2) - (nodeHeight / 2 * this.state.zoom);

            this.updateTransform();
        },
        
        showContextMenu(event, menu) {
            const sceneId = App.state.contextSceneId;
            const edgeData = this.state.edgeContextMenuData;
            let itemsHTML = '';

            const createButton = (label, action) => `<button onclick="${action}; App.nodeEditor.hideContextMenu(); event.stopPropagation();">${label}</button>`;
            const createSubmenu = (label, subItems) => `<div class="submenu">${createButton(label, 'void(0)')}<div class="submenu-content">${subItems}</div></div>`;

            if (edgeData) {
                itemsHTML += createButton('Delete Connection', `App.nodeEditor.deleteEdge()`);
            } else if (sceneId) { 
                itemsHTML += createButton('Set as Start Scene', `App.tree.setAsStartScene()`);
                itemsHTML += createButton('Duplicate Scene', `App.nodeEditor.cloneScene('${sceneId}')`);
                itemsHTML += '<hr>';
                const colorSubmenu = 
                    createButton('Blue', `App.nodeEditor.setNodeColor('${sceneId}', 'var(--color-tag-blue)')`) +
                    createButton('Green', `App.nodeEditor.setNodeColor('${sceneId}', 'var(--color-tag-green)')`) +
                    createButton('Orange', `App.nodeEditor.setNodeColor('${sceneId}', 'var(--color-tag-orange)')`) +
                    '<hr>' +
                    createButton('Clear Color', `App.nodeEditor.setNodeColor('${sceneId}', null)`);
                itemsHTML += createSubmenu('Set Color Tag', colorSubmenu);
                itemsHTML += '<hr>';
                itemsHTML += createButton('Delete Scene', `App.tree.deleteCurrentScene(true)`);
            } else { 
                itemsHTML += createButton('Add New Scene Here', `App.nodeEditor.addNewScene(App.nodeEditor.state.contextMenuPos, event)`);
                itemsHTML += '<hr>';
                itemsHTML += createButton('Auto-Arrange All', 'App.nodeEditor.autoArrange()');
                itemsHTML += createButton('Find Orphan Scenes', 'App.nodeEditor.findNextOrphan()');
            }
            
            menu.innerHTML = itemsHTML;
            menu.style.display = 'block';
            menu.style.left = `${event.clientX}px`;
            menu.style.top = `${event.clientY}px`;
        },

        hideContextMenu() {
            const menu = App.elements['editor-context-menu'];
            if(menu) menu.style.display = 'none';
        },

cloneScene(sceneId) {
            const originalScene = App.state.storyData.scenes[sceneId];
            if (!originalScene) return;
            const newId = prompt("Enter a unique ID for the new duplicated scene:", `${sceneId}_copy`);
            if (!newId) return;
            if (App.state.storyData.scenes[newId]) { App.ui.showNotification("Scene ID already exists."); return; }
            
            const newScene = JSON.parse(JSON.stringify(originalScene));
            newScene.id = newId;
            newScene.position = { x: originalScene.position.x + 40, y: originalScene.position.y + 40 };
            newScene.choices = []; 

            App.state.storyData.scenes[newId] = newScene;
            App.setDirty(true);
            App.ui.invalidateNavViews();
            App.ui.renderCurrentView();
        },

        setMediaType(sceneId, mediaType) {
            const scene = App.state.storyData.scenes[sceneId];
            if(scene) {
                scene.mediaType = mediaType;
                if(mediaType === 'none' && scene.image) scene.image = '';
                App.setDirty(true);
                App.ui.invalidateNavViews();
                App.ui.renderCurrentView();
                if(sceneId === App.state.currentSceneId) App.editor.render();
            }
        },

        setNodeColor(sceneId, color) {
            const scene = App.state.storyData.scenes[sceneId];
            if(scene) {
                scene.color = color;
                App.setDirty(true);
                App.ui.invalidateNavViews();
                App.ui.renderCurrentView();
            }
        },

        deleteEdge() {
            const { sourceId, choiceIndex } = this.state.edgeContextMenuData;
            if (sourceId && choiceIndex !== undefined) {
                const scene = App.state.storyData.scenes[sourceId];
                if (scene && scene.choices && scene.choices[choiceIndex]) {
                    scene.choices.splice(choiceIndex, 1);
                    App.setDirty(true);
                    this.renderEdges();
                    App.ui.invalidateNavViews();
                    App.ui.renderCurrentView();
                    if(sourceId === App.state.currentSceneId) App.editor.render();
                }
            }
        },

		editEdgeText(sourceSceneId, choiceIndex, event) {
            const existingEditor = document.getElementById('edge-text-editor');
            if (existingEditor) existingEditor.remove();

            const choice = App.state.storyData.scenes[sourceSceneId].choices[choiceIndex];
            const currentText = choice.action.text;

            const input = document.createElement('input');
            input.id = 'edge-text-editor';
            input.type = 'text';
            input.value = currentText;
            
            const viewRect = App.elements['node-editor-view'].getBoundingClientRect();
            input.style.left = `${event.clientX - viewRect.left}px`;
            input.style.top = `${event.clientY - viewRect.top}px`;
            input.style.transform = 'translate(-50%, -50%)';

            App.elements['node-editor-view'].appendChild(input);
            input.focus();
            input.select();

            const saveAndClose = () => {
                if (!document.body.contains(input)) {
                    return;
                }

                choice.action.text = input.value;
                App.setDirty(true);
                this.renderEdges(); 

                if (sourceSceneId === App.state.currentSceneId) {
                    App.editor.render();
                }
                
                input.remove();
            };

            const cancelAndClose = () => {
                if (input.parentElement) {
                    input.remove();
                }
            };

            input.addEventListener('blur', saveAndClose);

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur(); 
                } else if (e.key === 'Escape') {
                    cancelAndClose();
                }
            });
        },
        
        editNodeText(nodeEl) {
            const sceneId = nodeEl.dataset.sceneId;
            App.ui.selectScene(sceneId);
            setTimeout(() => {
                const sceneTextEl = document.getElementById('scene-text');
                sceneTextEl.focus();
                sceneTextEl.select();
            }, 50); 
        },

        zoom(factor, mouseX = null, mouseY = null) {
            const viewRect = App.elements['node-editor-view'].getBoundingClientRect();
            if (mouseX === null) mouseX = viewRect.left + viewRect.width / 2;
            if (mouseY === null) mouseY = viewRect.top + viewRect.height / 2;

            const pointerX = mouseX - viewRect.left;
            const pointerY = mouseY - viewRect.top;

            const oldZoom = this.state.zoom;
            const newZoom = Math.max(0.2, Math.min(2.5, oldZoom * factor));
            
            this.state.pan.x = pointerX - (pointerX - this.state.pan.x) * (newZoom / oldZoom);
            this.state.pan.y = pointerY - (pointerY - this.state.pan.y) * (newZoom / oldZoom);
            this.state.zoom = newZoom;

            this.updateTransform();
        },

        fitView() {
            const scenes = App.state.storyData.scenes;
            if (Object.keys(scenes).length === 0) return;

            const viewRect = App.elements['node-editor-view'].getBoundingClientRect();
            const PADDING = 50;
            const NODE_WIDTH = 240, NODE_HEIGHT = 220;

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            Object.values(scenes).forEach(s => {
                minX = Math.min(minX, s.position.x);
                minY = Math.min(minY, s.position.y);
                maxX = Math.max(maxX, s.position.x);
                maxY = Math.max(maxY, s.position.y);
            });

            const contentWidth = (maxX - minX) + NODE_WIDTH;
            const contentHeight = (maxY - minY) + NODE_HEIGHT;
            
            const zoomX = (viewRect.width - 2 * PADDING) / contentWidth;
            const zoomY = (viewRect.height - 2 * PADDING) / contentHeight;
            this.state.zoom = Math.min(zoomX, zoomY, 1.5);

            this.state.pan.x = -minX * this.state.zoom + (viewRect.width - contentWidth * this.state.zoom) / 2;
            this.state.pan.y = -minY * this.state.zoom + (viewRect.height - contentHeight * this.state.zoom) / 2;

            this.updateTransform();
        },

        calculateEdgePath(sourcePos, targetPos, sourceHeight) {
            const NODE_WIDTH = 240;
            const BEND_OFFSET = 50;

            const startX = sourcePos.x + NODE_WIDTH / 2;
            const startY = sourcePos.y + sourceHeight;
            const endX = targetPos.x + NODE_WIDTH / 2;
            const endY = targetPos.y;

            const midY = startY + BEND_OFFSET;

            let path, labelPos;

            if (Math.abs(startX - endX) < NODE_WIDTH / 2 && endY > startY) {
                path = `M ${startX} ${startY} L ${endX} ${endY}`;
                labelPos = { x: (startX + endX) / 2, y: (startY + endY) / 2 };
            } else { 
                path = `M ${startX} ${startY} V ${midY} H ${endX} V ${endY}`;
                labelPos = { x: (startX + endX) / 2, y: midY };
            }

            return { path, labelPos };
        }
		
		
    },

    debug: {
        init: function() {
            const originalConsole = {
                log: console.log.bind(console),
                warn: console.warn.bind(console),
                error: console.error.bind(console),
            };

            const override = (method, level) => {
                console[method] = (...args) => {
                    originalConsole[method](...args);
                    if (App.state.debugMode) {
                        const message = args.map(arg => {
                            try {
                                return typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg);
                            } catch (e) {
                                return `[Unserializable Object]`;
                            }
                        }).join(' ');
                        this.log(`[CONSOLE] ${message}`, level);
                    }
                };
            };

            override('log', 'INFO');
            override('warn', 'WARN');
            override('error', 'ERROR');

            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.altKey && e.key.toLowerCase() === 'd') {
                    e.preventDefault();
                    this.toggle();
                }
            });

            if(App.elements['copy-debug-log-btn']) {
                 App.elements['copy-debug-log-btn'].addEventListener('click', this.copyLog);
            }
        },

        toggle: function() {
            App.state.debugMode = !App.state.debugMode;
            App.ui.showNotification(`Debug Mode ${App.state.debugMode ? 'Enabled' : 'Disabled'}.`);
            console.log(`Debug mode toggled ${App.state.debugMode ? 'ON' : 'OFF'}.`);
        },

        log: function(message, level) {
            const currentLevel = level || 'INFO';
            const logEl = App.elements['debug-log'];
            if (!logEl) return;

            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
            const logEntry = document.createElement('span');
            logEntry.textContent = `[${timestamp}] [${currentLevel}] ${message}\n`;

            switch(currentLevel.toUpperCase()) {
                case 'ERROR': logEntry.style.color = '#ff8a8a'; break;
                case 'WARN': logEntry.style.color = '#ffd180'; break;
                case 'SUCCESS': logEntry.style.color = '#b9f6ca'; break;
                case 'INFO':
                default: logEntry.style.color = '#80d8ff'; break;
            }

            logEl.appendChild(logEntry);
            logEl.scrollTop = logEl.scrollHeight;
        },

        clear: function() {
            const logEl = App.elements['debug-log'];
            if (logEl) logEl.textContent = '';
        },

        copyLog: function() {
            const logEl = App.elements['debug-log'];
            if (navigator.clipboard) {
                navigator.clipboard.writeText(logEl.innerText).then(() => {
                    App.ui.showNotification('Debug log copied to clipboard.');
                }).catch(err => {
                    console.error('Failed to copy log:', err);
                    App.ui.showNotification('Failed to copy log.');
                });
            }
        },

        yieldToMain: function() {
            return new Promise(resolve => {
                setTimeout(resolve, 0);
            });
        }
    }
};

document.addEventListener('DOMContentLoaded', () => App.init());
</script>
</body>
</html>
