<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kinexus</title>
    <style>
        :root {
            --primary-color: #4a78ad; --secondary-color: #6c757d; --light-bg: #121212;
            --dark-text: #e0e0e0; --border-color: #333333; --success-color: #5a8f66;
            --danger-color: #b85a66; --warning-color: #c7921a; --warning-text: #ffffff;
            --purple-color: #8e63a9;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; display: flex; height: 100vh; margin: 0; background-color: var(--light-bg); color: var(--dark-text); font-size: 16px; }
        ::-webkit-scrollbar { width: 12px; height: 12px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background-color: #444; border-radius: 6px; border: 2px solid #1e1e1e; }
        ::-webkit-scrollbar-thumb:hover { background-color: #555; }
        html { scrollbar-color: #444 #1e1e1e; }

        #tree-view-container { 
            width: 350px; 
            min-width: 250px;
            max-width: 800px;
            background-color: #1e1e1e; 
            border-right: 1px solid var(--border-color); 
            padding: 15px; 
            display: flex; 
            flex-direction: column; 
            resize: horizontal;
            overflow: hidden;
        }
        #editor-container { flex-grow: 1; padding: 0 20px 20px; overflow-y: auto; background-color: var(--light-bg); }
        #editor-container fieldset { border: none; padding: 0; margin: 0; }
        #editor-container fieldset:disabled { opacity: 0.5; pointer-events: none; }
        #player-container { display: none; flex-grow: 1; overflow-y: auto; position: relative; justify-content: center; align-items: center; }
        #player-container.layout-image-as-bg {
            align-items: flex-end;
            padding: 20px;
            box-sizing: border-box;
        }

        h1, h2, h3 { border-bottom: 2px solid var(--primary-color); padding-bottom: 5px; margin-top: 0; }
        #editor-container h1 { margin-top: 20px; }
        .header { display: flex; justify-content: space-between; align-items: center; }
        .header h1 { white-space: nowrap; }
        .header h2 { margin-bottom: 0; }
        .header h3 { border-bottom: none; }
        #main-title-dirty-indicator { color: var(--danger-color); font-size: 0.7em; margin-left: 5px; display: none; }
        
        hr { border: none; border-top: 1px solid var(--border-color); margin: 15px 0; }
        #tree-view, #scene-list-view { list-style-type: none; padding-left: 0; flex-grow: 1; overflow: auto; min-height: 100px; margin-top: 10px; }
        #tree-view > ul { display: table; width: 100%; list-style-type: none; padding-left: 0; }
        #tree-view ul ul { list-style-type: none; padding-left: 20px; border-left: 1px solid #444; }
        #tree-view li { margin-top: 5px; color: var(--dark-text); }
        .scene-node { 
            cursor: pointer; 
            padding: 5px 8px; 
            border-radius: 4px; 
            display: flex; 
            align-items: center; 
            gap: 6px; 
            width: 100%; 
            box-sizing: border-box; 
        }
        .scene-node:hover { background-color: #333333; }
        .scene-node.active { background-color: var(--primary-color); color: white; font-weight: bold; }
        .scene-node-text { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .scene-node-icons { display: flex; gap: 4px; align-items: center; }
        .scene-node-icons .icon-orphan {
            order: -1; /* Place orphan icon first */
        }
        .scene-node-icons svg, .scene-card-icon { 
            width: 16px; height: 16px; flex-shrink: 0; 
            fill: currentColor; 
            display: inline-block;
            vertical-align: middle;
        }
        .icon-start { color: var(--success-color); }
        .icon-image { color: #8ab4f8; }
        .icon-sound { color: #fdd663; }
        .icon-deadend { color: var(--danger-color); }
        .icon-orphan { color: var(--danger-color); }
        .scene-node.active .scene-node-icons { color: white; }
        .choice-node { 
            list-style-type: none; 
            position: relative; 
            padding: 3px 0 3px 25px; 
            color: var(--choice-color, #a0a0a0);
            font-style: normal;
            font-size: 0.9em; 
        }
        .choice-node::before { 
            content: ''; 
            position: absolute; 
            top: -10px; 
            left: 5px; 
            width: 15px; 
            height: 18px; 
            border-bottom: 1px solid var(--choice-color, #444);
            border-left: 1px solid var(--choice-color, #444);
            border-radius: 0 0 0 5px; 
        }
        .choice-node-text { white-space: nowrap; }
        .tree-toggle { font-family: monospace; width: 20px; text-align: center; border-radius: 4px; background: #333333; -webkit-user-select: none; user-select: none; color: var(--dark-text); flex-shrink: 0; }
        .scene-node.active .tree-toggle { background: #ffffff; color: var(--primary-color); }
        .tree-toggle.empty { opacity: 0; cursor: default; }

        /* Scene List View Styles */
        #scene-list-view {
            margin-top: 0; /* Wrapper handles spacing */
        }
        #scene-list-controls {
            display: flex;
            justify-content: flex-end; /* Moved to right */
            align-items: center;
            gap: 10px;
            margin-top: 10px; /* Spacing between list and controls */
            flex-shrink: 0; /* Prevent controls from shrinking */
        }
        #scene-list-sort {
            background-color: #1e1e1e;
            color: var(--dark-text);
            border: 1px solid #444;
            border-radius: 4px;
            padding: 5px 8px;
            font-size: 0.9em;
        }
        .scene-list-group-header {
            font-size: 0.8em;
            text-transform: uppercase;
            color: #888;
            margin: 15px 0 5px 5px;
            font-weight: bold;
        }
        .scene-card {
            display: flex;
            gap: 12px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: border-color 0.2s, background-color 0.2s;
        }
        .scene-card:hover {
            background-color: #2a2a2a;
            border-color: #555;
        }
        .scene-card.active {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }
        .scene-card-thumbnail {
            width: 96px; /* 16:9 ratio */
            height: 54px;
            flex-shrink: 0;
            background-color: #111;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.7em;
            color: var(--secondary-color);
            overflow: hidden;
            border: 1px solid #444;
        }
        .scene-card.active .scene-card-thumbnail {
            border-color: rgba(255,255,255,0.5);
        }
        .scene-card-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .scene-card-content {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex-grow: 1;
            overflow: hidden; /* Important for ellipsis */
        }
        .scene-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .scene-card-id {
            font-weight: bold;
            font-size: 1.1em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .scene-card.active .scene-card-id {
            color: white;
        }
        .scene-card-icons {
            display: flex;
            gap: 8px;
            align-items: center;
            font-size: 0.9em;
        }
        .scene-card-icons .icon-orphan {
             order: -1; /* Place orphan icon first */
        }
        .scene-card-icon-group {
            display: flex;
            align-items: center;
            gap: 3px;
        }
        .choice-count-icon {
            background-color: var(--secondary-color);
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            font-size: 11px;
            font-weight: bold;
            line-height: 1;
            flex-shrink: 0;
        }
        .scene-card.active .choice-count-icon {
            background-color: rgba(255, 255, 255, 0.3);
        }
        .scene-card.active .scene-card-icons {
            color: #e0e0e0;
        }
        .scene-card.active .icon-orphan,
        .scene-card.active .icon-deadend {
             color: white;
             background-color: rgba(0,0,0,0.2);
             border-radius: 3px;
             padding: 1px;
        }
        .scene-card-text {
            font-size: 0.85em;
            color: #aaa;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .scene-card.active .scene-card-text {
            color: #ddd;
        }

        /* View Toggler Styles */
        #view-mode-toggle {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        #view-mode-toggle button {
            flex-grow: 1;
            background-color: var(--secondary-color);
            opacity: 0.6;
        }
        #view-mode-toggle button.active {
            background-color: var(--primary-color);
            opacity: 1;
        }
        
        button { padding: 10px 15px; background-color: var(--primary-color); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em; transition: background-color 0.2s; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
        .form-group.inline button { margin-top: 0; }
        button:disabled { background-color: var(--secondary-color); cursor: not-allowed; }
        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; }
        .btn-group button { margin-top: 0; }
        .btn-success { background-color: var(--success-color); }
        .btn-success.dirty { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(90, 143, 102, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(90, 143, 102, 0); } 100% { box-shadow: 0 0 0 0 rgba(90, 143, 102, 0); } }
        .btn-warning { background-color: var(--warning-color); color: var(--warning-text); }
        .btn-danger { background-color: var(--danger-color); }
        .btn-secondary { background-color: var(--secondary-color); }
        .btn-purple { background-color: var(--purple-color); }
        .file-icon-btn { padding: 8px; min-width: 40px; }
        .btn-round { border-radius: 50%; width: 30px; height: 30px; padding: 0; font-size: 1.2em; line-height: 30px; flex-shrink: 0; }
        #image-file-input, #sound-file-input { display: none; }
        
        .form-group { margin-bottom: 20px; }
        .form-group.choice-group { margin-bottom: 8px; }
        .form-group.inline { display: flex; align-items: center; gap: 10px; }
        .form-group.inline input, .form-group.inline select { flex-grow: 1; }
        .form-group label.checkbox-label { display: flex; align-items: center; gap: 8px; font-weight: normal; }
        .form-group label.checkbox-label input { width: auto; flex-grow: 0; }
        label { display: block; font-weight: bold; margin-bottom: 5px; }
        input[type="text"], input[type="search"], input[type="number"], textarea, select { width: 100%; box-sizing: border-box; padding: 10px; border: 1px solid #444444; border-radius: 4px; font-size: 1em; background-color: #1e1e1e; color: var(--dark-text); }
        input[type="text"]:disabled { background-color: #333333; cursor: not-allowed; }
        textarea { height: 120px; resize: vertical; }
       
        input.drag-over {
            border: 2px dashed var(--primary-color) !important;
            box-shadow: 0 0 10px var(--primary-color);
        }

        #media-hub { display: flex; gap: 15px; align-items: center; }
        #media-paths-container { flex-grow: 1; display: flex; flex-direction: column; gap: 10px; }
        #media-paths-container .form-group.inline { margin: 0; }
        #media-paths-container .media-icon-label {
            margin-bottom: 0;
            flex-shrink: 0;
            width: 24px;
            height: 24px;
            color: var(--secondary-color);
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        #scene-editor-preview-wrapper {
            position: relative;
            width: 100%;
            max-width: 720px;
            margin: 0 auto 25px auto;
            aspect-ratio: 16 / 9;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            background-color: #000;
        }
        #scene-editor-preview {
            position: absolute;
            top: 0;
            left: 0;
            width: 200%;
            height: 200%;
            transform: scale(0.5);
            transform-origin: top left;
            overflow: auto;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            font-size: var(--font-size);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #scene-editor-preview.layout-image-as-bg { align-items: flex-end; }
        #scene-editor-preview, #scene-editor-preview #preview-player-inner-container {
             background-size: cover; background-position: center;
        }
        #scene-editor-preview #preview-player-inner-container {
             width: 100%;
             max-width: 800px;
             margin: 20px;
             box-shadow: 0 5px 20px rgba(0,0,0,.5);
             gap: 20px;
             padding: var(--padding);
             border-radius: 12px;
             box-sizing: border-box;
             background-color: var(--container-bg-color);
             display: flex;
        }
        #scene-editor-preview .choice-btn {
            padding: 15px 20px;
            pointer-events: none;
            background-color: var(--btn-color);
            color: var(--btn-text-color);
            border: 1px solid var(--btn-color);
            text-align: left;
            border-radius: 6px;
            font-size: 1em;
        }
        #scene-editor-preview #preview-player-image {
            max-width: 100%;
            max-height: 50vh;
            display: block;
            margin: 0 auto;
            border-radius: 8px;
            object-fit: cover;
        }
        #scene-editor-preview #preview-player-text {
            white-space: pre-wrap;
            margin-bottom: 20px;
        }
        #scene-editor-preview #preview-player-choices {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .layout-top-down { flex-direction: column; } .layout-top-down #player-image-container, .layout-top-down #preview-player-image-container { width: 100%; margin-bottom: 20px; } .layout-top-down #player-image, .layout-top-down #preview-player-image { width: 100%; height: auto; }
        .layout-side-by-side { flex-direction: row; align-items: flex-start; } .layout-side-by-side #player-image-container, .layout-side-by-side #preview-player-image-container { width: 40%; flex-shrink: 0; } .layout-side-by-side #player-content-container, .layout-side-by-side #preview-player-content-container { width: 60%; }
        .layout-image-as-bg #player-image-container, .layout-image-as-bg #preview-player-image-container { display: none !important; }
        .layout-image-as-bg #player-content-container, .layout-image-as-bg #preview-player-content-container { width: 100%; }

        #ai-image-generator { display: flex; gap: 10px; align-items: center; margin-top: 5px; }
        #ai-image-preview { width: 150px; height: 150px; background-color: #1e1e1e; border: 1px dashed var(--border-color); display: flex; justify-content: center; align-items: center; font-size: 0.8em; color: var(--secondary-color); text-align: center; flex-shrink: 0; position: relative; }
        #ai-image-preview img { max-width: 100%; max-height: 100%; object-fit: contain; }
        #ai-image-controls { display: flex; gap: 10px; align-items: center; flex-grow: 1; }
        .modal { display: none; opacity: 0; visibility: hidden; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); justify-content: center; align-items: center; transition: opacity 0.2s, visibility 0.2s; }
        .modal.visible { display: flex; opacity: 1; visibility: visible; }
        .modal-content { position: relative; background-color: #1e1e1e; padding: 20px; border-radius: 8px; width: 80%; max-width: 600px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); color: var(--dark-text); }
        .modal-close { position: absolute; top: 10px; right: 15px; font-size: 1.5em; font-weight: bold; cursor: pointer; color: #aaaaaa; }
        .modal-close:hover { color: #ffffff; }
        .modal-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
        .modal-grid label { display: flex; flex-direction: column; }
        .modal-grid .grid-span-2 { grid-column: 1 / -1; display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .modal-grid .grid-full-width { grid-column: 1 / -1; }
        .modal-grid .grid-separator { grid-column: 1 / -1; margin: 5px 0; border: none; border-top: 1px solid var(--border-color); }
        input[type="color"] { width: 100%; height: 40px; padding: 0; border: 1px solid #444444; cursor: pointer; background-color: transparent; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; }
        
        #style-editor-modal.visible,
        #batch-image-modal.visible {
            background-color: transparent;
            pointer-events: none;
            justify-content: flex-start; 
            align-items: flex-start;
        }
        #style-editor-modal .modal-content,
        #batch-image-modal .modal-content {
            pointer-events: auto;
            margin: 0;
            border-radius: 0;
            max-height: none;
            max-width: none;
            overflow-y: auto;
            border-right: 1px solid var(--border-color);
            position: absolute;
            box-sizing: border-box;
            resize: horizontal;
            overflow: auto;
        }
        #batch-image-modal .modal-content {
            display: flex;
            flex-direction: column;
        }

        #tree-context-menu { display: none; position: absolute; background-color: #1e1e1e; border: 1px solid #333333; box-shadow: 2px 2px 5px rgba(0,0,0,0.2); border-radius: 4px; padding: 5px 0; z-index: 1001; }
        #tree-context-menu button { width: 100%; text-align: left; background: none; color: var(--dark-text); margin: 0; padding: 8px 15px; border-radius: 0; }
        #tree-context-menu button:hover { background-color: var(--primary-color); color: white; }
        #player-container { background-size: cover; background-position: center; background-color: var(--bg-color); color: var(--text-color); font-family: var(--font-family); font-size: var(--font-size); }
        #player-inner-container { width: 100%; max-width: 800px; padding: var(--padding); border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.5); display:flex; gap: 20px; margin: 20px; background-size: cover; background-position: center; background-color: var(--container-bg-color);}
        #player-image { max-width: 100%; max-height: 50vh; display: block; margin: 0 auto; border-radius: 8px; object-fit: cover; }
        #player-text { white-space: pre-wrap; margin-bottom: 20px; }
        #player-choices { display: flex; flex-direction: column; gap: 12px; }
        #player-choices .choice-btn { width: 100%; text-align: left; padding: 15px 20px; border-radius: 6px; cursor: pointer; font-size: 1em; transition: background-color .2s, transform .1s, border-color .2s; background-color: var(--btn-color); color: var(--btn-text-color); border: 1px solid transparent; }
        #player-choices .choice-btn:hover { transform: translateY(-2px); background-color: var(--btn-hover-color); }
        #player-choices .choice-btn:active { transform: translateY(1px); }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        #player-choices .choice-btn.fade-in { animation: fadeIn 0.5s forwards; opacity: 0; }

        #stop-play-x { position: absolute; top: 10px; right: 10px; background: var(--danger-color); color: white; border: none; font-size: 1.5em; padding: 5px 10px; cursor: pointer; z-index: 10; }
        #restart-play { position: absolute; top: 10px; right: 60px; z-index: 10; }
        #image-preview { width: 150px; height: 150px; background-color: #1e1e1e; border: 1px dashed var(--border-color); display: flex; justify-content: center; align-items: center; font-size: 0.8em; color: var(--secondary-color); text-align: center; flex-shrink: 0; position: relative; }
        #image-preview img { max-width: 100%; max-height: 100%; object-fit: contain; }
        #fullscreen-viewer { flex-direction: column; }
        #fullscreen-image { max-width: 90vw; max-height: 80vh; object-fit: contain; }
        #fullscreen-minimize { margin-top: 15px; }
        .thumbnail-fullscreen-icon {
            position: absolute;
            bottom: 4px; right: 4px; width: 24px; height: 24px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white; border-radius: 4px;
            cursor: pointer; display: flex; justify-content: center; align-items: center;
            opacity: 0; transition: opacity 0.2s;
        }
        #image-preview:hover .thumbnail-fullscreen-icon,
        #ai-image-preview:hover .thumbnail-fullscreen-icon { opacity: 1; }
        .thumbnail-fullscreen-icon svg { width: 16px; height: 16px; }
        .play-pause-icon.hidden { display: none; }
        
        #style-editor-grid #style-font-size,
        #style-editor-grid #style-padding {
            background-color: #1E1E1E;
            color: white;
            border: 1px solid #444444;
            border-radius: 4px;
            height: 40px;
            box-sizing: border-box;
        }
        
        #toggle-loop-btn.active {
            background-color: var(--primary-color);
        }

        #custom-tooltip {
            display: none;
            position: fixed;
            z-index: 9999;
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 14px;
            max-width: 350px;
            word-wrap: break-word;
            white-space: pre-wrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s linear;
        }

        #icon-thumbnail-tooltip {
            display: none;
            position: fixed;
            z-index: 9999;
            background-color: #2a2a2e;
            color: #fff;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 12px;
            font-size: 14px;
            width: 280px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s linear;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            display: flex;
            gap: 12px;
            align-items: center;
        }
        #icon-thumbnail-tooltip .thumbnail-icon {
            flex-shrink: 0;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #icon-thumbnail-tooltip .thumbnail-icon svg {
            width: 32px;
            height: 32px;
        }
        #icon-thumbnail-tooltip .thumbnail-text h4 {
            margin: 0 0 4px 0;
            font-size: 1em;
            color: #e0e0e0;
            border: none;
        }
        #icon-thumbnail-tooltip .thumbnail-text p {
            margin: 0;
            font-size: 0.9em;
            color: #aaa;
        }


        #batch-fieldset {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            min-height: 0;
            border: none;
            padding: 0;
            margin: 0;
        }
        #batch-info-log {
            background-color: #000;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            height: auto;
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
            margin-top: 15px;
            margin-bottom: 15px;
            color: #ccc;
        }
        #batch-controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            align-items: end;
        }
        #batch-controls-grid .full-width {
            grid-column: 1 / -1;
        }
    </style>
</head>
<body>

<div id="tree-view-container">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <button id="project-menu-btn" class="btn-secondary" title="Open Project Menu">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"/></svg>
            Menu
        </button>
        <button id="style-editor-btn" class="btn-primary file-icon-btn" title="Style Template Editor">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1 2.5A1.5 1.5 0 0 1 2.5 1h3A1.5 1.5 0 0 1 7 2.5v3A1.5 1.5 0 0 1 5.5 7h-3A1.5 1.5 0 0 1 1 5.5v-3zm8 0A1.5 1.5 0 0 1 10.5 1h3A1.5 1.5 0 0 1 15 2.5v3A1.5 1.5 0 0 1 13.5 7h-3A1.5 1.5 0 0 1 9 5.5v-3zm-8 8A1.5 1.5 0 0 1 2.5 9h3A1.5 1.5 0 0 1 7 10.5v3A1.5 1.5 0 0 1 5.5 15h-3A1.5 1.5 0 0 1 1 13.5v-3zm8 0A1.5 1.5 0 0 1 10.5 9h3a1.5 1.5 0 0 1 1.5 1.5v3a1.5 1.5 0 0 1-1.5 1.5h-3A1.5 1.5 0 0 1 9 13.5v-3z"/></svg>
        </button>
    </div>
    
    <div id="view-mode-toggle">
        <button id="toggle-tree-view-btn" class="active" title="Tree View">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="M10.23,6.86,8.7,8.4a.5.5,0,0,1-.71,0L6.44,6.86a.5.5,0,0,1,0-.71l.71-.71a.5.5,0,0,1,.71,0l.71.71a.5.5,0,0,0,.71,0l.71-.71a.5.5,0,0,1,.71,0l.71.71A.5.5,0,0,1,10.23,6.86Z"/>
                <path d="M15,11.5A1.5 1.5,0,0,1,13.5,13H11V9.5a.5.5,0,0,0-.5-.5H8.71a.5.5,0,0,1,0-1H11.5a.5.5,0,0,0,.5-.5V6h1.5a.5.5,0,0,0,0-1H11.5A1.5 1.5,0,0,0,10,6.5v1a1.5,1.5,0,0,0-1.5,1.5H5.5A1.5 1.5,0,0,0,4,7.5v-1A1.5 1.5,0,0,0,2.5,5H1a.5.5,0,0,0,0,1H2.5a.5.5,0,0,1,.5.5V8H5.29a.5.5,0,0,1,0,1H3a.5.5,0,0,0-.5,.5V13H1.5A1.5 1.5,0,0,1,0,11.5v-1A1.5 1.5,0,0,1,1.5,9h.05a.5.5,0,0,1,0,1H1.5a.5.5,0,0,0-.5.5v1a.5.5,0,0,0,.5.5H3v.5a.5.5,0,0,0,.5.5H11a.5.5,0,0,0,.5-.5V13h1.5a.5.5,0,0,0,.5-.5v-1a.5.5,0,0,0-.5-.5h-.05a.5.5,0,0,1,0-1H14.5A1.5 1.5,0,0,1,16,10.5Z"/>
            </svg>
            Tree
        </button>
        <button id="toggle-scene-view-btn" title="Scene List View">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="M2.5,4A1.5,1.5,0,1,0,4,2.5,1.5,1.5,0,0,0,2.5,4Z"/>
                <path d="M2.5,9A1.5,1.5,0,1,0,4,7.5,1.5,1.5,0,0,0,2.5,9Z"/>
                <path d="M2.5,14A1.5,1.5,0,1,0,4,12.5,1.5,1.5,0,0,0,2.5,14Z"/>
                <path d="M7,3H15a1,1,0,0,1,0,2H7A1,1,0,0,1,7,3Z"/>
                <path d="M7,8H15a1,1,0,0,1,0,2H7A1,1,0,0,1,7,8Z"/>
                <path d="M7,13H15a1,1,0,0,1,0,2H7A1,1,0,0,1,7,13Z"/>
            </svg>
            Scenes
        </button>
    </div>
    
    <ul id="tree-view"></ul>
    <div id="scene-list-view-wrapper" style="display: none; flex-direction: column; flex-grow: 1; min-height: 0;">
        <div id="scene-list-view"></div>
        <div id="scene-list-controls">
            <label for="scene-list-sort" style="font-size: 0.9em; margin: 0; font-weight: normal;">Sort by:</label>
            <select id="scene-list-sort">
                <option value="id">ID (A-Z)</option>
                <option value="modified">Last Modified</option>
            </select>
        </div>
    </div>

    <div class="form-group inline" style="margin-top: 15px; margin-bottom: 0;">
        <input type="search" id="scene-search-input" placeholder="Filter scenes...">
        <button id="scene-search-btn" class="file-icon-btn" title="Search Scenes">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/></svg>
        </button>
    </div>
</div>

<div id="editor-container">
    <fieldset id="editor-fieldset">
        <div class="header">
            <h1>Scene Editor <span id="main-title-dirty-indicator">(unsaved)</span></h1>
            <div style="flex-grow: 1; display: flex; justify-content: center; align-items: center;">
                <div class="form-group inline" id="scene-id-group" style="margin-bottom: 0; min-width: 250px;">
                    <label for="scene-id" style="margin-bottom: 0; white-space: nowrap;">Scene ID</label>
                    <input type="text" id="scene-id" disabled style="padding-top: 10px; padding-bottom: 10px;">
                    <button id="rename-scene-btn" title="Rename Scene ID" class="file-icon-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z"/></svg>
                    </button>
                    <button id="new-scene-btn" class="btn-round" title="Create New Scene">+</button>
                </div>
            </div>
            <div class="btn-group">
                <button id="play-from-current-btn" class="btn-success" title="Play from Current Scene">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" style="transform: scaleX(1.2);"><path d="M10.804 8 5 4.633v6.734L10.804 8zM4 4v8h-1V4h1zm8 0v8h-1V4h1z"/></svg>
                </button>
                <button id="play-from-start-btn" class="btn-success" title="Play from Start Scene">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>
                </button>
                 <button id="preview-btn" class="btn-success" title="Preview Project in New Tab">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M6.271 5.055a.5.5 0 0 1 .52.038l3.5 2.5a.5.5 0 0 1 0 .814l-3.5 2.5A.5.5 0 0 1 6 10.5v-5a.5.5 0 0 1 .271-.445z"/></svg>
                </button>
                <button id="save-scene-btn" class="btn-warning" title="Save Changes to Memory (Ctrl+S)">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4.5 0h-2A1.5 1.5 0 0 0 1 1.5V15a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2.5A1.5 1.5 0 0 0 13.5 1h-2a.5.5 0 0 1 0-1h-2a.5.5 0 0 1 0 1h-2a.5.5 0 0 1 0-1H4.5zM3 14V2.5A.5.5 0 0 1 3.5 2H5v1.5A1.5 1.5 0 0 0 6.5 5h3A1.5 1.5 0 0 0 11 3.5V2h1.5a.5.5 0 0 1 .5.5V14a.5.5 0 0 1-.5-.5H3.5a.5.5 0 0 1-.5-.5z"/></svg>
                </button>
                <button id="delete-scene-btn" class="btn-danger" title="Delete Current Scene">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg>
                </button>
            </div>
        </div>
        <div id="editor-panel">
            
            <div id="scene-editor-preview-wrapper">
                <div id="scene-editor-preview">
                    <div id="preview-player-inner-container" class="layout-top-down">
                        <div id="preview-player-image-container"><img id="preview-player-image" src="" alt="Preview image"></div>
                        <div id="preview-player-content-container">
                            <div id="preview-player-text"></div>
                            <div id="preview-player-choices"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="form-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <textarea id="scene-text" placeholder="Story text goes here..." style="flex-grow: 1;"></textarea>
                <button id="process-text-ai-btn" class="btn-purple" title="Process Text with AI">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M7.657 6.247c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937zM3.794 1.148c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937z"/></svg>
                </button>
            </div>

            <div id="choices-container"></div>
            <div style="display: flex; justify-content: flex-end; margin-bottom: 15px;">
                <button id="add-choice-btn" class="btn-round" title="Add New Choice">+</button>
            </div>
            <hr>

            <div class="form-group" id="media-hub">
                <div id="image-preview">
                    <span>Thumbnail</span>
                    <div class="thumbnail-fullscreen-icon" title="View Fullscreen">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg>
                    </div>
                </div>
                <div id="media-paths-container">
                    <div class="form-group inline">
                        <span class="media-icon-label" title="Image Path">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/><path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/></svg>
                        </span>
                        <input type="text" id="scene-image" data-asset-type="images" placeholder="e.g., images/trench.jpg">
                        <button id="select-image-btn" class="btn-warning file-icon-btn" title="Select Image File">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.54 3.87.5 3a2 2 0 0 1 2-2h3.672a2 2 0 0 1 1.414.586l.828.828A2 2 0 0 0 9.828 3h3.982a2 2 0 0 1 1.992 2.181l-.637 7A2 2 0 0 1 13.174 14H2.826a2 2 0 0 1-1.991-1.819l-.637-7a1.99 1.99 0 0 1 .342-1.31zM6.172 2a1 1 0 0 0-.707.293L4.646 3.114a1 1 0 0 1-.707.293H2.5a1 1 0 0 0-1 .981l.637 7a1 1 0 0 0 .992.919h10.348a1 1 0 0 0 .991-.919l.637-7a1 1 0 0 0-1-1.019h-3.982a1 1 0 0 1-.707-.293l-.828-.828A1 1 0 0 0 6.172 2H2.5z"/></svg>
                        </button>
                    </div>
                    <div class="form-group inline">
                         <span class="media-icon-label" title="Sound Path">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M8 3a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0v-8A.5.5 0 0 1 8 3zm-2 2a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 1 .5-.5zm4 0a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 1 .5-.5zm-6 1a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2a.5.5 0 0 1 .5-.5zm8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2a.5.5 0 0 1 .5-.5zm-10 1a.5.5 0 0 1 .5.5v0a.5.5 0 0 1-1 0v0a.5.5 0 0 1 .5-.5zm12 0a.5.5 0 0 1 .5.5v0a.5.5 0 0 1-1 0v0a.5.5 0 0 1 .5-.5z"/></svg>
                        </span>
                        <input type="text" id="scene-sound" data-asset-type="sounds" placeholder="e.g., sounds/wind.mp3">
                         <button id="toggle-loop-btn" class="btn-secondary file-icon-btn" title="Toggle Ambience Loop">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                 <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                                 <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966a.25.25 0 0 1 0 .384l-2.36 1.966A.25.25 0 0 1 8 4.466z"/>
                             </svg>
                         </button>
                         <button id="toggle-ambience-btn" class="btn-secondary file-icon-btn" title="Play/Pause Ambience">
                            <svg class="play-pause-icon" id="ambience-play-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M10.804 8 5 4.633v6.734L10.804 8z"/></svg>
                            <svg class="play-pause-icon hidden" id="ambience-pause-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M6 3.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5zm4 0a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5z"/></svg>
                        </button>
                        <button id="select-sound-btn" class="btn-warning file-icon-btn" title="Select Sound File">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.54 3.87.5 3a2 2 0 0 1 2-2h3.672a2 2 0 0 1 1.414.586l.828.828A2 2 0 0 0 9.828 3h3.982a2 2 0 0 1 1.992 2.181l-.637 7A2 2 0 0 1 13.174 14H2.826a2 2 0 0 1-1.991-1.819l-.637-7a1.99 1.99 0 0 1 .342-1.31zM6.172 2a1 1 0 0 0-.707.293L4.646 3.114a1 1 0 0 1-.707.293H2.5a1 1 0 0 0-1 .981l.637 7a1 1 0 0 0 .992.919h10.348a1 1 0 0 0 .991-.919l.637-7a1 1 0 0 0-1-1.019h-3.982a1 1 0 0 1-.707-.293l-.828-.828A1 1 0 0 0 6.172 2H2.5z"/></svg>
                        </button>
                    </div>
                </div>
            </div>

            <hr>

            <div class="form-group">
                <label for="scene-image-prompt">AI Image</label>
                <div id="ai-image-generator">
                    <div id="ai-image-preview">
                        <span>Preview</span>
                        <div class="thumbnail-fullscreen-icon" title="View Fullscreen">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg>
                        </div>
                    </div>
                    <div id="ai-image-controls">
                        <textarea id="scene-image-prompt" placeholder="A stunning vista of a fantasy castle at sunset, digital art" style="flex-grow: 1; height: 150px; resize: none; margin-top:0;"></textarea>
                        <div class="btn-group" style="flex-direction: column; flex-shrink: 0; gap: 5px; margin-top: 0; align-self: stretch; justify-content: center;">
                            <button id="render-ai-image-btn" class="btn-purple" style="margin-top:0;" title="Render AI Image (Right-click for batch options)">
                                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M7.657 6.247c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937zM3.794 1.148c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937z"/></svg>
                            </button>
                            <button id="add-ai-image-btn" class="btn-success" style="margin-top:0;" title="Add Rendered Image to Scene">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/></svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </fieldset>
</div>

<!-- Hidden Inputs for File Selection -->
<input type="file" id="image-file-input" accept="image/*">
<input type="file" id="sound-file-input" accept="audio/*">

<!-- Player and Context Menu -->
<div id="player-container"><button id="stop-play-x" class="btn-danger">X</button><button id="restart-play" class="btn-secondary" title="Restart Game"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908.417A6 6 0 1 0 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466z"/></svg></button><div id="player-inner-container"><div id="player-image-container"><img id="player-image" src=""></div><div id="player-content-container"><div id="player-text"></div><div id="player-choices"></div></div></div><audio id="ambience-player"></audio><audio id="music-player" loop></audio></div>
<div id="tree-context-menu"><button id="set-start-scene-btn">Set as Start Scene</button></div>

<!-- Tooltips -->
<div id="custom-tooltip"></div>
<div id="icon-thumbnail-tooltip">
    <div class="thumbnail-icon"></div>
    <div class="thumbnail-text">
        <h4></h4>
        <p></p>
    </div>
</div>


<!-- Modals -->
<div id="project-menu-modal" class="modal">
    <div class="modal-content">
        <span class="modal-close">&times;</span>
        <h2>Project Menu</h2>
        <div class="btn-group" style="flex-direction: column; gap: 15px; align-items: stretch;">
            <button id="new-project-btn" class="btn-secondary">New Project</button>
            <button id="open-project-btn" class="btn-secondary">Open Project</button>
            <button id="save-story-btn" class="btn-success">Save Project</button>
            <button id="about-editor-btn">Project Text Editor</button>
            <button id="batch-image-gen-btn" class="btn-secondary" disabled>Batch Image Generation</button>
            <button id="export-data-btn" class="btn-warning">Export Data</button>
            <button id="export-project-btn" class="btn-warning">Export Standalone Game</button>
            <button id="export-exe-btn" class="btn-warning">Export as EXE (Windows)</button>
        </div>
    </div>
</div>
<div id="about-editor-modal" class="modal"><div class="modal-content"><span class="modal-close">&times;</span><h2>Project Text Editor</h2><p>This information will be displayed in the player's "About" section.</p><div class="form-group"><label for="story-title">Story Title</label><input type="text" id="story-title" placeholder="Your story title"></div><div class="form-group"><label for="creator-name">Creator Name</label><input type="text" id="creator-name" placeholder="Your name or alias"></div><div class="form-group"><label for="about-text">About Text</label><textarea id="about-text" placeholder="A brief description of your project."></textarea></div></div></div>
<div id="export-data-modal" class="modal"><div class="modal-content"><span class="modal-close">&times;</span><h2>Export Specific Data</h2><p>Select data to export as a JSON file.</p><button data-export-type="imagePrompts">Export All Image Prompts</button></div></div>
<div id="style-editor-modal" class="modal"><div class="modal-content"><span class="modal-close">&times;</span><h2>Style Template Editor</h2><div id="style-editor-grid" class="modal-grid"></div></div></div>
<div id="fullscreen-viewer" class="modal"><img id="fullscreen-image" src=""><button id="fullscreen-minimize" class="btn-secondary">Minimize</button></div>
<div id="notification-modal" class="modal">
    <div class="modal-content" style="max-width: 400px; text-align: center;">
        <p id="notification-message" style="margin-top: 0;"></p>
        <button id="notification-close-btn" class="btn-secondary" style="min-width: 80px;">OK</button>
    </div>
</div>
<div id="pollinations-text-modal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="modal-close">&times;</span>
        <h2>Process Text with AI</h2>
        <div class="form-group">
            <label for="pollinations-instruction">Instruction</label>
            <textarea id="pollinations-instruction" placeholder="e.g., Rewrite this text in the style of Edgar Allan Poe"></textarea>
        </div>
        <div class="btn-group" style="justify-content: flex-end;">
            <button id="pollinations-submit-btn" class="btn-purple">Process Text</button>
        </div>
    </div>
</div>

<div id="batch-image-modal" class="modal">
    <div class="modal-content">
        <span class="modal-close">&times;</span>
        <h2>Batch Image Generation</h2>
        <fieldset id="batch-fieldset">
            <div id="batch-controls-grid">
                <div class="form-group full-width" style="margin-bottom:0;">
                    <label for="batch-suffix-input">Prompt Suffix</label>
                    <input type="text" id="batch-suffix-input" placeholder="e.g., , cinematic lighting, 4k">
                </div>
                <div class="form-group" style="margin-bottom:0;">
                    <label for="batch-cooldown-input">Cooldown (sec)</label>
                    <input type="number" id="batch-cooldown-input" value="15" min="0">
                </div>
                <div class="form-group" style="margin-bottom:0;">
                     <label class="checkbox-label">
                        <input type="checkbox" id="batch-rewrite-prompt-checkbox">
                        AI Rewrite Text to Prompt
                    </label>
                </div>
                 <div class="form-group" style="margin-bottom:0;">
                     <label class="checkbox-label" title="If checked, new images will be generated even for scenes that already have one. Also allows 'AI Rewrite' to replace existing prompts.">
                        <input type="checkbox" id="batch-overwrite-checkbox">
                        Overwrite
                    </label>
                </div>
            </div>
            <div id="batch-info-log">Ready to generate.</div>
             <hr style="margin-top: 0;">
             <div class="btn-group" style="justify-content: space-between;">
                <button id="batch-remove-images-btn" class="btn-danger">Delete All Images</button>
                <button id="batch-remove-prompts-btn" class="btn-danger">Delete All Prompts</button>
            </div>
        </fieldset>
        <div class="btn-group" style="margin-top: 20px; justify-content: flex-end; flex-shrink: 0;">
            <button id="batch-generate-btn" class="btn-purple">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M7.657 6.247c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937zM3.794 1.148c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937z"/></svg>
                Generate
            </button>
        </div>
    </div>
</div>

<div id="export-exe-modal" class="modal">
    <div class="modal-content" style="max-width: 560px;">
        <span class="modal-close">&times;</span>
        <h2>Export Windows EXE</h2>
        <div class="form-group" style="display:flex; gap:15px; align-items:center;">
            <div id="export-icon-preview" style="width:96px; height:96px; border:1px dashed var(--border-color); display:flex; align-items:center; justify-content:center; background:#111; border-radius:8px; overflow:hidden;">
                <span>Icon (Optional)</span>
            </div>
            <div class="btn-group" style="flex-direction:column; gap:8px;">
                <button id="select-export-icon-btn" class="btn-warning">Select Icon</button>
                <small style="opacity:.8;">Use a <b>.ico</b> file for the EXE icon.</small>
            </div>
        </div>
        <input type="file" id="export-icon-file-input" accept="image/*" style="display:none;">
        <div class="form-group">
            <label for="export-nw-path">NW.js Folder Path</label>
            <div class="form-group inline" style="margin:0;">
                <input type="text" id="export-nw-path" placeholder="Select the root NW.js folder" disabled>
                <button id="select-nw-btn" class="btn-warning file-icon-btn" title="Select NW.js Folder">📁</button>
                <button id="nw-download-btn" class="btn-secondary file-icon-btn" title="Open NW.js Downloads Page">🌐</button>
            </div>
        </div>
        
        <div class="form-group">
            <label>Export Log</label>
            <pre id="export-exe-log" style="background-color: #000; border: 1px solid var(--border-color); border-radius: 4px; height: 150px; overflow-y: auto; padding: 10px; font-family: monospace; font-size: 0.9em; white-space: pre-wrap; color: #ccc;">Ready to export.
</pre>
        </div>

        <div class="btn-group" style="justify-content:flex-end;">
            <button id="export-exe-run-btn" class="btn-success">Export</button>
        </div>
    </div>
</div>

<!-- JSZip Library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<!-- Player HTML Template -->
<template id="player-template">
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>__STORY_TITLE__</title>
        <style>
            :root { --primary-color: #4a78ad; --secondary-color: #6c757d; }
            * { box-sizing: border-box; }
            body { 
                margin: 0; 
                font-family: sans-serif; 
                display: flex; 
                justify-content: center; 
                min-height: 100vh; 
                transition: background-color .3s; 
                background-size: cover; 
                background-position: center; 
                padding: 20px;
            }
            body:not(.layout-image-as-bg) { align-items: center; }
            body.layout-image-as-bg { align-items: flex-end; }

            #game-container { 
                width: 100%; 
                max-width: 800px; 
                border-radius: 12px; 
                box-shadow: 0 5px 20px rgba(0,0,0,.5); 
                display: flex; 
                gap: 20px; 
                position: relative; 
                background-size: cover; 
                background-position: center; 
                padding: var(--padding);
            }
            #image-container { flex-shrink: 0; }
            #scene-image { display: block; margin: 0 auto; border-radius: 8px; object-fit: cover; }
            #scene-text { white-space: pre-wrap; margin-bottom: 20px; }
            #choices-container { display: flex; flex-direction: column; gap: 12px; }
            .choice-btn { padding: 15px 20px; border-radius: 6px; cursor: pointer; font-size: 1em; text-align: left; transition: background-color .2s,transform .1s, border-color .2s; }
            .choice-btn:hover { transform: translateY(-2px); }
            .choice-btn:active { transform: translateY(1px); }
            @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
            .choice-btn.fade-in { animation: fadeIn 0.5s forwards; opacity: 0; }

            #game-container.layout-top-down { flex-direction: column; }
            #game-container.layout-top-down #image-container { width: 100%; margin-bottom: 20px; }
            #game-container.layout-top-down #scene-image { width: 100%; height: auto; max-height: 50vh; }
            #game-container.layout-side-by-side { flex-direction: row; align-items: flex-start; }
            #game-container.layout-side-by-side #image-container { width: 40%; }
            #game-container.layout-side-by-side #scene-image { width: 100%; height: auto; }
            #game-container.layout-side-by-side #content-container { width: 60%; }
            #game-container.layout-image-as-bg #image-container { display: none; }
            #game-container.layout-image-as-bg #content-container { width: 100%; }
            body.layout-image-as-bg .choice-btn { text-align: center; }

            .player-top-bar {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                padding: 10px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                z-index: 100;
                pointer-events: none;
            }
            .player-top-bar-left, .player-top-bar-right {
                display: flex;
                gap: 10px;
            }
            .player-ui-btn {
                pointer-events: auto;
                background: rgba(0,0,0,0.5);
                color: white;
                border: 1px solid rgba(255,255,255,0.5);
                border-radius: 50%;
                width: 40px;
                height: 40px;
                padding: 0;
                font-size: 24px;
                line-height: 40px;
                text-align: center;
                cursor: pointer;
                display: flex;
                justify-content: center;
                align-items: center;
            }
            .player-ui-btn svg {
                width: 22px;
                height: 22px;
                fill: currentColor;
            }
            .player-ui-btn .icon-off {
                display: none;
            }
            #fullscreen-btn {
                position: fixed;
                bottom: 15px;
                right: 15px;
                z-index: 100;
            }
            
            #exit-message {
                display: none;
                width: 100%;
                text-align: center;
                font-size: 1.2em;
                color: var(--text-color, #f0f0f0);
            }

            @media (max-width: 600px) {
                body {
                    padding: 10px;
                }
                #game-container {
                    padding: 15px;
                    gap: 15px;
                }
                .choice-btn {
                    padding: 12px 15px;
                    font-size: 0.9em;
                }
            }
            
            .player-modal {
                display: none;
                position: fixed;
                z-index: 1000;
                left: 0; top: 0; width: 100%; height: 100%;
                background-color: transparent;
                transition: background-color 0.3s ease-out;
            }
            .player-modal.visible {
                background-color: rgba(0, 0, 0, 0.5);
            }
            .player-modal-content {
                background-color: #2c2c2c;
                color: #e0e0e0;
                padding: 20px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                position: relative;
                max-height: 90vh;
                overflow-y: auto;
            }
            #player-menu-modal {
                justify-content: flex-start;
            }
            #player-menu-modal .player-modal-content {
                background-color: #202124;
                width: 100%;
                max-width: 360px;
                height: 100%;
                max-height: 100vh;
                border-radius: 0;
                margin: 0;
                transform: translateX(-100%);
                transition: transform 0.3s ease-out;
                padding: 0;
                display: flex;
                flex-direction: column;
            }
            #player-menu-modal.visible .player-modal-content {
                transform: translateX(0);
            }
            #about-modal {
                justify-content: center;
                align-items: center;
            }
            #about-modal .player-modal-content {
                width: 90%;
                max-width: 500px;
                border-radius: 8px;
            }
            .menu-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 16px 20px;
                flex-shrink: 0;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }
            .menu-header h2 {
                margin: 0;
                border: none;
                font-size: 1.1em;
                color: #e8eaed;
            }
            .menu-header .player-modal-close {
                position: static;
                font-size: 1.8em;
                line-height: 1;
            }
            .menu-body {
                padding: 20px;
                overflow-y: auto;
                flex-grow: 1;
            }
            .menu-body hr {
                border: none;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                margin: 20px 0;
            }
            .menu-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; gap: 15px; }
            .menu-item button { flex-grow: 1; margin: 0; background-color: var(--secondary-color); padding: 8px 12px; }
            .menu-item button:disabled { background-color: #444; color: #888; cursor: not-allowed; }
            .menu-item span { flex-shrink: 0; color: #bdc1c6; }
            
            #about-title { text-align: center; }
            #about-creator { text-align: center; font-style: italic; margin-top: -10px; }
            #about-text { text-align: left; }
            #about-text a { color: #8ab4f8; text-decoration: none; }
            #about-text a:hover { text-decoration: underline; }
            .about-footer { margin-top: 20px; padding-top: 10px; border-top: 1px solid #444; font-size: 0.8em; text-align: center; white-space: pre-wrap; }
            .about-footer a { color: #8af; text-decoration: none; }

            #loading-overlay {
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: #111; z-index: 9999; display: flex;
                justify-content: center; align-items: center; flex-direction: column;
                color: white; font-size: 1.5em;
            }
            .loading-spinner {
                border: 8px solid #f3f3f3; border-top: 8px solid var(--primary-color);
                border-radius: 50%; width: 60px; height: 60px;
                animation: spin 1.5s linear infinite; margin-bottom: 20px;
            }
            @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

            __CUSTOM_STYLES__
        </style>
    </head>
    <body class="__LAYOUT_CLASS__">
        <div id="loading-overlay">
            <div class="loading-spinner"></div>
            <p>Loading...</p>
        </div>

        <div id="exit-message">
            <p>Thanks for playing!</p>
            <p>You can now close this window.</p>
        </div>
        <div id="game-container" class="__LAYOUT_CLASS__">
            <div id="image-container"><img id="scene-image" src=""></div>
            <div id="content-container">
                <div id="scene-text"></div>
                <div id="choices-container"></div>
            </div>
            <audio id="ambience-player"></audio>
            <audio id="music-player" loop></audio>
        </div>

        <div class="player-top-bar">
            <div class="player-top-bar-left">
                <button id="player-menu-btn" class="player-ui-btn" title="Open Menu">&#9776;</button>
                <button id="player-sound-toggle-btn" class="player-ui-btn" title="Toggle Sound">
                    <svg class="icon-on" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg>
                    <svg class="icon-off" viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"></path></svg>
                </button>
            </div>
            <div class="player-top-bar-right">
                <button id="player-close-btn" class="player-ui-btn" title="Exit Game">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
                </button>
            </div>
        </div>
        
        <button id="fullscreen-btn" class="player-ui-btn" title="Toggle Fullscreen">
            <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"></path></svg>
        </button>

        <div id="player-menu-modal" class="player-modal">
            <div class="player-modal-content">
                <div class="menu-header">
                    <h2>Menu</h2>
                    <span class="player-modal-close">&times;</span>
                </div>
                <div class="menu-body">
                    <div class="menu-item"><button id="restart-btn">Restart Game</button></div>
                    <hr>
                    <div class="menu-item"><button id="save-btn">Save Progress</button><button id="load-btn">Load Progress</button></div>
                    <hr>
                    <div class="menu-item"><span>Music</span><input type="range" id="volume-slider" min="0" max="1" step="0.01"></div>
                    <div class="menu-item"><span>Ambience</span><input type="range" id="ambience-volume-slider" min="0" max="1" step="0.01"></div>
                    <div class="menu-item"><span>Font Size</span><input type="range" id="font-size-slider" min="8" max="28" step="1" value="16"></div>
                    <hr>
                    <div class="menu-item"><button id="about-btn">About</button></div>
                </div>
            </div>
        </div>

        <div id="about-modal" class="player-modal">
            <div class="player-modal-content">
                <span class="player-modal-close">&times;</span>
                <h2 id="about-title"></h2>
                <p id="about-creator"></p>
                <p id="about-text"></p>
                <div class="about-footer">Created in
Kinexus
<a href="https://github.com/tin2tin/CYOA_Studio" target="_blank">https://github.com/tin2tin/CYOA_Studio</a></div>
            </div>
        </div>
__PLAYER_SCRIPT__
    </body>
    </html>
</template>

<!-- Main Application Logic -->
<script>
const App = {
    state: {
        storyData: {},
        currentSceneId: null,
        isDirty: false,
        contextSceneId: null,
        projectDirectoryHandle: null,
        pendingAssetCopies: new Map(),
        aiImageUrl: null,
        orphanSceneIds: new Set(),
        typewriter: { intervalId: null, skipListener: null },
        currentNavView: 'tree', // 'tree' or 'list'
        navViewsDirty: true, // IMPROVEMENT: Flag to check if tree/list needs re-rendering
        missingAssetWarnings: new Set(),
    },
    elements: {},

    init() {
        this.cacheElements();
        this.bindEvents();
        this.ui.enableEditor(false);
        this.ui.displayWelcomeMessage();
        this.modals.show('project-menu-modal');
        this.ui.setViewMode(localStorage.getItem('cyoa-nav-view') || 'tree');
    },

    getNewStoryObject() {
        return { 
            meta: { 
                title: "New Story", 
                startSceneId: "start",
                creatorName: "",
                aboutText: "",
                styles: App.styles.getDefaults(), 
                layout: 'layout-image-as-bg' 
            },
            scenes: { "start": { id: "start", text: "Start here.", image: "", imagePrompt: "", ambienceSound: "", ambienceLoop: true, choices: [], lastModified: Date.now() } } 
        };
    },
    
    cacheElements() {
        const ids = [
            'tree-view', 'editor-container', 'player-container', 'scene-id', 'scene-image',
            'scene-image-prompt', 'scene-sound', 'scene-text', 'choices-container',
            'ambience-player', 'music-player', 'export-data-modal', 'style-editor-modal', 'about-editor-modal',
            'tree-context-menu', 'main-title-dirty-indicator',
            'save-story-btn', 'player-image', 'player-text', 'player-choices', 'player-inner-container',
            'editor-fieldset', 'ai-image-preview', 'render-ai-image-btn', 'add-ai-image-btn', 'image-preview',
            'story-title', 'creator-name', 'about-text',
            'notification-modal', 'notification-message', 'notification-close-btn',
            'toggle-ambience-btn', 'ambience-play-icon', 'ambience-pause-icon', 'toggle-loop-btn',
            'scene-editor-preview', 'scene-editor-preview-wrapper',
            'pollinations-text-modal', 'pollinations-instruction', 'pollinations-submit-btn', 'process-text-ai-btn',
            'style-editor-btn', 'batch-image-modal', 'batch-image-gen-btn',
            'scene-list-view', 'toggle-tree-view-btn', 'toggle-scene-view-btn',
            'scene-list-view-wrapper', 'scene-list-sort'
        ];
        ids.forEach(id => this.elements[id] = document.getElementById(id));
    },

    bindEvents() {
        document.getElementById('new-project-btn').addEventListener('click', () => App.io.newProject());
        document.getElementById('open-project-btn').addEventListener('click', () => App.io.openProject());
        App.elements['save-story-btn'].addEventListener('click', () => App.io.saveProject());
        
        document.getElementById('new-scene-btn').addEventListener('click', () => App.tree.createNewScene());
        document.getElementById('rename-scene-btn').addEventListener('click', () => App.tree.renameScene());
        document.getElementById('delete-scene-btn').addEventListener('click', () => App.tree.deleteCurrentScene());
        document.getElementById('add-choice-btn').addEventListener('click', () => App.editor.addChoiceToDOM());
        document.getElementById('save-scene-btn').addEventListener('click', () => App.editor.saveCurrentScene(true));
        
        document.getElementById('select-image-btn').addEventListener('click', () => App.assets.selectFile('images', 'scene-image'));
        document.getElementById('select-sound-btn').addEventListener('click', () => App.assets.selectFile('sounds', 'scene-sound'));
        App.elements['scene-image'].addEventListener('change', (e) => App.ui.updateImageThumbnail(e.target.value));
        App.elements['scene-sound'].addEventListener('input', (e) => {
            const hasSound = !!e.target.value;
            const btn = App.elements['toggle-ambience-btn'];
            btn.classList.toggle('btn-success', hasSound);
            btn.classList.toggle('btn-secondary', !hasSound);
        });

        App.elements['toggle-ambience-btn'].addEventListener('click', () => App.player.toggleAmbienceSound());
        App.elements['ambience-player'].addEventListener('play', () => App.player.updateAmbienceButton(true));
        App.elements['ambience-player'].addEventListener('pause', () => App.player.updateAmbienceButton(false));

        App.elements['toggle-loop-btn'].addEventListener('click', (e) => {
            const btn = e.currentTarget;
            const scene = App.state.storyData.scenes[App.state.currentSceneId];
            if (scene) {
                scene.ambienceLoop = !btn.classList.contains('active');
                btn.classList.toggle('active', scene.ambienceLoop);
                App.setDirty(true);
            }
        });

        ['scene-text', 'scene-image'].forEach(id => {
            App.elements[id].addEventListener('input', () => App.editor.renderPreview());
        });
        App.elements['choices-container'].addEventListener('input', () => App.editor.renderPreview());


        ['story-title', 'creator-name', 'about-text'].forEach(id => {
            App.elements[id].addEventListener('input', (e) => {
                const key = id === 'story-title' ? 'title' : id === 'creator-name' ? 'creatorName' : 'aboutText';
                App.state.storyData.meta[key] = e.target.value;
                App.setDirty(true);
            });
        });

        App.elements['render-ai-image-btn'].addEventListener('click', () => App.assets.renderPollinationImage());
        App.elements['render-ai-image-btn'].addEventListener('contextmenu', (e) => {
            e.preventDefault();
            App.batch.open();
        });
        
        App.elements['add-ai-image-btn'].addEventListener('click', () => App.assets.addPollinationImageToScene());
        App.elements['process-text-ai-btn'].addEventListener('click', () => App.modals.show('pollinations-text-modal'));
        App.elements['pollinations-submit-btn'].addEventListener('click', () => App.assets.processTextWithPollinations());

        document.getElementById('play-from-start-btn').addEventListener('click', () => { App.editor.saveCurrentScene(false); App.player.play(App.state.storyData.meta.startSceneId); });
        document.getElementById('play-from-current-btn').addEventListener('click', () => { App.editor.saveCurrentScene(false); App.player.play(App.state.currentSceneId); });
        document.getElementById('stop-play-x')?.addEventListener('click', () => App.player.stop());
        document.getElementById('restart-play')?.addEventListener('click', () => App.player.play(App.state.storyData.meta.startSceneId));
        
        document.getElementById('export-project-btn').addEventListener('click', () => App.io.exportProjectZip());
        document.getElementById('export-exe-btn').addEventListener('click', () => App.modals.show('export-exe-modal'));
        document.getElementById('preview-btn').addEventListener('click', () => App.io.previewProject());
        document.getElementById('export-data-btn').addEventListener('click', () => App.modals.show('export-data-modal'));
        // Add Validate Project button to project menu, if not present, add dynamically
        (function ensureValidateButton(){
            const menu = document.querySelector('#project-menu-modal .btn-group');
            if (menu && !document.getElementById('validate-project-btn')) {
                const btn = document.createElement('button');
                btn.id = 'validate-project-btn';
                btn.className = 'btn-secondary';
                btn.textContent = 'Validate Project';
                btn.addEventListener('click', App.io.openValidationReport);
                menu.insertBefore(btn, document.getElementById('export-data-btn'));
            }
        })();
        App.elements['style-editor-btn'].addEventListener('click', () => App.styles.open());
        App.elements['batch-image-gen-btn'].addEventListener('click', () => App.batch.open());
        document.getElementById('about-editor-btn').addEventListener('click', () => App.modals.show('about-editor-modal'));
        
        document.querySelectorAll('.modal-close').forEach(el => el.addEventListener('click', (e) => App.modals.hide(e.target.closest('.modal'))));
        App.elements['export-data-modal'].addEventListener('click', (e) => { if(e.target.dataset.exportType) App.io.exportData(e.target.dataset.exportType); });
        document.getElementById('set-start-scene-btn').addEventListener('click', () => App.tree.setAsStartScene());
        document.addEventListener('click', (e) => { if (!e.target.closest('.scene-node')) App.elements['tree-context-menu'].style.display = 'none'; });
        
        window.addEventListener('click', (e) => { 
            if (e.target.classList.contains('modal') && e.target.id !== 'about-editor-modal') {
                App.modals.hide(e.target); 
            }
        });

        document.getElementById('project-menu-btn').addEventListener('click', () => App.modals.show('project-menu-modal'));
        App.elements['notification-close-btn'].addEventListener('click', () => App.modals.hide(App.elements['notification-modal']));
        
        document.getElementById('batch-generate-btn').addEventListener('click', () => App.batch.startGeneration());
        document.getElementById('batch-remove-images-btn').addEventListener('click', () => App.batch.removeAllImages());
        document.getElementById('batch-remove-prompts-btn').addEventListener('click', () => App.batch.removeAllImagePrompts());

        const inputs = ['scene-image', 'scene-sound'];
        inputs.forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('dragover', App.assets.handleDragOver);
            el.addEventListener('dragleave', App.assets.handleDragLeave);
            el.addEventListener('drop', App.assets.handleFileDrop);
        });


        window.addEventListener('beforeunload', (e) => { if (App.state.isDirty) { e.preventDefault(); e.returnValue = ''; } });
        
        const searchInput = document.getElementById('scene-search-input');
        searchInput.addEventListener('input', () => App.ui.renderCurrentView());
        document.getElementById('scene-search-btn').addEventListener('click', () => App.ui.renderCurrentView());

        App.elements['toggle-tree-view-btn'].addEventListener('click', () => App.ui.setViewMode('tree'));
        App.elements['toggle-scene-view-btn'].addEventListener('click', () => App.ui.setViewMode('list'));
        App.elements['scene-list-sort'].addEventListener('change', () => App.sceneList.render());


        document.querySelectorAll('.thumbnail-fullscreen-icon').forEach(icon => {
            icon.addEventListener('click', (e) => {
                e.stopPropagation();
                const parentPreview = e.currentTarget.parentElement;
                const img = parentPreview.querySelector('img');
                if (img && img.src) {
                    App.ui.showFullscreenImage(img.src);
                }
            });
        });
        document.getElementById('fullscreen-minimize').addEventListener('click', () => App.modals.hide(document.getElementById('fullscreen-viewer')));
        document.getElementById('fullscreen-viewer').addEventListener('click', (e) => {
            if (e.target.id === 'fullscreen-viewer') {
                App.modals.hide(document.getElementById('fullscreen-viewer'));
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                if (App.state.projectDirectoryHandle && App.elements['editor-container'].style.display !== 'none') {
                    App.editor.saveCurrentScene(true);
                    App.io.saveProject();
                }
            }
        });

        // Tooltip Logic
        const tooltip = document.getElementById('custom-tooltip');
        const thumbnailTooltip = document.getElementById('icon-thumbnail-tooltip');
        let activeTooltip = null;

        document.body.addEventListener('mouseover', e => {
            const iconTarget = e.target.closest('[class^="icon-"]');
            const titleTarget = e.target.closest('[title]');

            if (iconTarget && App.ui.iconThumbnails[iconTarget.classList[0]]) {
                activeTooltip = thumbnailTooltip;
                const iconClass = iconTarget.classList[0];
                App.ui.showIconThumbnail(App.ui.iconThumbnails[iconClass]);
            } else if (titleTarget && titleTarget.title) {
                activeTooltip = tooltip;
                tooltip.textContent = titleTarget.title;
                titleTarget.dataset.originalTitle = titleTarget.title;
                titleTarget.removeAttribute('title');
                tooltip.style.display = 'block';
                requestAnimationFrame(() => { tooltip.style.opacity = '1'; });
            }
        });

        document.body.addEventListener('mouseout', () => {
            if (activeTooltip) {
                if (activeTooltip === tooltip) {
                    const originalTarget = document.querySelector('[data-original-title]');
                    if (originalTarget) {
                        originalTarget.setAttribute('title', originalTarget.dataset.originalTitle);
                        originalTarget.removeAttribute('data-original-title');
                    }
                }
                activeTooltip.style.opacity = '0';
                const tooltipRef = activeTooltip;
                setTimeout(() => {
                    if (tooltipRef && tooltipRef.style.opacity === '0') {
                        tooltipRef.style.display = 'none';
                    }
                }, 150);
                activeTooltip = null;
            }
        });

        document.body.addEventListener('mousemove', e => {
            if (activeTooltip) {
                const x = e.clientX;
                const y = e.clientY;
                const tooltipRect = activeTooltip.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                let top = y + 24;
                let left = x + 12;

                if (left + tooltipRect.width > viewportWidth) {
                    left = x - tooltipRect.width - 12;
                }
                if (top + tooltipRect.height > viewportHeight) {
                    top = y - tooltipRect.height - 24;
                }
                if (left < 0) left = 0;
                if (top < 0) top = 0;
                
                activeTooltip.style.left = `${left}px`;
                activeTooltip.style.top = `${top}px`;
            }
        });
    },
    
    setDirty(isDirty) {
        this.state.isDirty = isDirty;
        this.elements['main-title-dirty-indicator'].style.display = isDirty ? 'inline' : 'none';
        this.elements['save-story-btn'].classList.toggle('dirty', isDirty);
    },

    ui: {
        cursor: {
            wait() { document.body.style.cursor = 'wait'; },
            default() { document.body.style.cursor = 'default'; }
        },
        invalidateNavViews() {
            if (!App.state.navViewsDirty) {
                App.state.navViewsDirty = true;
            }
        },
        setViewMode(mode) {
            if (App.state.navViewsDirty) {
                this.cursor.wait();
                try {
                    const filterTerm = document.getElementById('scene-search-input').value;
                    App.tree.render(filterTerm);
                    App.sceneList.render(filterTerm);
                    App.state.navViewsDirty = false;
                } finally {
                    this.cursor.default();
                }
            }

            App.state.currentNavView = mode;
            localStorage.setItem('cyoa-nav-view', mode);

            const isTreeView = mode === 'tree';
            App.elements['tree-view'].style.display = isTreeView ? 'block' : 'none';
            App.elements['scene-list-view-wrapper'].style.display = isTreeView ? 'none' : 'flex';
            
            App.elements['toggle-tree-view-btn'].classList.toggle('active', isTreeView);
            App.elements['toggle-scene-view-btn'].classList.toggle('active', !isTreeView);
        },
        renderCurrentView() {
            if (!App.state.projectDirectoryHandle) {
                this.displayWelcomeMessage();
                return;
            }
            const filterTerm = document.getElementById('scene-search-input').value;
            if (App.state.currentNavView === 'tree') {
                App.tree.render(filterTerm);
            } else {
                App.sceneList.render(filterTerm);
            }
        },

        selectScene(sceneId) {
            if (!sceneId || !App.state.storyData.scenes[sceneId]) {
                console.error(`Attempted to select non-existent scene: ${sceneId}`);
                return;
            }

            if (App.elements['player-container'].style.display === 'flex') {
                App.player.renderScene(sceneId);
                return;
            }

            App.editor.saveCurrentScene(false);
            const needsSelectionChange = App.state.currentSceneId !== sceneId;
            
            if (needsSelectionChange) {
                const oldSceneId = App.state.currentSceneId;
                App.state.currentSceneId = sceneId;
                App.elements['ambience-player'].pause();
                
                const oldTreeNode = document.querySelector(`.scene-node[data-scene-id="${oldSceneId}"]`);
                const oldCardNode = document.querySelector(`.scene-card[data-scene-id="${oldSceneId}"]`);
                if (oldTreeNode) oldTreeNode.classList.remove('active');
                if (oldCardNode) oldCardNode.classList.remove('active');
            }
            
            const newTreeNode = document.querySelector(`.scene-node[data-scene-id="${sceneId}"]`);
            const newCardNode = document.querySelector(`.scene-card[data-scene-id="${sceneId}"]`);
            if (newTreeNode) newTreeNode.classList.add('active');
            if (newCardNode) newCardNode.classList.add('active');

            if (needsSelectionChange) {
                App.editor.render();
            }

            requestAnimationFrame(() => {
                const activeNode = document.querySelector(`.scene-node.active, .scene-card.active`);
                if (activeNode) {
                    activeNode.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                }
            });
        },

        enableEditor(isEnabled) {
            App.elements['editor-fieldset'].disabled = !isEnabled;
            document.getElementById('new-scene-btn').disabled = !isEnabled;
            document.getElementById('scene-search-input').disabled = !isEnabled;
            document.getElementById('scene-search-btn').disabled = !isEnabled;
            App.elements['save-story-btn'].disabled = !isEnabled;
            document.getElementById('export-project-btn').disabled = !isEnabled;
            document.getElementById('export-exe-btn').disabled = !isEnabled;
            document.getElementById('export-data-btn').disabled = !isEnabled;
            App.elements['style-editor-btn'].disabled = !isEnabled;
            document.getElementById('about-editor-btn').disabled = !isEnabled;
            
            const batchBtn = App.elements['batch-image-gen-btn'];
            if (batchBtn) {
                batchBtn.disabled = !isEnabled;
                if (isEnabled) {
                    batchBtn.classList.remove('btn-secondary');
                    batchBtn.classList.add('btn-purple');
                } else {
                    batchBtn.classList.remove('btn-purple');
                    batchBtn.classList.add('btn-secondary');
                }
            }
        },
        displayWelcomeMessage() {
            App.elements['tree-view'].innerHTML = `<li>Welcome! Please create a <strong>New Project</strong> or <strong>Open an existing one</strong> to begin.</li>`;
            App.elements['scene-list-view'].innerHTML = `<li style="padding:10px;">Welcome! Please create a project to see scenes here.</li>`;
            document.getElementById('scene-search-input').disabled = true;
            document.getElementById('scene-search-btn').disabled = true;
        },
        updateAiImagePreview(url, message = '') {
            const preview = App.elements['ai-image-preview'];
            const icon = preview.querySelector('.thumbnail-fullscreen-icon');
            preview.innerHTML = '';
            if (icon) preview.appendChild(icon);

            if (url) {
                const img = document.createElement('img');
                img.src = url;
                preview.appendChild(img);
            } else {
                const span = document.createElement('span');
                span.textContent = message || 'Preview';
                preview.appendChild(span);
            }
        },
        async updateImageThumbnail(path) {
            const preview = App.elements['image-preview'];
            const icon = preview.querySelector('.thumbnail-fullscreen-icon');
            preview.innerHTML = '';
            if(icon) preview.appendChild(icon);
            const defaultSpan = document.createElement('span');
            defaultSpan.textContent = 'Thumbnail';
            preview.appendChild(defaultSpan);

            if (!path) return;
            try {
                const url = await App.io.getAssetDataUrl(path);
                if (url) {
                    preview.innerHTML = '';
                    if(icon) preview.appendChild(icon);
                    const img = document.createElement('img');
                    img.src = url;
                    preview.appendChild(img);
                } else {
                     defaultSpan.textContent = 'Invalid Path';
                }
            } catch (e) {
                defaultSpan.textContent = 'Invalid Path';
                console.warn('Thumbnail load failed:', e);
            }
        },
        updateMetaInputs() {
            const meta = App.state.storyData.meta;
            App.elements['story-title'].value = meta.title || '';
            App.elements['creator-name'].value = meta.creatorName || '';
            App.elements['about-text'].value = meta.aboutText || '';
        },
        showFullscreenImage(src) {
            document.getElementById('fullscreen-image').src = src;
            App.modals.show('fullscreen-viewer');
        },
        showNotification(message) {
            App.elements['notification-message'].innerHTML = message;
            App.modals.show('notification-modal');
        },
        showIconThumbnail(data) {
            const tooltip = document.getElementById('icon-thumbnail-tooltip');
            tooltip.querySelector('.thumbnail-icon').innerHTML = data.icon;
            tooltip.querySelector('h4').textContent = data.title;
            tooltip.querySelector('p').textContent = data.desc;
            tooltip.style.display = 'flex';
            requestAnimationFrame(() => { tooltip.style.opacity = '1'; });
        },
        iconThumbnails: {
            'icon-start': {
                icon: `<svg class="icon-start" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>`,
                title: 'Start Scene',
                desc: 'This is the first scene players will see when the story begins.'
            },
            'icon-image': {
                icon: `<svg class="icon-image" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/><path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/></svg>`,
                title: 'Has Image',
                desc: 'This scene has an associated background or display image.'
            },
            'icon-sound': {
                icon: `<svg class="icon-sound" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M9.707,2.293a1,1,0,0,0-1.414,0L4.6,6H2.5A1.5,1.5,0,0,0,1,7.5v1A1.5,1.5,0,0,0,2.5,10H4.6l3.69,3.707a1,1,0,0,0,1.414,0V2.293Z"/></svg>`,
                title: 'Has Audio',
                desc: 'This scene has ambient sound or music that will play.'
            },
            'icon-deadend': {
                icon: `<svg class="icon-deadend" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/></svg>`,
                title: 'Dead End',
                desc: 'This scene has no choices and ends a branch of the story.'
            },
            'icon-orphan': {
                icon: `<svg class="icon-orphan" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M7.5 7.5V4h1v3.5h3.5v1H8.5V12h-1V8.5H4v-1h3.5z"/></svg>`,
                title: 'Orphan Scene',
                desc: 'This scene cannot be reached from the Start Scene. It is disconnected from the main story flow.'
            }
        }
    },

    io: {
        openValidationReport: async function() {
            if (!App.state.projectDirectoryHandle) {
                App.ui.showNotification('Please open a project first.');
                return;
            }
            try {
                const storyFileHandle = await App.state.projectDirectoryHandle.getFileHandle('story.json');
                const file = await storyFileHandle.getFile();
                const content = await file.text();
                let raw;
                try {
                    raw = JSON.parse(content);
                } catch (e) {
                    App.ui.showNotification(`<b>Validation Error:</b><br>Malformed JSON in story.json<br><br><i>${e.message}</i>`);
                    return;
                }
                const result = App.io.validateProjectData(raw, { autofix: false });
                if (!result.ok) {
                    App.ui.showNotification(`<b>Validation Failed:</b><br>${result.errors.join('<br>')}`);
                    return;
                }
                const warnings = result.warnings && result.warnings.length ? ('<br><br><b>Warnings:</b><br>' + result.warnings.map(w => '• ' + w).join('<br>')) : '';
                App.ui.showNotification(`<b>Validation OK</b>${warnings}`);
            } catch (err) {
                console.error('Validation error:', err);
                App.ui.showNotification('Validation failed due to an unexpected error.');
            }
        },
        validateProjectData(rawStoryData, { autofix = true } = {}) {
            const messages = [];
            const warnings = [];
            const errors = [];

            const defaultStory = App.getNewStoryObject();
            let storyData = rawStoryData;

            // Basic shape
            if (typeof storyData !== 'object' || storyData === null) {
                errors.push("Project root is not an object.");
                return { ok: false, data: defaultStory, messages, warnings, errors };
            }

            // Meta merge
            storyData.meta = { ...defaultStory.meta, ...(storyData.meta || {}) };
            if (typeof storyData.meta !== 'object' || storyData.meta === null) {
                warnings.push("'meta' was invalid. Reset to defaults.");
                storyData.meta = { ...defaultStory.meta };
            }

            // Scenes normalization: allow array or object
            const originalScenes = storyData.scenes;
            if (Array.isArray(originalScenes)) {
                const obj = {};
                originalScenes.forEach((scene, index) => {
                    if (scene && typeof scene === 'object') {
                        const desiredId = typeof scene.id === 'string' && scene.id.trim() ? scene.id.trim() : `scene_${index + 1}`;
                        obj[desiredId] = { ...scene, id: desiredId };
                    }
                });
                warnings.push("Converted 'scenes' from array to object using scene ids.")
                storyData.scenes = obj;
            } else if (typeof originalScenes !== 'object' || originalScenes === null) {
                warnings.push("'scenes' missing or invalid. Initialized with default 'start' scene.");
                storyData.scenes = { ...defaultStory.scenes };
            }

            // Coerce each scene, detect duplicates and invalid ids
            const sanitizedScenes = {};
            const seenIds = new Set();
            const invalidIdRegex = /[^A-Za-z0-9_\-]/;
            Object.entries(storyData.scenes).forEach(([key, sceneObj]) => {
                const scene = (typeof sceneObj === 'object' && sceneObj !== null) ? sceneObj : {};
                let id = typeof scene.id === 'string' && scene.id.trim() ? scene.id.trim() : key;
                if (!id || typeof id !== 'string') id = key;
                if (!id) id = 'scene';

                // Sanitize id: spaces to underscores
                let sanitizedId = id.replace(/\s+/g, '_');
                if (invalidIdRegex.test(sanitizedId)) {
                    const fixed = sanitizedId.replace(invalidIdRegex, '_');
                    warnings.push(`Scene id '${id}' contained invalid characters. Using '${fixed}'.`);
                    sanitizedId = fixed;
                }

                // Ensure unique id
                let uniqueId = sanitizedId;
                let counter = 2;
                while (seenIds.has(uniqueId)) {
                    uniqueId = `${sanitizedId}_${counter++}`;
                }
                if (uniqueId !== sanitizedId) {
                    warnings.push(`Duplicate scene id '${sanitizedId}' detected. Renamed to '${uniqueId}'.`);
                }
                seenIds.add(uniqueId);

                const safeChoices = Array.isArray(scene.choices) ? scene.choices.filter(c => c && typeof c === 'object') : [];

                sanitizedScenes[uniqueId] = {
                    id: uniqueId,
                    text: typeof scene.text === 'string' ? scene.text : '',
                    image: typeof scene.image === 'string' ? scene.image : '',
                    imagePrompt: typeof scene.imagePrompt === 'string' ? scene.imagePrompt : '',
                    ambienceSound: typeof scene.ambienceSound === 'string' ? scene.ambienceSound : '',
                    ambienceLoop: (scene.ambienceLoop === undefined ? true : !!scene.ambienceLoop),
                    choices: safeChoices.map(c => ({
                        text: typeof c.text === 'string' ? c.text : '',
                        target: typeof c.target === 'string' ? c.target : ''
                    })),
                    lastModified: typeof scene.lastModified === 'number' ? scene.lastModified : Date.now()
                };
            });

            if (Object.keys(sanitizedScenes).length === 0) {
                errors.push("No valid scenes found.");
                if (autofix) {
                    warnings.push("Replaced with default 'start' scene.");
                    storyData.scenes = { ...defaultStory.scenes };
                } else {
                    return { ok: false, data: defaultStory, messages, warnings, errors };
                }
            } else {
                storyData.scenes = sanitizedScenes;
            }

            // Validate choice targets and collect missing
            const allIds = new Set(Object.keys(storyData.scenes));
            const missingTargets = new Map();
            Object.values(storyData.scenes).forEach(scene => {
                scene.choices.forEach(ch => {
                    if (ch.target && !allIds.has(ch.target)) {
                        const arr = missingTargets.get(scene.id) || [];
                        arr.push(ch.target);
                        missingTargets.set(scene.id, arr);
                    }
                });
            });
            if (missingTargets.size > 0) {
                missingTargets.forEach((targets, fromId) => {
                    warnings.push(`Scene '${fromId}' has choices pointing to missing targets: ${[...new Set(targets)].join(', ')}`);
                });
            }

            // Start scene validity
            if (!storyData.meta.startSceneId || !storyData.scenes[storyData.meta.startSceneId]) {
                const old = storyData.meta.startSceneId;
                const fallback = Object.keys(storyData.scenes)[0];
                storyData.meta.startSceneId = fallback;
                warnings.push(`Start scene '${old || '(none)'}' was invalid. Using '${fallback}'.`);
            }

            return { ok: true, data: storyData, messages, warnings, errors };
        },
        async newProject() {
            try {
                const dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
                
                let projectName = prompt("Enter a name for your new project:", "My Kinexus Story");
                if (!projectName) return;
                projectName = projectName.trim().replace(/\s+/g, '_');

                let projectHandle;
                try {
                    projectHandle = await dirHandle.getDirectoryHandle(projectName);
                    const storyFileHandle = await projectHandle.getFileHandle('story.json').catch(() => null);
                    if (storyFileHandle) {
                        await App.io.openProject(projectHandle);
                        return;
                    }
                } catch (e) {
                    if (e.name === 'NotFoundError') {
                        projectHandle = await dirHandle.getDirectoryHandle(projectName, { create: true });
                    } else {
                        throw e;
                    }
                }

                await projectHandle.getDirectoryHandle('images', { create: true });
                await projectHandle.getDirectoryHandle('sounds', { create: true });
                
                const storyFileHandle = await projectHandle.getFileHandle('story.json', { create: true });
                const writable = await storyFileHandle.createWritable();
                const newStory = App.getNewStoryObject();
                newStory.meta.title = projectName;
                await writable.write(JSON.stringify(newStory, null, 2));
                await writable.close();

                App.state.projectDirectoryHandle = projectHandle;
                App.state.storyData = newStory;
                App.state.pendingAssetCopies.clear();
                App.modals.hideAll(); 
                App.ui.enableEditor(true);
                App.setDirty(false);
                App.ui.updateMetaInputs();
                App.ui.invalidateNavViews();
                App.ui.setViewMode(App.state.currentNavView);
                App.ui.selectScene('start');
                App.ui.showNotification(`Project '${projectName}' created successfully!`);

            } catch (err) { 
                if (err.name === 'SecurityError') {
                    return App.ui.showNotification("This feature is not available in the current environment (e.g., a sandboxed iframe).\nPlease run this file from a local server or open it directly in a compatible browser (like Chrome or Edge).");
                }
                if (err.name !== 'AbortError') { 
                    console.error(err); 
                    App.ui.showNotification('Could not create the project.'); 
                } 
            }
        },

        async openProject(dirHandle = null) {
            App.ui.cursor.wait();
            try {
                App.player.stop();
                document.getElementById('scene-search-input').value = '';
                if (App.state.missingAssetWarnings) App.state.missingAssetWarnings.clear();
                
                if (!dirHandle) {
                    dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
                }

                let storyFileHandle;
                let storyData;

                try {
                    storyFileHandle = await dirHandle.getFileHandle('story.json');
                    const file = await storyFileHandle.getFile();
                    const fileContent = await file.text();

                    if (fileContent.trim() === '') {
                        console.warn("story.json is empty. Initializing with default structure.");
                        storyData = App.getNewStoryObject();
                        storyData.meta.title = dirHandle.name;
                    } else {
                        try {
                            storyData = JSON.parse(fileContent);
                        } catch (e) {
                            console.error("JSON Parsing Error in story.json:", e);
                            App.ui.showNotification(`<b>Error Opening Project:</b><br>The 'story.json' file is malformed and could not be read.<br><br><i>Details: ${e.message}</i>`);
                            return;
                        }
                    }
                } catch (e) {
                    if (e.name === 'NotFoundError') {
                        console.log("story.json not found. Creating a new project structure in the selected directory.");
                        storyData = App.getNewStoryObject();
                        storyData.meta.title = dirHandle.name;
                    } else {
                        throw e; // Re-throw other errors
                    }
                }
                // Validate & sanitize
                console.log("Validating and sanitizing project data...");
                const result = App.io.validateProjectData(storyData, { autofix: false });
                if (!result.ok && result.errors.length) {
                    App.ui.showNotification(`<b>Error Opening Project:</b><br>${result.errors.join('<br>')}`);
                    return;
                }
                storyData = result.data;

                await dirHandle.getDirectoryHandle('images', { create: true });
                await dirHandle.getDirectoryHandle('sounds', { create: true });

                App.state.storyData = storyData;
                App.state.projectDirectoryHandle = dirHandle;
                App.state.pendingAssetCopies.clear();
                App.modals.hideAll();
                App.ui.enableEditor(true);
                App.setDirty(false);
                App.ui.updateMetaInputs();
                App.ui.invalidateNavViews();
                App.ui.setViewMode(App.state.currentNavView);
                App.ui.selectScene(App.state.storyData.meta.startSceneId);

                let finalNotification = `Project '${App.state.storyData.meta.title}' loaded successfully!`;
                if (result.warnings && result.warnings.length) {
                    finalNotification += `<br><br><b>Warnings:</b><br>` + result.warnings.map(w => `• ${w}`).join('<br>');
                }
                App.ui.showNotification(finalNotification);

                // Show summarized missing assets shortly after initial render (if any collected)
                setTimeout(() => {
                    try {
                        const missing = App.state.missingAssetWarnings ? Array.from(App.state.missingAssetWarnings) : [];
                        if (missing.length > 0) {
                            const preview = missing.slice(0, 10).map(p => `• ${p}`).join('<br>');
                            const more = missing.length > 10 ? `<br>...and ${missing.length - 10} more.` : '';
                            App.ui.showNotification(`<b>Missing Assets Detected:</b><br>${preview}${more}`);
                        }
                    } catch {}
                }, 500);

            } catch (err) { 
                if (err.name === 'SecurityError') {
                    App.ui.showNotification("This feature is not available in the current environment (e.g., a sandboxed iframe).\nPlease run this file from a local server or open it directly in a compatible browser (like Chrome or Edge).");
                } else if (err.name !== 'AbortError') { 
                    console.error("Failed to open project:", err); 
                    App.ui.showNotification('A critical error occurred while opening the project. Check the console for details.'); 
                } 
            } finally {
                App.ui.cursor.default();
            }
        },
        
        async saveProject() {
            App.ui.cursor.wait();
            try {
                if (!App.state.projectDirectoryHandle) { App.ui.showNotification("No project is open."); return; }
                if (App.elements['editor-container'].style.display !== 'none') {
                    App.editor.saveCurrentScene(false);
                }
                
                if (App.state.pendingAssetCopies.size > 0) {
                    for (const [relativePath, fileObject] of App.state.pendingAssetCopies.entries()) {
                        const pathParts = relativePath.split('/');
                        const fileName = pathParts.pop();
                        let currentHandle = App.state.projectDirectoryHandle;
                        for (const part of pathParts) {
                            currentHandle = await currentHandle.getDirectoryHandle(part, { create: true });
                        }
                        const fileHandle = await currentHandle.getFileHandle(fileName, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(fileObject);
                        await writable.close();
                    }
                    console.log(`Copied ${App.state.pendingAssetCopies.size} new asset(s) to the project folder.`);
                    App.state.pendingAssetCopies.clear();
                }

                const storyFileHandle = await App.state.projectDirectoryHandle.getFileHandle('story.json', { create: true });
                const writable = await storyFileHandle.createWritable();
                await writable.write(JSON.stringify(App.state.storyData, null, 2));
                await writable.close();
                
                App.setDirty(false);
                console.log("Project saved successfully!");
                App.ui.showNotification("Project saved successfully!");

            } catch (err) { 
                console.error(err); 
                App.ui.showNotification("Failed to save project. Check the console for errors."); 
            } finally {
                App.ui.cursor.default();
            }
        },
        
        async getFormattedPlayerHTML(isForExport = false) {
            const storyData = JSON.parse(JSON.stringify(App.state.storyData));
            let storyJsonString;

            if (isForExport) {
                storyJsonString = JSON.stringify(storyData, null, 2);
            } else { 
                const assetPaths = new Set();
                Object.values(storyData.scenes).forEach(scene => {
                    if (scene.image) assetPaths.add(scene.image);
                    if (scene.ambienceSound) assetPaths.add(scene.ambienceSound);
                });
                if(storyData.meta.styles['--music-path']) assetPaths.add(storyData.meta.styles['--music-path']);
                if(storyData.meta.styles['--screen-bg-image']) assetPaths.add(storyData.meta.styles['--screen-bg-image']);
                if(storyData.meta.styles['--container-bg-image']) assetPaths.add(storyData.meta.styles['--container-bg-image']);

                const assetDataUrls = {};
                for (const path of assetPaths) {
                    assetDataUrls[path] = await App.io.getAssetDataUrl(path);
                }

                Object.values(storyData.scenes).forEach(scene => {
                    if (scene.image && assetDataUrls[scene.image]) scene.image = assetDataUrls[scene.image];
                    if (scene.ambienceSound && assetDataUrls[scene.ambienceSound]) scene.ambienceSound = assetDataUrls[scene.ambienceSound];
                });
                if(storyData.meta.styles['--music-path'] && assetDataUrls[storyData.meta.styles['--music-path']]) storyData.meta.styles['--music-path'] = assetDataUrls[storyData.meta.styles['--music-path']];
                if(storyData.meta.styles['--screen-bg-image'] && assetDataUrls[storyData.meta.styles['--screen-bg-image']]) storyData.meta.styles['--screen-bg-image'] = assetDataUrls[storyData.meta.styles['--screen-bg-image']];
                if(storyData.meta.styles['--container-bg-image'] && assetDataUrls[storyData.meta.styles['--container-bg-image']]) storyData.meta.styles['--container-bg-image'] = assetDataUrls[storyData.meta.styles['--container-bg-image']];
                
                storyJsonString = JSON.stringify(storyData);
            }

            const playerScript = `
        <script>
            document.addEventListener('DOMContentLoaded', () => {
                const storyData = ${storyJsonString};
                const sceneImage = document.getElementById('scene-image'), sceneText = document.getElementById('scene-text'), choicesContainer = document.getElementById('choices-container'), ambiencePlayer = document.getElementById('ambience-player'), musicPlayer = document.getElementById('music-player'), playerMenuBtn = document.getElementById('player-menu-btn'), playerMenuModal = document.getElementById('player-menu-modal'), aboutModal = document.getElementById('about-modal'), gameContainer = document.getElementById('game-container'), contentContainer = document.getElementById('content-container');
                let currentSceneId, currentAmbienceSrc = '', currentMusicSrc = '';
                let typewriterState = { intervalId: null, skipListener: null };
                
                const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                const isAndroid = /android/i.test(navigator.userAgent);
                const clickEvent = isTouchDevice ? 'touchend' : 'click';

                function bindEvent(element, handler) {
                    if(!element) return;
                    element.addEventListener(clickEvent, (e) => {
                        if (isTouchDevice) e.preventDefault();
                        handler(e);
                    });
                }

                function isStorageAvailable() {
                    try {
                        const storage = window.localStorage;
                        const x = '__storage_test__';
                        storage.setItem(x, x);
                        storage.removeItem(x);
                        return true;
                    } catch (e) {
                        return false;
                    }
                }

                const storageAvailable = isStorageAvailable();
                
                function linkify(text) {
                    if (!text) return '';
                    const urlRegex = /(\\b(https?|ftp|file):\\/\\/[-A-Z0-9+&@#\\/%?=~_|!:,.;]*[-A-Z0-9+&@#\\/%=~_|])/ig;
                    return text.replace(urlRegex, function(url) {
                        return '<a href="' + url + '" target="_blank" rel="noopener noreferrer">' + url + '</a>';
                    });
                }

                function showModal(modal) { modal.style.display = 'flex'; setTimeout(() => modal.classList.add('visible'), 10); }
                function hideModal(modal) { modal.classList.remove('visible'); setTimeout(() => modal.style.display = 'none', 300); }

                function setupMenu() {
                    const saveBtn = document.getElementById('save-btn');
                    const loadBtn = document.getElementById('load-btn');
                    const fontSizeSlider = document.getElementById('font-size-slider');
                    const soundToggleBtn = document.getElementById('player-sound-toggle-btn');
                    const closeBtn = document.getElementById('player-close-btn');
                    const volumeSlider = document.getElementById('volume-slider');
                    const ambienceVolumeSlider = document.getElementById('ambience-volume-slider');

                    bindEvent(playerMenuBtn, () => showModal(playerMenuModal));
                    bindEvent(playerMenuModal, (e) => { if (e.target === playerMenuModal) hideModal(playerMenuModal); });
                    bindEvent(playerMenuModal.querySelector('.player-modal-close'), () => hideModal(playerMenuModal));
                    bindEvent(aboutModal.querySelector('.player-modal-close'), () => hideModal(aboutModal));

                    bindEvent(document.getElementById('about-btn'), () => { hideModal(playerMenuModal); showModal(aboutModal); });
                    bindEvent(document.getElementById('restart-btn'), () => { if (storageAvailable) { localStorage.removeItem('cyoa-save-' + storyData.meta.title); } renderScene(storyData.meta.startSceneId); hideModal(playerMenuModal); });
                    bindEvent(document.getElementById('fullscreen-btn'), () => { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(e => console.warn(e)); } else { if(document.exitFullscreen) document.exitFullscreen(); } });
                    
                    bindEvent(closeBtn, () => {
                        if (window.top === window.self) {
                            if (document.fullscreenElement) document.exitFullscreen();
                            window.close();
                        } else {
                            document.body.innerHTML = '<div id="exit-message" style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; text-align: center; font-size: 1.2em; color: #f0f0f0;"><p>Thanks for playing!</p><p>You can now close this window.</p></div>';
                        }
                    });

                    bindEvent(soundToggleBtn, function() {
                        const isMuted = !musicPlayer.muted;
                        musicPlayer.muted = isMuted;
                        ambiencePlayer.muted = isMuted;
                        soundToggleBtn.querySelector('.icon-on').style.display = isMuted ? 'none' : 'block';
                        soundToggleBtn.querySelector('.icon-off').style.display = isMuted ? 'block' : 'none';
                    });

                    if (!storageAvailable) {
                        saveBtn.disabled = true;
                        loadBtn.disabled = true;
                        saveBtn.title = "Saving/Loading is disabled when running from a local file.";
                        loadBtn.title = "Saving/Loading is disabled when running from a local file.";
                    } else {
                        bindEvent(saveBtn, () => { localStorage.setItem('cyoa-save-' + storyData.meta.title, currentSceneId); alert('Progress saved!'); hideModal(playerMenuModal); });
                        bindEvent(loadBtn, () => { const savedId = localStorage.getItem('cyoa-save-' + storyData.meta.title); if (savedId && storyData.scenes[savedId]) { renderScene(savedId); } else { alert('No save data found.'); } hideModal(playerMenuModal); });
                    }
                    
                    const savedMusicVol = storageAvailable ? localStorage.getItem('cyoa-music-volume-' + storyData.meta.title) : null;
                    const defaultMusicVol = storyData.meta.styles['--music-volume'] || '0.4';
                    volumeSlider.value = savedMusicVol !== null ? savedMusicVol : defaultMusicVol;
                    musicPlayer.volume = volumeSlider.value;
                    volumeSlider.addEventListener('input', function() {
                        musicPlayer.volume = this.value;
                        if (storageAvailable) localStorage.setItem('cyoa-music-volume-' + storyData.meta.title, this.value);
                    });

                    const savedAmbienceVol = storageAvailable ? localStorage.getItem('cyoa-ambience-volume-' + storyData.meta.title) : null;
                    const defaultAmbienceVol = storyData.meta.styles['--ambience-volume'] || '0.4';
                    ambienceVolumeSlider.value = savedAmbienceVol !== null ? savedAmbienceVol : defaultAmbienceVol;
                    ambiencePlayer.volume = ambienceVolumeSlider.value;
                    ambienceVolumeSlider.addEventListener('input', function() {
                        ambiencePlayer.volume = this.value;
                        if (storageAvailable) localStorage.setItem('cyoa-ambience-volume-' + storyData.meta.title, this.value);
                    });
                    
                    function applyFontSize(size) {
                        gameContainer.style.fontSize = size + 'px';
                        if(fontSizeSlider) fontSizeSlider.value = size;
                    }

                    const savedSize = storageAvailable ? localStorage.getItem('cyoa-fontsize-' + storyData.meta.title) : null;
                    if (savedSize) {
                        applyFontSize(savedSize);
                    } else if (isAndroid) {
                        applyFontSize(12); 
                    }

                    if(fontSizeSlider) {
                        fontSizeSlider.addEventListener('input', function() {
                            applyFontSize(this.value);
                            if (storageAvailable) { localStorage.setItem('cyoa-fontsize-' + storyData.meta.title, this.value); }
                        });
                    }

                    document.getElementById('about-title').textContent = storyData.meta.title;
                    document.getElementById('about-creator').textContent = storyData.meta.creatorName ? 'By ' + storyData.meta.creatorName : '';
                    document.getElementById('about-text').innerHTML = linkify(storyData.meta.aboutText);
                }

                function setupGlobalStyles() {
                    const musicPath = storyData.meta.styles['--music-path'] || '';
                    if (musicPath !== currentMusicSrc) {
                        currentMusicSrc = musicPath;
                        musicPlayer.src = musicPath;
                        if (musicPath) {
                            musicPlayer.play().catch(e=>console.log("Music autoplay blocked by browser."));
                        } else {
                            musicPlayer.pause();
                        }
                    }
                    
                    const startAudioOnFirstInteraction = () => {
                        if (musicPlayer.src && musicPlayer.paused) {
                            musicPlayer.play().catch(e => console.warn("Music could not be started on interaction.", e));
                        }
                        if (ambiencePlayer.src && ambiencePlayer.paused) {
                            ambiencePlayer.play().catch(e => console.warn("Ambience could not be started on interaction.", e));
                        }
                        document.body.removeEventListener('click', startAudioOnFirstInteraction);
                        document.body.removeEventListener('touchend', startAudioOnFirstInteraction);
                    };
                    document.body.addEventListener('click', startAudioOnFirstInteraction);
                    document.body.addEventListener('touchend', startAudioOnFirstInteraction);
                }
                
                function typeWriter(text, choices) {
                    let i = 0;
                    choicesContainer.innerHTML = '';
                    
                    const tempChoices = document.createElement('div');
                    (choices || []).forEach(choice => {
                        const button = document.createElement('button');
                        button.className = 'choice-btn';
                        button.textContent = choice.text;
                        tempChoices.appendChild(button);
                    });
                    choicesContainer.appendChild(tempChoices);
                    sceneText.textContent = text;
                    const containerHeight = contentContainer.offsetHeight;
                    choicesContainer.innerHTML = '';
                    sceneText.innerHTML = '';
                    contentContainer.style.minHeight = containerHeight + 'px';

                    function showChoices() {
                        while (choicesContainer.firstChild) { choicesContainer.removeChild(choicesContainer.firstChild); }
                        (choices || []).forEach((choice, index) => {
                            const button = document.createElement('button');
                            button.textContent = choice.text;
                            button.className = 'choice-btn fade-in';
                            button.style.animationDelay = (index * 0.2) + 's';
                            bindEvent(button, (e) => { e.stopPropagation(); renderScene(choice.target); });
                            choicesContainer.appendChild(button);
                        });
                    }
                    
                    if (typewriterState.intervalId) clearInterval(typewriterState.intervalId);
                    if (typewriterState.skipListener) gameContainer.removeEventListener(clickEvent, typewriterState.skipListener);
                    
                    const skipTyping = () => {
                        clearInterval(typewriterState.intervalId);
                        typewriterState.intervalId = null;
                        sceneText.innerHTML = text;
                        contentContainer.style.minHeight = '';
                        showChoices();
                        gameContainer.removeEventListener(clickEvent, typewriterState.skipListener);
                        typewriterState.skipListener = null;
                    };
                    typewriterState.skipListener = skipTyping;
                    bindEvent(gameContainer, skipTyping);
                    
                    typewriterState.intervalId = setInterval(() => {
                        if (i < text.length) {
                            sceneText.innerHTML += text.charAt(i);
                            i++;
                        } else {
                           skipTyping();
                        }
                    }, 30);
                }

                function renderScene(sceneId) {
                    try {
                        currentSceneId = sceneId;
                        const scene = storyData.scenes[sceneId];
                        if (!scene) { sceneText.textContent = 'Error: Scene "' + sceneId + '" not found.'; return; }
                        
                        if (storyData.meta.styles['--typewriter-effect'] === 'on') {
                            typeWriter(scene.text, scene.choices);
                        } else {
                            contentContainer.style.minHeight = '';
                            sceneText.textContent = scene.text;
                            choicesContainer.innerHTML = '';
                            (scene.choices || []).forEach(choice => { 
                                const button = document.createElement('button'); 
                                button.textContent = choice.text; 
                                button.className = 'choice-btn'; 
                                bindEvent(button, () => renderScene(choice.target)); 
                                choicesContainer.appendChild(button); 
                            });
                        }
                        
                        const layout = storyData.meta.layout;
                        const imageContainer = document.getElementById('image-container');
                        const imageUrl = scene.image;
                        const globalScreenBgUrl = storyData.meta.styles['--screen-bg-image'];
                        
                        document.body.className = layout;
                        gameContainer.className = layout;

                        if (layout === 'layout-image-as-bg') {
                            if (imageUrl) {
                                document.body.style.backgroundImage = \`url('\${imageUrl}')\`;
                            } else {
                                document.body.style.backgroundImage = globalScreenBgUrl ? \`url('\${globalScreenBgUrl}')\` : 'none';
                            }
                        } else {
                            document.body.style.backgroundImage = globalScreenBgUrl ? \`url('\${globalScreenBgUrl}')\` : 'none';
                            if (imageUrl) {
                                sceneImage.src = imageUrl;
                                imageContainer.style.display = 'block';
                            } else {
                                imageContainer.style.display = 'none';
                            }
                        }
                        
                        ambiencePlayer.loop = scene.ambienceLoop ?? true;
                        const soundUrl = scene.ambienceSound || '';
                        if (soundUrl !== currentAmbienceSrc) {
                            currentAmbienceSrc = soundUrl;
                            ambiencePlayer.src = soundUrl;
                        }
                        
                        if (soundUrl && ambiencePlayer.paused) {
                            ambiencePlayer.play().catch(e => console.warn("Ambience autoplay blocked."));
                        } else if (!soundUrl) {
                            ambiencePlayer.pause();
                        }
                    } catch(e) {
                        console.error("Error rendering scene:", e);
                        sceneText.textContent = "An error occurred. Check the console for details.";
                    }
                }
                
                function preloadAssets(assets) {
                    const promises = assets.filter(Boolean).map(url => {
                        return new Promise((resolve, reject) => {
                            const isImage = /\\.(jpg|jpeg|png|gif|webp)$/i.test(url) || url.startsWith('data:image');
                            const isAudio = /\\.(mp3|wav|ogg|m4a)$/i.test(url) || url.startsWith('data:audio');

                            if (isImage) {
                                const img = new Image();
                                img.onload = () => resolve(url);
                                img.onerror = () => reject(url);
                                img.src = url;
                            } else if (isAudio) {
                                const audio = new Audio();
                                audio.oncanplaythrough = () => resolve(url);
                                audio.onerror = () => reject(url);
                                audio.src = url;
                            } else {
                                resolve(url); // Not a preloadable asset type, resolve immediately
                            }
                        });
                    });
                    return Promise.all(promises);
                }

                async function main() {
                    const loader = document.getElementById('loading-overlay');
                    setupMenu();
                    document.title = storyData.meta.title || 'Choose Your Own Adventure';
                    
                    const startSceneId = storyData.meta.startSceneId;
                    const startScene = storyData.scenes[startSceneId];
                    const initialAssets = [
                        startScene ? startScene.image : null,
                        startScene ? startScene.ambienceSound : null,
                        storyData.meta.styles['--music-path'],
                        storyData.meta.styles['--screen-bg-image'],
                        storyData.meta.styles['--container-bg-image']
                    ];

                    try {
                        await preloadAssets(initialAssets);
                    } catch (failedUrl) {
                        console.warn('Could not load an initial asset: ' + failedUrl + '. Starting anyway.');
                    } finally {
                        if(loader) loader.style.display = 'none';
                        setupGlobalStyles();
                        
                        let startingScene = startSceneId;
                        if (storageAvailable) {
                            const savedSceneId = localStorage.getItem('cyoa-save-' + storyData.meta.title);
                            if (savedSceneId && storyData.scenes[savedSceneId]) {
                                startingScene = savedSceneId;
                            }
                        }
                        renderScene(startingScene);
                    }
                }

                main();
            });
        <\/script>`;

            return document.getElementById('player-template').innerHTML
                .replace(/__STORY_TITLE__/g, storyData.meta.title || 'My Story')
                .replace(/__LAYOUT_CLASS__/g, storyData.meta.layout)
                .replace('__CUSTOM_STYLES__', App.styles.generateCSS(storyData.meta.styles))
                .replace('__PLAYER_SCRIPT__', playerScript);
        },

        async exportProjectZip() {
            if (!App.state.projectDirectoryHandle) { App.ui.showNotification("Please open a project to export."); return; }
            App.editor.saveCurrentScene(false);
            App.ui.showNotification("Collecting used assets and preparing export...");

            const zip = new window.JSZip();
            
            const playerHtml = await App.io.getFormattedPlayerHTML(true);
            zip.file("index.html", playerHtml);

            const usedAssetPaths = new Set();
            Object.values(App.state.storyData.scenes).forEach(scene => {
                if (scene.image) usedAssetPaths.add(scene.image);
                if (scene.ambienceSound) usedAssetPaths.add(scene.ambienceSound);
            });
            const metaStyles = App.state.storyData.meta.styles;
            if (metaStyles['--screen-bg-image']) usedAssetPaths.add(metaStyles['--screen-bg-image']);
            if (metaStyles['--container-bg-image']) usedAssetPaths.add(metaStyles['--container-bg-image']);
            if (metaStyles['--music-path']) usedAssetPaths.add(metaStyles['--music-path']);
            
            const assetPromises = Array.from(usedAssetPaths).map(async (path) => {
                try {
                    const file = await App.io.getAssetFile(path);
                    if (file) {
                        zip.file(path, file);
                    }
                } catch(err) {
                     console.warn(`Could not add asset "${path}" to zip:`, err);
                }
            });

            await Promise.all(assetPromises);

            zip.generateAsync({ type: "blob" }).then(content => {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(content);
                a.download = `${App.state.storyData.meta.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_export.zip`;
                a.click();
                URL.revokeObjectURL(a.href);
                App.ui.showNotification("Project exported successfully!");
            }).catch(err => {
                console.error("ZIP Export failed:", err); 
                App.ui.showNotification("Could not export project. Check console for details.");
            });
        },
        
        async exportProjectExe() {
            if (!App.state.projectDirectoryHandle) { 
                App.ui.showNotification("Please open a project to export."); 
                return; 
            }
            App.editor.saveCurrentScene(false);
            App.ui.showNotification("Preparing standalone Windows build (ZIP)... This may take a moment.");

            const safeTitle = App.state.storyData.meta.title.replace(/[^a-z0-9]/gi, '_').toLowerCase();

            // 1) Ask user to select their NW.js directory (contains nw.exe, dlls, locales/)
            let nwDirHandle;
            try {
                nwDirHandle = await window.showDirectoryPicker({ mode: 'read' });
            } catch (e) {
                App.ui.showNotification("Export cancelled or directory picker unavailable.");
                return;
            }

            // Helper: recursively add directory contents to JSZip
            async function addDirectoryToZip(dirHandle, zipFolder) {
                for await (const [name, handle] of dirHandle.entries()) {
                    if (handle.kind === 'file') {
                        const file = await handle.getFile();
                        // Skip original nw.exe; we will add it back renamed to <safeTitle>.exe
                        if (name.toLowerCase() === 'nw.exe') continue;
                        zipFolder.file(name, file);
                    } else if (handle.kind === 'directory') {
                        const sub = zipFolder.folder(name);
                        await addDirectoryToZip(handle, sub);
                    }
                }
            }

            // 2) Create main ZIP and copy NW runtime into it
            const mainZip = new window.JSZip();
            await addDirectoryToZip(nwDirHandle, mainZip);

            // 3) Read nw.exe and add it renamed to <title>.exe
            try {
                const exeHandle = await nwDirHandle.getFileHandle('nw.exe');
                const exeFile = await exeHandle.getFile();
                mainZip.file(`${safeTitle}.exe`, exeFile);
            } catch (e) {
                App.ui.showNotification("Selected NW.js folder does not contain nw.exe.");
                return;
            }

            // 4) Build package.nw: app files (index.html + assets)
            //    Generate player HTML for export (with relative paths) and collect used assets.
            const appZip = new window.JSZip();
            const playerHtml = await App.io.getFormattedPlayerHTML(true);
            appZip.file('index.html', playerHtml);

            const usedAssetPaths = new Set();
            Object.values(App.state.storyData.scenes).forEach(scene => {
                if (scene.image) usedAssetPaths.add(scene.image);
                if (scene.ambienceSound) usedAssetPaths.add(scene.ambienceSound);
            });
            const metaStyles = App.state.storyData.meta.styles;
            if (metaStyles['--screen-bg-image']) usedAssetPaths.add(metaStyles['--screen-bg-image']);
            if (metaStyles['--container-bg-image']) usedAssetPaths.add(metaStyles['--container-bg-image']);
            if (metaStyles['--music-path']) usedAssetPaths.add(metaStyles['--music-path']);

            // Copy assets into package.nw with their same relative paths
            for (const path of usedAssetPaths) {
                try {
                    const file = await App.io.getAssetFile(path);
                    if (file) appZip.file(path, file);
                } catch {}
            }

            // Include a minimal package.json inside package.nw (optional but helpful)
            const packageJson = {
                name: safeTitle,
                main: "index.html",
                window: { title: App.state.storyData.meta.title, width: 1280, height: 720, resizable: true }
            };
            appZip.file('package.json', JSON.stringify(packageJson, null, 2));

            const packageNwBlob = await appZip.generateAsync({ type: 'blob', compression: 'DEFLATE' });
            mainZip.file('package.nw', packageNwBlob);

            // 5) Generate final ZIP and download
            const finalZipBlob = await mainZip.generateAsync({ type: 'blob', compression: 'DEFLATE' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(finalZipBlob);
            a.download = `${safeTitle}_windows_standalone.zip`;
            a.click();
            URL.revokeObjectURL(a.href);

            App.ui.showNotification("Standalone Windows build created. Unzip and run the EXE.");
        },
        
        async exportProjectExe() {
            if (!App.state.projectDirectoryHandle) { 
                App.ui.showNotification("Please open a project to export."); 
                return; 
            }
            App.editor.saveCurrentScene(false);
            App.ui.showNotification("Preparing EXE export... This may take a moment.");

            const zip = new window.JSZip();
            const safeTitle = App.state.storyData.meta.title.replace(/[^a-z0-9]/gi, '_').toLowerCase();

            // 1. Create package.json for NW.js
            const packageJson = {
                name: safeTitle,
                main: "index.html",
                window: {
                    title: App.state.storyData.meta.title,
                    width: 1280,
                    height: 720,
                    resizable: true
                }
            };
            zip.file("package.json", JSON.stringify(packageJson, null, 2));

            // 2. Generate and add index.html
            const playerHtml = await App.io.getFormattedPlayerHTML(true);
            zip.file("index.html", playerHtml);

            // 3. Collect and add all used assets
            const usedAssetPaths = new Set();
            Object.values(App.state.storyData.scenes).forEach(scene => {
                if (scene.image) usedAssetPaths.add(scene.image);
                if (scene.ambienceSound) usedAssetPaths.add(scene.ambienceSound);
            });
            const metaStyles = App.state.storyData.meta.styles;
            if (metaStyles['--screen-bg-image']) usedAssetPaths.add(metaStyles['--screen-bg-image']);
            if (metaStyles['--container-bg-image']) usedAssetPaths.add(metaStyles['--container-bg-image']);
            if (metaStyles['--music-path']) usedAssetPaths.add(metaStyles['--music-path']);

            const assetPromises = Array.from(usedAssetPaths).map(async (path) => {
                try {
                    const file = await App.io.getAssetFile(path);
                    if (file) {
                        zip.file(path, file);
                    }
                } catch(err) {
                     console.warn(`Could not add asset "${path}" to zip:`, err);
                }
            });
            await Promise.all(assetPromises);

            try {
                // 4. Generate the package zip blob
                const packageZipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE" });

                // 5. Fetch the NW.js binary
                const nwExeResponse = await fetch('./nwjs/nw.exe');
                if (!nwExeResponse.ok) throw new Error("NW.js binary not found.");
                const nwExeBlob = await nwExeResponse.blob();

                // 6. Concatenate blobs
                const finalExeBlob = new Blob([nwExeBlob, packageZipBlob]);

                // 7. Trigger download
                const a = document.createElement('a');
                a.href = URL.createObjectURL(finalExeBlob);
                a.download = `${safeTitle}.exe`;
                a.click();
                URL.revokeObjectURL(a.href);
                App.ui.showNotification("EXE exported successfully!");

            } catch (err) {
                console.error("EXE Export failed:", err);
                try {
                    const packageZipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE" });

                    let exeFile = null;

                    // Preferred: pick the nw.exe file directly
                    if (window.showOpenFilePicker) {
                        try {
                            const [handle] = await window.showOpenFilePicker({
                                multiple: false,
                                types: [{
                                    description: 'NW.js Executable',
                                    accept: { 'application/vnd.microsoft.portable-executable': ['.exe'] }
                                }]
                            });
                            const file = await handle.getFile();
                            if (file && file.name.toLowerCase() === 'nw.exe') {
                                exeFile = file;
                            }
                        } catch (e) {
                            // continue to next fallback
                        }
                    }

                    // Fallback: pick a directory and read nw.exe from it
                    if (!exeFile && window.showDirectoryPicker) {
                        try {
                            const nwDir = await window.showDirectoryPicker({ mode: 'read' });
                            const exeHandle = await nwDir.getFileHandle('nw.exe');
                            exeFile = await exeHandle.getFile();
                        } catch (e) {
                            // continue to next fallback
                        }
                    }

                    // Last-resort fallback: input[type=file]
                    if (!exeFile) {
                        exeFile = await new Promise((resolve) => {
                            const input = document.createElement('input');
                            input.type = 'file';
                            input.accept = '.exe';
                            input.style.display = 'none';
                            document.body.appendChild(input);
                            input.addEventListener('change', () => {
                                const file = input.files && input.files[0] ? input.files[0] : null;
                                document.body.removeChild(input);
                                if (file && file.name.toLowerCase() === 'nw.exe') {
                                    resolve(file);
                                } else {
                                    resolve(null);
                                }
                            });
                            input.click();
                        });
                    }

                    if (!exeFile) {
                        throw new Error('NW.js executable not provided.');
                    }

                    const finalExeBlob = new Blob([exeFile, packageZipBlob]);
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(finalExeBlob);
                    a.download = `${safeTitle}.exe`;
                    a.click();
                    URL.revokeObjectURL(a.href);
                    App.ui.showNotification("EXE exported successfully!");
                } catch (fallbackErr) {
                    console.error('Fallback EXE export failed:', fallbackErr);
                    App.ui.showNotification(`
                        EXE export failed. Could not find <code>nwjs/nw.exe</code>.<br><br>
                        Please ensure the <code>nwjs</code> folder from the Kinexus download is in the same directory as this HTML file, or select the <code>nw.exe</code> when prompted.
                    `);
                }
            }
        },

        async previewProject() {
            if (!App.state.projectDirectoryHandle) { App.ui.showNotification("Please open a project to preview."); return; }
            App.editor.saveCurrentScene(false);
            try {
                const playerHtml = await App.io.getFormattedPlayerHTML(false);
                const blob = new Blob([playerHtml], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                window.open(url, '_blank');
            } catch (err) { console.error("Preview failed:", err); App.ui.showNotification("Could not generate preview. Check console for details."); }
        },
        
        async getAssetDataUrl(path) {
            const file = await App.io.getAssetFile(path);
            if (!file) return null;
            
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        },

        async getAssetFile(path) {
            if (!path) return null;
            if (App.state.pendingAssetCopies.has(path)) {
                return App.state.pendingAssetCopies.get(path);
            }
            try {
                const pathParts = path.split('/');
                const fileName = pathParts.pop();
                let dirHandle = App.state.projectDirectoryHandle;
                for (const part of pathParts) {
                    dirHandle = await dirHandle.getDirectoryHandle(part);
                }
                const fileHandle = await dirHandle.getFileHandle(fileName);
                return await fileHandle.getFile();
            } catch (e) { 
                if (!App.state.missingAssetWarnings.has(path)) {
                    App.state.missingAssetWarnings.add(path);
                    console.warn(`Asset file not found in project: ${path}`);
                }
                return null; 
            }
        },
        
        exportData(type) {
            let data = {};
            let filename = `${type}.json`;
            switch(type) {
                case 'imagePrompts':
                    Object.values(App.state.storyData.scenes).forEach(scene => {
                        if (scene.imagePrompt) {
                            data[scene.id] = scene.imagePrompt;
                        }
                    });
                    break;
                default:
                    App.ui.showNotification(`Unknown data export type: ${type}`);
                    return;
            }
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            a.click();
            URL.revokeObjectURL(a.href);
        },
        async exportStandaloneWithOptions({ nwFolder = null, iconBlob = null, logCallback = () => {} } = {}) {
            if (!nwFolder) {
                throw new Error('NW.js folder not provided.');
            }
            logCallback('Starting EXE export process...');
            const safeTitle = App.state.storyData.meta.title.replace(/[^a-z0-9]/gi, '_').toLowerCase();

            logCallback(`Verifying selected NW.js folder...`);
            try {
                await nwFolder.getFileHandle('nw.exe');
                logCallback('-> nw.exe found. Looks good.');
            } catch {
                throw new Error('Selected folder does not contain nw.exe.');
            }
            
            async function addDirectoryToZip(dirHandle, zipFolder) {
                for await (const [name, handle] of dirHandle.entries()) {
                    if (handle.kind === 'file') {
                        const file = await handle.getFile();
                        if (name.toLowerCase() === 'nw.exe') continue;
                        zipFolder.file(name, file);
                    } else if (handle.kind === 'directory') {
                        const sub = zipFolder.folder(name);
                        await addDirectoryToZip(handle, sub);
                    }
                }
            }

            logCallback('Creating main application package...');
            const mainZip = new window.JSZip();
            logCallback('-> Copying NW.js runtime files (this may take a moment)...');
            await addDirectoryToZip(nwFolder, mainZip);

            const exeHandle = await nwFolder.getFileHandle('nw.exe');
            const exeFile = await exeHandle.getFile();
            mainZip.file(`${safeTitle}.exe`, exeFile);
            logCallback('-> Runtime copied.');

            logCallback('Creating game data package (package.nw)...');
            const appZip = new window.JSZip();
            const playerHtml = await App.io.getFormattedPlayerHTML(true);
            appZip.file('index.html', playerHtml);

            const usedAssetPaths = new Set();
            Object.values(App.state.storyData.scenes).forEach(scene => {
                if (scene.image) usedAssetPaths.add(scene.image);
                if (scene.ambienceSound) usedAssetPaths.add(scene.ambienceSound);
            });
            const metaStyles = App.state.storyData.meta.styles;
            if (metaStyles['--screen-bg-image']) usedAssetPaths.add(metaStyles['--screen-bg-image']);
            if (metaStyles['--container-bg-image']) usedAssetPaths.add(metaStyles['--container-bg-image']);
            if (metaStyles['--music-path']) usedAssetPaths.add(metaStyles['--music-path']);
            
            logCallback(`-> Found ${usedAssetPaths.size} assets to include.`);
            for (const path of usedAssetPaths) {
                try {
                    const f = await App.io.getAssetFile(path);
                    if (f) {
                        appZip.file(path, f);
                    }
                } catch (err) {
                    logCallback(`-> WARNING: Could not package asset '${path}'. It will be missing from the game.`);
                }
            }
            logCallback('-> All project assets added to package.');
            // ================================================================= //

            let iconPath = '';
            if (iconBlob) {
                logCallback('-> Processing window icon...');
                const pngBlob = await (async () => {
                    const bmp = await createImageBitmap(iconBlob);
                    const canvas = document.createElement('canvas');
                    canvas.width = 256; canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(bmp, 0, 0, 256, 256);
                    return await new Promise(res => canvas.toBlob(res, 'image/png'));
                })();
                iconPath = 'icon.png';
                appZip.file(iconPath, pngBlob);
                logCallback('-> Window icon added.');
            }

            const packageJson = {
                name: safeTitle,
                main: 'index.html',
                window: { title: App.state.storyData.meta.title, width: 1280, height: 720, resizable: true, icon: iconPath || undefined }
            };
            appZip.file('package.json', JSON.stringify(packageJson, null, 2));

            const packageNwBlob = await appZip.generateAsync({ type: 'blob', compression: 'DEFLATE' });
            mainZip.file('package.nw', packageNwBlob);
            logCallback('-> Game data package complete.');

            logCallback('Creating final ZIP file for download...');
            const finalZipBlob = await mainZip.generateAsync({ type: 'blob', compression: 'DEFLATE' });
            
            const a = document.createElement('a');
            a.href = URL.createObjectURL(finalZipBlob);
            a.download = `${safeTitle}_windows_standalone.zip`;
            a.click();
            URL.revokeObjectURL(a.href);
            logCallback('SUCCESS: Download initiated. Export complete!');
            logCallback('Unzip the downloaded file and run the .exe to play.');
        }
    },
    
    sceneList: {
        ICONS: {
            start: `<svg xmlns="http://www.w3.org/2000/svg" class="scene-card-icon icon-start" title="Start Scene" viewBox="0 0 16 16"><path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>`,
            audio: `<svg xmlns="http://www.w3.org/2000/svg" class="scene-card-icon icon-sound" title="Has Audio" viewBox="0 0 16 16"><path d="M9.707,2.293a1,1,0,0,0-1.414,0L4.6,6H2.5A1.5,1.5,0,0,0,1,7.5v1A1.5,1.5,0,0,0,2.5,10H4.6l3.69,3.707a1,1,0,0,0,1.414,0V2.293Z"/></svg>`,
            loop: `<svg xmlns="http://www.w3.org/2000/svg" class="scene-card-icon icon-sound" title="Audio Loops" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966a.25.25 0 0 1 0 .384l-2.36 1.966A.25.25 0 0 1 8 4.466z"/></svg>`,
            orphan: `<svg xmlns="http://www.w3.org/2000/svg" class="scene-card-icon icon-orphan" title="Orphan Scene" viewBox="0 0 16 16"><path d="M7.5 7.5V4h1v3.5h3.5v1H8.5V12h-1V8.5H4v-1h3.5z"/></svg>`,
            end: `<svg xmlns="http://www.w3.org/2000/svg" class="scene-card-icon icon-deadend" title="End of a Branch" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/></svg>`,
        },
        
        createCard(scene) {
            const card = document.createElement('div');
            card.className = 'scene-card';
            card.dataset.sceneId = scene.id;
            if (scene.id === App.state.currentSceneId) {
                card.classList.add('active');
            }
            card.onclick = () => App.ui.selectScene(scene.id);
            card.oncontextmenu = (e) => {
                e.preventDefault();
                App.state.contextSceneId = scene.id;
                const menu = App.elements['tree-context-menu'];
                menu.style.display = 'block'; menu.style.left = `${e.pageX}px`; menu.style.top = `${e.pageY}px`;
            };

            let iconsHTML = '';
            let orphanIconHTML = '';

            if (App.state.orphanSceneIds.has(scene.id)) {
                orphanIconHTML = this.ICONS.orphan;
            }
            if (scene.id === App.state.storyData.meta.startSceneId) {
                iconsHTML += this.ICONS.start;
            }
            if (scene.ambienceSound) {
                iconsHTML += this.ICONS.audio;
                if (scene.ambienceLoop !== false) iconsHTML += this.ICONS.loop;
            }
            const choiceCount = scene.choices?.length || 0;
            if (choiceCount > 0) {
                iconsHTML += `<div class="choice-count-icon" title="${choiceCount} choices">${choiceCount}</div>`;
            } else {
                iconsHTML += this.ICONS.end;
            }

            card.innerHTML = `
                <div class="scene-card-thumbnail">
                    ${scene.image ? `<img data-src-path="${scene.image}" alt="Thumbnail for ${scene.id}">` : `<span>No Image</span>`}
                </div>
                <div class="scene-card-content">
                    <div class="scene-card-header">
                        <div class="scene-card-id">${scene.id}</div>
                        <div class="scene-card-icons">${orphanIconHTML}${iconsHTML}</div>
                    </div>
                    <div class="scene-card-text">${scene.text ? scene.text.split('\n')[0] : '...'}</div>
                </div>
            `;
            return card;
        },

        render(filterTerm = '') {
            if (!App.state.storyData.meta) {
                return;
            }
            App.tree.findOrphans();
            const container = App.elements['scene-list-view'];
            container.innerHTML = '';
            
            const searchTerm = filterTerm.trim().toLowerCase();
            let scenes = Object.values(App.state.storyData.scenes || {});
            
            if (searchTerm) {
                scenes = scenes.filter(scene => 
                    scene.id.toLowerCase().includes(searchTerm) || 
                    (scene.text && scene.text.toLowerCase().includes(searchTerm))
                );
            }
            
            const sortMethod = App.elements['scene-list-sort'].value;
            scenes.sort((a, b) => {
                if (sortMethod === 'modified') {
                    return (b.lastModified || 0) - (a.lastModified || 0);
                }
                return a.id.localeCompare(b.id);
            });

            if (scenes.length === 0) {
                container.innerHTML = `<li style="padding:10px;">No scenes found.</li>`;
                return;
            }
            
            const connectedScenes = scenes.filter(s => !App.state.orphanSceneIds.has(s.id));
            const orphanScenes = scenes.filter(s => App.state.orphanSceneIds.has(s.id));

            if (connectedScenes.length > 0) {
                const header = document.createElement('div');
                header.className = 'scene-list-group-header';
                header.textContent = 'Connected Scenes';
                container.appendChild(header);
                connectedScenes.forEach(scene => container.appendChild(this.createCard(scene)));
            }

            if (orphanScenes.length > 0) {
                 const header = document.createElement('div');
                header.className = 'scene-list-group-header';
                header.textContent = 'Orphan Scenes';
                container.appendChild(header);
                orphanScenes.forEach(scene => container.appendChild(this.createCard(scene)));
            }

            const imgs = Array.from(container.querySelectorAll('img[data-src-path]'));
            imgs.forEach(async img => {
                const path = img.dataset.srcPath;
                const url = await App.io.getAssetDataUrl(path);
                if (url) {
                    img.src = url;
                } else {
                    const parent = img.parentElement;
                    parent.innerHTML = `<span>Invalid Path</span>`;
                }
            });
        },
    },

    tree: {
        colorCache: new Map(),
        nextHue: Math.random() * 360,
        getColorForScene(sceneId) {
            if (this.colorCache.has(sceneId)) {
                return this.colorCache.get(sceneId);
            }
            const goldenRatioConjugate = 0.61803398875;
            this.nextHue += goldenRatioConjugate;
            this.nextHue %= 1;
            const hue = this.nextHue * 360;
            const saturation = 45;
            const lightness = 60;
            const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            this.colorCache.set(sceneId, color);
            return color;
        },
        ICONS: {
            start: `<svg class="icon-start" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>`,
            image: `<svg class="icon-image" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/><path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/></svg>`,
            sound: `<svg class="icon-sound" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M9.707,2.293a1,1,0,0,0-1.414,0L4.6,6H2.5A1.5,1.5,0,0,0,1,7.5v1A1.5,1.5,0,0,0,2.5,10H4.6l3.69,3.707a1,1,0,0,0,1.414,0V2.293Z"/></svg>`,
            deadEnd: `<svg class="icon-deadend" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/></svg>`,
            orphan: `<svg class="icon-orphan" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M7.5 7.5V4h1v3.5h3.5v1H8.5V12h-1V8.5H4v-1h3.5z"/></svg>`,
        },

        findOrphans() {
            if (!App.state.storyData || !App.state.storyData.scenes) {
                App.state.orphanSceneIds.clear();
                return;
            }
            const scenes = App.state.storyData.scenes;
            const allSceneIds = new Set(Object.keys(scenes));
            const reachableSceneIds = new Set();
            const startSceneId = App.state.storyData.meta.startSceneId;
            if (startSceneId && scenes[startSceneId]) {
                const queue = [startSceneId];
                while (queue.length > 0) {
                    const current = queue.shift();
                    if (reachableSceneIds.has(current)) continue;
                    reachableSceneIds.add(current);
                    const scene = scenes[current];
                    if (scene && scene.choices) {
                        scene.choices.forEach(choice => {
                            if (choice.target && allSceneIds.has(choice.target) && !reachableSceneIds.has(choice.target)) {
                                queue.push(choice.target);
                            }
                        });
                    }
                }
            }
            App.state.orphanSceneIds.clear();
            allSceneIds.forEach(id => {
                if (!reachableSceneIds.has(id)) {
                    App.state.orphanSceneIds.add(id);
                }
            });
        },

        render(filterTerm = '') {
            if (!App.state.storyData.meta) {
                return;
            }
            this.findOrphans();
            const treeView = App.elements['tree-view'];
            treeView.innerHTML = '';
            
            const searchTerm = filterTerm.trim().toLowerCase();

            if (searchTerm) {
                const matchingIds = Object.keys(App.state.storyData.scenes || {}).filter(id => 
                    id.toLowerCase().includes(searchTerm) || 
                    (App.state.storyData.scenes[id].text && App.state.storyData.scenes[id].text.toLowerCase().includes(searchTerm))
                );
                
                if (matchingIds.length > 0) {
                    const list = document.createElement('ul');
                    matchingIds.sort().forEach(id => {
                        const li = document.createElement('li');
                        const sceneNode = document.createElement('div');
                        sceneNode.className = 'scene-node';
                        sceneNode.dataset.sceneId = id; 
                        if (id === App.state.currentSceneId) sceneNode.classList.add('active');
                        
                        const text = document.createElement('span');
                        text.textContent = id;
                        sceneNode.appendChild(text);

                        sceneNode.onclick = () => {
                            document.getElementById('scene-search-input').value = '';
                            App.ui.selectScene(id);
                        };
                        li.appendChild(sceneNode);
                        list.appendChild(li);
                    });
                    treeView.appendChild(list);
                } else {
                    treeView.innerHTML = `<li>No results found.</li>`;
                }
                return;
            }

            const collapsedState = {};
            treeView.querySelectorAll('li[data-scene-id]').forEach(li => { if (li.dataset.collapsed === 'true') collapsedState[li.dataset.sceneId] = true; });

            const scenes = App.state.storyData.scenes;
            const { startSceneId } = App.state.storyData.meta;
            if (!startSceneId || !scenes[startSceneId]) {
                treeView.innerHTML = `<li>No start scene set. Set a start scene to view the main story map.</li>`;
            } else {
                const rootUl = document.createElement('ul');
                const visited = new Set();
                this.buildNode(startSceneId, rootUl, [], collapsedState, visited);
                treeView.appendChild(rootUl);
            }

            if (App.state.orphanSceneIds.size > 0) {
                const orphanHeader = document.createElement('h3');
                orphanHeader.textContent = 'Orphan Scenes';
                orphanHeader.style.marginTop = '20px';
                orphanHeader.style.borderBottom = 'none';
                treeView.appendChild(orphanHeader);

                const orphanTargets = new Set();
                App.state.orphanSceneIds.forEach(id => {
                    const scene = scenes[id];
                    if (scene && scene.choices) {
                        scene.choices.forEach(choice => {
                            if (choice.target && App.state.orphanSceneIds.has(choice.target)) {
                                orphanTargets.add(choice.target);
                            }
                        });
                    }
                });

                const orphanRoots = Array.from(App.state.orphanSceneIds).filter(id => !orphanTargets.has(id)).sort();

                const orphanUl = document.createElement('ul');
                const visitedOrphans = new Set();
                orphanRoots.forEach(rootId => {
                    this.buildNode(rootId, orphanUl, [], collapsedState, visitedOrphans);
                });
                treeView.appendChild(orphanUl);
            }
        },
        buildNode(sceneId, parentElement, path, collapsedState, visitedSet) {
            const scene = App.state.storyData.scenes[sceneId];
            if (!scene) { parentElement.innerHTML += `<li><span style="color:red">Broken Link: ${sceneId}</span></li>`; return; }
            if (visitedSet && visitedSet.has(sceneId)) {
                const li = document.createElement('li');
                li.dataset.sceneId = sceneId;
                const sceneNode = document.createElement('div');
                sceneNode.className = 'scene-node';
                sceneNode.dataset.sceneId = sceneId;
                const text = document.createElement('span');
                text.className = 'scene-node-text';
                text.textContent = `${sceneId} (already shown)`;
                sceneNode.appendChild(text);
                sceneNode.onclick = () => App.ui.selectScene(sceneId);
                li.appendChild(sceneNode);
                parentElement.appendChild(li);
                return;
            }
            if (visitedSet) visitedSet.add(sceneId);
            const li = document.createElement('li');
            li.dataset.sceneId = sceneId;
            if (collapsedState[sceneId]) li.dataset.collapsed = 'true';
            
            const sceneNode = document.createElement('div');
            sceneNode.className = 'scene-node';
            sceneNode.dataset.sceneId = sceneId;
            if (sceneId === App.state.currentSceneId) sceneNode.classList.add('active');
            
            const sceneText = scene.text || 'Empty scene';
            sceneNode.title = sceneText.split('\n')[0].substring(0, 150);

            const toggle = document.createElement('span');
            toggle.className = 'tree-toggle';
            const hasChoices = scene.choices && scene.choices.length > 0;
            if (hasChoices) {
                toggle.textContent = li.dataset.collapsed === 'true' ? '[+]' : '[-]';
                toggle.onclick = (e) => { e.stopPropagation(); li.dataset.collapsed = (li.dataset.collapsed === 'true' ? 'false' : 'true'); this.render(); };
            } else { toggle.classList.add('empty'); }

            const iconsDiv = document.createElement('div');
            iconsDiv.className = 'scene-node-icons';
            
            let iconsHTML = '';
            if (App.state.orphanSceneIds.has(sceneId)) iconsHTML += this.ICONS.orphan;
            if (sceneId === App.state.storyData.meta.startSceneId) iconsHTML += this.ICONS.start;
            if (scene.image) iconsHTML += this.ICONS.image;
            if (scene.ambienceSound) iconsHTML += this.ICONS.sound;
            if (!hasChoices) iconsHTML += this.ICONS.deadEnd;
            iconsDiv.innerHTML = iconsHTML;

            const text = document.createElement('span'); 
            text.className = 'scene-node-text';
            text.textContent = sceneId;

            sceneNode.appendChild(toggle); 
            sceneNode.appendChild(iconsDiv);
            sceneNode.appendChild(text);

            sceneNode.onclick = () => App.ui.selectScene(sceneId);
            sceneNode.oncontextmenu = (e) => {
                e.preventDefault(); App.state.contextSceneId = sceneId;
                const menu = App.elements['tree-context-menu'];
                menu.style.display = 'block'; menu.style.left = `${e.pageX}px`; menu.style.top = `${e.pageY}px`;
            };
            li.appendChild(sceneNode);
            if (path.includes(sceneId)) {
                li.querySelector('.scene-node').appendChild(document.createElement('span')).textContent = ' (LOOP)';
                parentElement.appendChild(li); return;
            }

            path.push(sceneId); // Add current scene to path for children
            if (hasChoices && li.dataset.collapsed !== 'true') {
                const childUl = document.createElement('ul');
                const choiceColor = this.getColorForScene(sceneId);
                childUl.style.borderLeftColor = choiceColor;

                scene.choices.forEach(choice => {
                    const choiceLi = document.createElement('li');
                    choiceLi.className = 'choice-node';
                    choiceLi.style.setProperty('--choice-color', choiceColor);

                    const choiceTextSpan = document.createElement('span');
                    choiceTextSpan.className = 'choice-node-text';
                    choiceTextSpan.textContent = `"${choice.text}"`;
                    choiceLi.appendChild(choiceTextSpan);
                    childUl.appendChild(choiceLi);
                    this.buildNode(choice.target, childUl, path, collapsedState, visitedSet);
                });
                li.appendChild(childUl);
            }
            path.pop(); // Remove current scene from path before returning

            parentElement.appendChild(li);
        },
        createNewScene() {
            let newId = prompt("Enter a unique ID for the new scene:");
            if (!newId) return;
            newId = newId.trim().replace(/\s+/g, '_');
            if (!newId.length) return;
            while (App.state.storyData.scenes[newId]) {
                newId = prompt(`Scene ID "${newId}" already exists. Please enter a different one:`);
                if (!newId) return;
                newId = newId.trim().replace(/\s+/g, '_');
                if (!newId.length) return;
            }
            App.state.storyData.scenes[newId] = { id: newId, text: `This is the new scene '${newId}'.`, choices: [], ambienceLoop: true, lastModified: Date.now() };
            App.setDirty(true);
            App.ui.invalidateNavViews();
            App.ui.setViewMode(App.state.currentNavView);
            App.ui.selectScene(newId);
        },
        renameScene() {
            const oldId = App.state.currentSceneId;
            if (!oldId) { App.ui.showNotification("No scene selected to rename."); return; }
            let newId = prompt("Enter the new ID for this scene:", oldId);
            if (!newId || newId === oldId) return;
            newId = newId.trim().replace(/\s+/g, '_');
            if (!newId.length) return;
            if (App.state.storyData.scenes[newId]) { App.ui.showNotification(`Scene ID "${newId}" already exists.`); return; }

            const sceneData = App.state.storyData.scenes[oldId];
            sceneData.id = newId; 
            sceneData.lastModified = Date.now();
            App.state.storyData.scenes[newId] = sceneData;
            delete App.state.storyData.scenes[oldId];

            Object.values(App.state.storyData.scenes).forEach(scene => {
                if(scene.choices) {
                    scene.choices.forEach(choice => {
                        if (choice.target === oldId) choice.target = newId;
                    });
                }
            });

            if (App.state.storyData.meta.startSceneId === oldId) {
                App.state.storyData.meta.startSceneId = newId;
            }
            
            App.state.currentSceneId = newId;
            App.setDirty(true);
            App.ui.invalidateNavViews();
            App.ui.setViewMode(App.state.currentNavView);
            App.editor.render();
        },
        deleteCurrentScene() {
            const sceneId = App.state.currentSceneId;
            if (!sceneId) { App.ui.showNotification("No scene selected to delete."); return; }
            if (sceneId === App.state.storyData.meta.startSceneId) { App.ui.showNotification("Cannot delete the start scene. Set another scene as the start scene first."); return; }
            if (!confirm(`Are you sure you want to permanently delete scene "${sceneId}"? This cannot be undone.`)) return;

            delete App.state.storyData.scenes[sceneId];
            Object.values(App.state.storyData.scenes).forEach(scene => {
                if(scene.choices) {
                     scene.choices.forEach(choice => {
                        if (choice.target === sceneId) choice.target = '';
                    });
                }
            });
            
            App.setDirty(true);
            const nextSceneId = App.state.storyData.meta.startSceneId;
            App.state.currentSceneId = null; // Unset current so selectScene forces a render
            App.ui.invalidateNavViews();
            App.ui.setViewMode(App.state.currentNavView);
            App.ui.selectScene(nextSceneId);
        },
        setAsStartScene() {
            if (App.state.contextSceneId) {
                App.state.storyData.meta.startSceneId = App.state.contextSceneId;
                App.setDirty(true);
                App.ui.invalidateNavViews();
                App.ui.setViewMode(App.state.currentNavView);
            }
        }
    },

    editor: {
        render() { 
            const scene = App.state.storyData.scenes[App.state.currentSceneId]; 
            const meta = App.state.storyData.meta;
            const editorPanel = document.getElementById('editor-panel'); 
            const previewWrapper = App.elements['scene-editor-preview-wrapper'];

            if (!scene) { 
                editorPanel.style.display = 'none'; 
                if(previewWrapper) previewWrapper.style.display = 'none';
                return; 
            } 
            editorPanel.style.display = 'block'; 
            if(previewWrapper) previewWrapper.style.display = 'block';

            App.elements['scene-id'].value = App.state.currentSceneId; 
            App.elements['scene-text'].value = scene.text || ''; 
            App.elements['choices-container'].innerHTML = ''; 
            (scene.choices || []).forEach(choice => this.addChoiceToDOM(choice)); 
            App.elements['scene-image'].value = scene.image || ''; 
            App.ui.updateImageThumbnail(scene.image); 
            App.elements['scene-image-prompt'].value = scene.imagePrompt || ''; 
            
            const soundInput = App.elements['scene-sound'];
            soundInput.value = scene.ambienceSound || ''; 
            const hasSound = !!soundInput.value;
            const playBtn = App.elements['toggle-ambience-btn'];
            playBtn.classList.toggle('btn-success', hasSound);
            playBtn.classList.toggle('btn-secondary', !hasSound);
            
            const loopBtn = App.elements['toggle-loop-btn'];
            const shouldLoop = scene.ambienceLoop ?? true;
            loopBtn.classList.toggle('active', shouldLoop);

            App.ui.updateAiImagePreview(null); 
            App.state.aiImageUrl = null; 
            App.elements['creator-name'].value = meta.creatorName || '';
            App.elements['about-text'].value = meta.aboutText || '';

            this.renderPreview();
        },
        async renderPreview() {
            const previewContainer = App.elements['scene-editor-preview'];
            const previewWrapper = App.elements['scene-editor-preview-wrapper'];
            if (!previewContainer || !previewWrapper || previewWrapper.style.display === 'none') return;

            const textEl = document.getElementById('preview-player-text');
            const choicesEl = document.getElementById('preview-player-choices');
            const imageEl = document.getElementById('preview-player-image');
            const imageContainerEl = document.getElementById('preview-player-image-container');
            const innerContainer = document.getElementById('preview-player-inner-container');

            const sceneText = App.elements['scene-text'].value;
            const sceneImage = App.elements['scene-image'].value;
            const choices = Array.from(App.elements['choices-container'].querySelectorAll('.choice-group')).map(div => ({
                text: div.querySelector('input[type=text]').value,
                target: div.querySelector('select').value
            }));

            App.styles.applyToContainer(previewContainer);

            textEl.textContent = sceneText;
            choicesEl.innerHTML = '';
            choices.forEach(choice => {
                if (choice.text) {
                    const button = document.createElement('button');
                    button.className = 'choice-btn';
                    button.textContent = choice.text;
                    choicesEl.appendChild(button);
                }
            });
            
            const meta = App.state.storyData.meta;
            const styles = meta.styles;
            const sceneImageUrl = await App.io.getAssetDataUrl(sceneImage);
            const globalScreenBgUrl = await App.io.getAssetDataUrl(styles['--screen-bg-image']);
            const containerBgUrl = await App.io.getAssetDataUrl(styles['--container-bg-image']);

            innerContainer.style.backgroundImage = containerBgUrl ? `url("${containerBgUrl}")` : 'none';

            if (meta.layout === 'layout-image-as-bg') {
                imageContainerEl.style.display = 'none';
                previewContainer.style.backgroundImage = sceneImageUrl ? `url("${sceneImageUrl}")` : (globalScreenBgUrl ? `url("${globalScreenBgUrl}")` : 'none');
            } else {
                previewContainer.style.backgroundImage = globalScreenBgUrl ? `url("${globalScreenBgUrl}")` : 'none';
                if (sceneImageUrl) {
                    imageEl.src = sceneImageUrl;
                    imageContainerEl.style.display = 'block';
                } else {
                    imageContainerEl.style.display = 'none';
                }
            }
        },
        saveCurrentScene(showAlert = false) {
            if (!App.state.currentSceneId) return;
            const id = App.state.currentSceneId;
            const scene = App.state.storyData.scenes[id];
            if (!scene) return;
        
            const originalData = {
                text: scene.text || '',
                image: scene.image || '',
                imagePrompt: scene.imagePrompt || '',
                ambienceSound: scene.ambienceSound || '',
                ambienceLoop: scene.ambienceLoop ?? true,
                choices: JSON.stringify(scene.choices || [])
            };
        
            const newChoices = Array.from(App.elements['choices-container'].querySelectorAll('.choice-group')).map(div => ({
                text: div.querySelector('input[type=text]').value,
                target: div.querySelector('select').value
            }));
            const newData = {
                text: App.elements['scene-text'].value,
                image: App.elements['scene-image'].value.trim(),
                imagePrompt: App.elements['scene-image-prompt'].value.trim(),
                ambienceSound: App.elements['scene-sound'].value.trim(),
                ambienceLoop: App.elements['toggle-loop-btn'].classList.contains('active'),
                choices: JSON.stringify(newChoices)
            };
            
            if (Object.keys(originalData).every(key => originalData[key] === newData[key])) {
                if (showAlert) {
                    console.log(`No changes detected for scene '${id}'.`);
                }
                return;
            }
        
            scene.text = newData.text;
            scene.image = newData.image;
            scene.imagePrompt = newData.imagePrompt;
            scene.ambienceSound = newData.ambienceSound;
            scene.ambienceLoop = newData.ambienceLoop;
            scene.choices = JSON.parse(newData.choices);
            scene.lastModified = Date.now();
        
            App.setDirty(true);
            App.ui.invalidateNavViews();
            App.ui.renderCurrentView();
        
            if (showAlert) {
                console.log(`Scene '${id}' changes saved to memory and view updated.`);
            }
         },
        addChoiceToDOM(choice = { text: '', target: '' }) { 
            const choiceDiv = document.createElement('div'); 
            choiceDiv.className = 'form-group inline choice-group'; 
            const textInput = document.createElement('input'); 
            textInput.type = 'text'; 
            textInput.placeholder = 'Choice text'; 
            textInput.value = choice.text; 
            const targetSelect = document.createElement('select'); 
            const defaultOption = document.createElement('option'); 
            defaultOption.value = ''; 
            defaultOption.textContent = '-- Select Target --'; 
            targetSelect.appendChild(defaultOption); 
            Object.keys(App.state.storyData.scenes || {}).sort().forEach(id => { 
                const option = document.createElement('option');
                const scene = App.state.storyData.scenes[id];
                const sceneText = scene.text || 'Empty scene';
                option.title = sceneText.split('\n')[0].substring(0, 150);
                option.value = id; 
                option.textContent = id; 
                if (id === choice.target) option.selected = true; 
                targetSelect.appendChild(option); 
            }); 
            const goToBtn = document.createElement('button');
            goToBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/></svg>`;
            goToBtn.className = 'btn-success';
            goToBtn.title = "Go to selected scene";
            goToBtn.style.padding = '8px';
            goToBtn.style.lineHeight = 1;
            goToBtn.onclick = () => { const targetScene = targetSelect.value; if (targetScene) App.ui.selectScene(targetScene); };
            const deleteBtn = document.createElement('button'); 
            deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg>`;
            deleteBtn.className = 'btn-danger'; 
            deleteBtn.title = "Delete Choice";
            deleteBtn.style.flexShrink = '0';
            deleteBtn.style.padding = '8px';
            deleteBtn.style.lineHeight = 1;
            deleteBtn.onclick = () => {
                choiceDiv.remove();
                this.renderPreview();
            }; 
            choiceDiv.appendChild(textInput); 
            choiceDiv.appendChild(targetSelect); 
            choiceDiv.appendChild(goToBtn);
            choiceDiv.appendChild(deleteBtn); 
            App.elements['choices-container'].appendChild(choiceDiv); 
        }
    },
    
    assets: {
        selectFile(assetType, targetInputId) {
            const fileInputId = assetType === 'images' ? 'image-file-input' : 'sound-file-input';
            const fileInput = document.getElementById(fileInputId);
            fileInput.onchange = (e) => this.handleLocalFileSelect(e, assetType, targetInputId);
            fileInput.click();
        },
        handleLocalFileSelect(event, assetTypeFolder, targetInputId) {
            const file = event.target.files[0]; if (!file) return;
            const destinationPath = `${assetTypeFolder}/${file.name}`;
            App.state.pendingAssetCopies.set(destinationPath, file);
            const inputElement = document.getElementById(targetInputId);
            if (inputElement) {
                inputElement.value = destinationPath;
                inputElement.dispatchEvent(new Event('input', { bubbles: true })); 
                if (targetInputId === 'scene-image') App.ui.updateImageThumbnail(destinationPath);
            }
            App.setDirty(true);
            event.target.value = '';
        },
        handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            e.target.classList.add('drag-over');
        },
        handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            e.target.classList.remove('drag-over');
        },
        handleFileDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            const targetInput = e.target;
            targetInput.classList.remove('drag-over');
            
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                const file = e.dataTransfer.files[0];
                const assetTypeFolder = targetInput.dataset.assetType || 'assets';
                const destinationPath = `${assetTypeFolder}/${file.name}`;

                App.state.pendingAssetCopies.set(destinationPath, file);
                targetInput.value = destinationPath;
                targetInput.dispatchEvent(new Event('input', { bubbles: true })); 
                if (targetInput.id === 'scene-image') App.ui.updateImageThumbnail(destinationPath);

                App.setDirty(true);
            }
        },
        renderPollinationImage() {
            const promptText = App.elements['scene-image-prompt'].value.trim();
            if (!promptText) { App.ui.showNotification("Please enter a prompt first."); return; }
            
            App.state.aiImageUrl = null; 
            App.ui.updateAiImagePreview(null, 'Rendering...');

            const layout = App.state.storyData.meta.layout;
            let urlSuffix = '';
            if (layout === 'layout-side-by-side') {
                urlSuffix = '&width=1024&height=1024';
            } else if (layout === 'layout-top-down' || layout === 'layout-image-as-bg') {
                urlSuffix = '&width=1280&height=720';
            }

            const randomSeed = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
            const url = "https://image.pollinations.ai/prompt/" + encodeURIComponent(promptText) + `?seed=${randomSeed}&safe=true&nologo=true&enhance=true&model=flux` + urlSuffix;
            
            const tempImg = new Image();
            tempImg.onload = () => {
                App.state.aiImageUrl = url;
                App.ui.updateAiImagePreview(url);
            };
            tempImg.onerror = () => { 
                App.ui.updateAiImagePreview(null, 'Render failed.'); 
                App.state.aiImageUrl = null; 
            };
            tempImg.src = url;
        },
        async addPollinationImageToScene() {
            if (!App.state.aiImageUrl) {
                App.ui.showNotification("Please render an image first.");
                return;
            }
            App.ui.updateAiImagePreview(null, 'Downloading...');
            try {
                const urlToFetch = App.state.aiImageUrl + '&t=' + Date.now();
                const response = await fetch(urlToFetch);

                if (!response.ok) throw new Error(`Fetch failed: ${response.statusText}`);
                const imageBlob = await response.blob();
                
                const filename = `${App.state.currentSceneId || 'image'}_${Date.now()}.jpg`;
                const destinationPath = `images/${filename}`;

                App.state.pendingAssetCopies.set(destinationPath, imageBlob);
                App.elements['scene-image'].value = destinationPath;
                App.ui.updateImageThumbnail(destinationPath);
                App.elements['scene-image'].dispatchEvent(new Event('input', { bubbles: true }));
                App.setDirty(true);
                App.editor.saveCurrentScene(false);
                App.ui.invalidateNavViews();
                App.ui.setViewMode(App.state.currentNavView);
            } catch (err) {
                console.error("Error adding AI image:", err);
                App.ui.showNotification("Could not download or save the image.");
                App.ui.updateAiImagePreview(App.state.aiImageUrl);
            }
        },
        async processTextWithPollinations() {
            const instruction = App.elements['pollinations-instruction'].value.trim();
            const sceneText = App.elements['scene-text'].value.trim();

            if (!instruction || !sceneText) {
                App.ui.showNotification("Both an instruction and scene text are required.");
                return;
            }

            App.modals.hide(App.elements['pollinations-text-modal']);
            App.ui.showNotification("Processing text with AI...");

            const combinedText = `${instruction}: ${sceneText}`;
            const url = "https://text.pollinations.ai/" + encodeURIComponent(combinedText);

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const htmlString = await response.text();

                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlString, 'text/html');
                const processedText = doc.body.innerText.trim();

                if (processedText) {
                    const originalText = App.elements['scene-text'].value;
                    App.elements['scene-text'].value = originalText + '\n\n' + processedText;

                    App.elements['scene-text'].dispatchEvent(new Event('input', { bubbles: true }));
                    App.setDirty(true);
                    App.ui.showNotification("Text processing complete!");
                } else {
                    throw new Error("No text found in the response from Pollinations AI.");
                }

            } catch (error) {
                console.error("Error processing text with Pollinations AI:", error);
                App.ui.showNotification("Failed to process text. Check the console for details.");
            }
        }
    },

    player: {
        async play(sceneId) {
            if (!sceneId || !App.state.storyData.scenes[sceneId]) { App.ui.showNotification("Cannot play scene. Please select a valid scene to start from."); return; }
            App.elements['player-inner-container'].style.height = 'auto';
            App.elements['editor-container'].style.display = 'none';
            App.elements['player-container'].style.display = 'flex';
            await this.renderScene(sceneId);
        },
        typeWriter(textEl, choicesEl, contentEl, text, choices, onChoiceClick) {
            let i = 0;
            choicesEl.innerHTML = '';
            
            const tempChoices = document.createElement('div');
            (choices || []).forEach(choice => {
                const button = document.createElement('button');
                button.className = 'choice-btn';
                button.textContent = choice.text;
                tempChoices.appendChild(button);
            });
            choicesEl.appendChild(tempChoices);
            textEl.textContent = text;
            const containerHeight = contentEl.offsetHeight;
            choicesEl.innerHTML = '';
            textEl.innerHTML = '';
            contentEl.style.minHeight = containerHeight + 'px';

            const showChoices = () => {
                (choices || []).forEach((choice, index) => {
                    const button = document.createElement('button');
                    button.textContent = choice.text;
                    button.className = 'choice-btn fade-in';
                    button.style.animationDelay = (index * 0.2) + 's';
                    button.onclick = (e) => { e.stopPropagation(); onChoiceClick(choice.target); };
                    choicesEl.appendChild(button);
                });
            };
            
            if (App.state.typewriter.intervalId) clearInterval(App.state.typewriter.intervalId);
            if (App.state.typewriter.skipListener) App.elements['player-inner-container'].removeEventListener('click', App.state.typewriter.skipListener);
            
            const skipTyping = () => {
                clearInterval(App.state.typewriter.intervalId);
                App.state.typewriter.intervalId = null;
                textEl.innerHTML = text;
                contentEl.style.minHeight = '';
                showChoices();
                App.elements['player-inner-container'].removeEventListener('click', App.state.typewriter.skipListener);
                App.state.typewriter.skipListener = null;
            };
            App.state.typewriter.skipListener = skipTyping;
            App.elements['player-inner-container'].addEventListener('click', skipTyping);
            
            App.state.typewriter.intervalId = setInterval(() => {
                if (i < text.length) {
                    textEl.innerHTML += text.charAt(i);
                    i++;
                } else {
                   skipTyping();
                }
            }, 30);
        },
        async renderScene(sceneId) {
            App.state.currentSceneId = sceneId;
            App.ui.setViewMode(App.state.currentNavView);

            const scene = App.state.storyData.scenes[sceneId];
            const { 'player-text': text, 'player-choices': choices, 'ambience-player': audio, 'player-inner-container': innerContainer } = App.elements;
            const contentContainer = document.getElementById('player-content-container');
            if (!scene) { text.textContent = `Error: Scene "${sceneId}" not found.`; return; }
            
            await App.styles.applyToPlayer();

            if (App.state.storyData.meta.styles['--typewriter-effect'] === 'on') {
                this.typeWriter(text, choices, contentContainer, scene.text, scene.choices, (target) => this.renderScene(target));
            } else {
                contentContainer.style.minHeight = '';
                text.textContent = scene.text;
                choices.innerHTML = '';
                (scene.choices || []).forEach(choice => { 
                    const button = document.createElement('button'); 
                    button.className = 'choice-btn'; 
                    button.textContent = choice.text; 
                    button.onclick = () => this.renderScene(choice.target); 
                    choices.appendChild(button); 
                });
            }
            
            audio.loop = scene.ambienceLoop ?? true;
            const soundUrl = await App.io.getAssetDataUrl(scene.ambienceSound);
            if (soundUrl) {
                if(audio.src !== soundUrl) audio.src = soundUrl;
                audio.play().catch(e => console.warn("Audio autoplay was blocked."));
            } else { audio.pause(); }
            
            requestAnimationFrame(() => {
                innerContainer.style.height = 'auto';
            });
        },
        stop() {
            if (App.state.typewriter.intervalId) clearInterval(App.state.typewriter.intervalId);
            if (App.state.typewriter.skipListener) App.elements['player-inner-container'].removeEventListener('click', App.state.typewriter.skipListener);
            App.state.typewriter = { intervalId: null, skipListener: null };

            App.elements['editor-container'].style.display = 'block';
            App.elements['player-container'].style.display = 'none';
            App.elements['ambience-player'].pause();
            App.elements['music-player'].pause();
            App.elements['ambience-player'].src = '';
            App.elements['music-player'].src = '';
            
            if (App.state.currentSceneId) {
                App.editor.render();
            }
        },
        async toggleAmbienceSound() {
            const audio = App.elements['ambience-player'];
            const soundPath = App.elements['scene-sound'].value;

            if (!soundPath) return;

            const scene = App.state.storyData.scenes[App.state.currentSceneId];
            if (scene) {
                audio.loop = scene.ambienceLoop ?? true;
            }

            const soundUrl = await App.io.getAssetDataUrl(soundPath);

            if (!soundUrl) {
                App.ui.showNotification("Audio file not found in project.");
                return;
            }

            const isPlayingThisSound = !audio.paused && audio.currentSrc.endsWith(soundUrl);

            if (isPlayingThisSound) {
                audio.pause();
            } else {
                audio.src = soundUrl;
                audio.play().catch(e => console.warn("Audio playback failed.", e));
            }
        },
        updateAmbienceButton(isPlaying) {
            App.elements['ambience-play-icon'].classList.toggle('hidden', isPlaying);
            App.elements['ambience-pause-icon'].classList.toggle('hidden', !isPlaying);
        }
    },
    
    styles: {
        open() {
            App.modals.hide(document.getElementById('project-menu-modal'));
            
            const sidebar = document.getElementById('tree-view-container');
            const rect = sidebar.getBoundingClientRect();
            const modalContent = document.querySelector('#style-editor-modal .modal-content');
            
            const style = getComputedStyle(sidebar);
            const scrollbarWidth = sidebar.offsetWidth - sidebar.clientWidth;

            modalContent.style.top = `${rect.top}px`;
            modalContent.style.left = `${rect.left}px`;
            modalContent.style.width = `${rect.width - scrollbarWidth}px`;
            modalContent.style.height = `${rect.height}px`;

            const grid = document.getElementById('style-editor-grid');
            const styles = App.state.storyData.meta.styles;
            const defaults = this.getDefaults();
            const layout = App.state.storyData.meta.layout;
            grid.innerHTML = `
                <div class="grid-full-width">
                    <label>Layout <select id="style-layout"><option value="layout-top-down">Image on Top</option><option value="layout-side-by-side">Image on Side</option><option value="layout-image-as-bg">Image as Background</option></select></label>
                </div>
                <div class="grid-span-2">
                    <label>Font Family <select id="style-font-family"><option value="sans-serif">Sans-Serif</option><option value="serif">Serif</option><option value="monospace">Monospace</option></select></label>
                    <label>Font Size (px) <input type="number" id="style-font-size" min="8" max="48" step="1"></label>
                </div>
                <div class="grid-span-2">
                     <label>Text Color <input type="color" id="style-text-color"></label>
                     <label>Typewriter Effect <select id="style-typewriter-effect"><option value="off">Off</option><option value="on">On</option></select></label>
                </div>

                <hr class="grid-separator">
                <label>Page BG Color <input type="color" id="style-bg-color"></label>
                <div class="grid-full-width">
                    <label>Page BG Image <div class="form-group inline" style="margin:0;"><input type="text" id="style-screen-bg-image" class="path-input" data-asset-type="images" placeholder="images/bg.jpg"><button class="btn-warning file-icon-btn" title="Select Screen Background">📁</button></div></label>
                </div>
                
                <hr class="grid-separator">
                <div class="grid-full-width">
                    <label>Container Padding (px) <input type="number" id="style-padding" min="0"></label>
                </div>
                <div class="grid-span-2">
                    <label>Container BG Color <input type="color" id="style-container-bg-color"></label>
                    <label>Container BG Opacity <input type="range" id="style-container-bg-opacity" min="0" max="1" step="0.01"></label>
                </div>
                <div class="grid-full-width">
                   <label>Container BG Image <div class="form-group inline" style="margin:0;"><input type="text" id="style-container-bg-image" class="path-input" data-asset-type="images" placeholder="images/container-bg.png"><button class="btn-warning file-icon-btn" title="Select Container Background">📁</button></div></label>
                </div>
                
                <hr class="grid-separator">
                <div class="grid-span-2">
                    <label>Button Color <input type="color" id="style-btn-color"></label>
                    <label>Button Opacity <input type="range" id="style-btn-opacity" min="0" max="1" step="0.01" value="1"></label>
                </div>
                <div class="grid-span-2">
                    <label>Button Hover Color <input type="color" id="style-btn-hover-color"></label>
                    <label>Button Text Color <input type="color" id="style-btn-text-color"></label>
                </div>


                <hr class="grid-separator">
                <div class="grid-full-width">
                    <label>Background Music <div class="form-group inline" style="margin:0;"><input type="text" id="style-music-path" class="path-input" data-asset-type="sounds" placeholder="sounds/music.mp3"><button class="btn-warning file-icon-btn" title="Select Music File">📁</button></div></label>
                </div>
                <div class="grid-span-2">
                    <label>Music Volume <input type="range" id="style-music-volume" min="0" max="1" step="0.01"></label>
                    <label>Ambience Volume <input type="range" id="style-ambience-volume" min="0" max="1" step="0.01"></label>
                </div>
            `;
            
            Object.keys(defaults).forEach(key => { 
                const el = grid.querySelector(`#style-${key.replace(/--/g, '')}`); 
                if(el) {
                    if (el.type === 'number') {
                        el.value = parseInt(styles[key] || defaults[key]);
                    } else if (el.type !== 'color') {
                         el.value = styles[key] || defaults[key];
                    }
                }
            });
            grid.querySelector('#style-layout').value = layout;

            const parseAndSetColor = (colorVar, hexInputId, opacitySliderId = null) => {
                const colorValue = styles[colorVar] || defaults[colorVar];
                const match = colorValue.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
                const toHex = c => ('0' + parseInt(c).toString(16)).slice(-2);
                
                if (match) {
                    const r = match[1], g = match[2], b = match[3];
                    const a = match[4] !== undefined ? parseFloat(match[4]) : 1;
                    grid.querySelector(`#${hexInputId}`).value = `#${toHex(r)}${toHex(g)}${toHex(b)}`;
                    if (opacitySliderId) grid.querySelector(`#${opacitySliderId}`).value = a;
                } else {
                    grid.querySelector(`#${hexInputId}`).value = colorValue;
                     if (opacitySliderId) grid.querySelector(`#${opacitySliderId}`).value = 1;
                }
            };
            
            parseAndSetColor('--bg-color', 'style-bg-color');
            parseAndSetColor('--text-color', 'style-text-color');
            parseAndSetColor('--btn-text-color', 'style-btn-text-color');
            parseAndSetColor('--container-bg-color', 'style-container-bg-color', 'style-container-bg-opacity');
            parseAndSetColor('--btn-color', 'style-btn-color', 'style-btn-opacity');
            parseAndSetColor('--btn-hover-color', 'style-btn-hover-color');


            grid.oninput = (e) => this.handleUpdate(e);

            grid.querySelectorAll('.file-icon-btn').forEach(btn => {
                const input = btn.previousElementSibling;
                btn.onclick = () => App.assets.selectFile(input.dataset.assetType, input.id);
            });
            grid.querySelectorAll('.path-input').forEach(input => {
                input.addEventListener('dragover', App.assets.handleDragOver);
                input.addEventListener('dragleave', App.assets.handleDragLeave);
                input.addEventListener('drop', App.assets.handleFileDrop);
            });
            App.modals.show('style-editor-modal'); 
        },
		handleUpdate(event) {
			const target = event.target;
			const id = target.id.replace('style-', '');
			let value = target.value;

			const hexToRgba = (h, o) => {
				const r = parseInt(h.slice(1, 3), 16), g = parseInt(h.slice(3, 5), 16), b = parseInt(h.slice(5, 7), 16);
				return `rgba(${r}, ${g}, ${b}, ${o})`;
			};

			if (target.id === 'style-container-bg-color' || target.id === 'style-container-bg-opacity') {
				const hex = document.getElementById('style-container-bg-color').value;
				const opacity = document.getElementById('style-container-bg-opacity').value;
				App.state.storyData.meta.styles['--container-bg-color'] = hexToRgba(hex, opacity);
			} else if (['btn-color', 'btn-hover-color', 'btn-opacity'].includes(id)) {
				const hex = document.getElementById('style-btn-color').value;
				const hoverHex = document.getElementById('style-btn-hover-color').value;
				const opacity = document.getElementById('style-btn-opacity').value;
				App.state.storyData.meta.styles['--btn-color'] = hexToRgba(hex, opacity);
				App.state.storyData.meta.styles['--btn-hover-color'] = hexToRgba(hoverHex, opacity);
			}
			else if (id === 'layout') { App.state.storyData.meta.layout = value; } 
			else {
				if (target.type === 'number') value += 'px';
				App.state.storyData.meta.styles[`--${id}`] = value;
			}
			
			// Live-update the editor's audio players' volume
			if (id === 'music-volume') {
				App.elements['music-player'].volume = parseFloat(target.value);
			} else if (id === 'ambience-volume') {
				App.elements['ambience-player'].volume = parseFloat(target.value);
			}
			
			App.setDirty(true);
			if (App.elements['player-container'].style.display === 'flex') App.player.renderScene(App.state.currentSceneId);
			if (App.elements['editor-fieldset'].disabled === false) App.editor.renderPreview();
		},
        applyToContainer(container) {
            const meta = App.state.storyData.meta;
            const styles = meta.styles;
            const defaults = this.getDefaults();
            const innerContainer = container.querySelector('#preview-player-inner-container') || container.querySelector('#player-inner-container');

            Object.keys(defaults).forEach(key => {
                if (key.startsWith('--')) {
                    const value = styles[key] || defaults[key];
                    container.style.setProperty(key, value);
                }
            });
            container.className = meta.layout;
            if(innerContainer) innerContainer.className = meta.layout;
        },
        async applyToPlayer() {
            const pc = App.elements['player-container'];
            const pic = App.elements['player-inner-container'];
            const musicPlayer = App.elements['music-player'];
            const imageContainer = document.getElementById('player-image-container');
            const playerImage = App.elements['player-image'];
            const scene = App.state.storyData.scenes[App.state.currentSceneId];
            const meta = App.state.storyData.meta;
            const styles = meta.styles;
            
            this.applyToContainer(pc);

            const imageUrl = await App.io.getAssetDataUrl(scene?.image);
            const globalScreenBgUrl = await App.io.getAssetDataUrl(styles['--screen-bg-image']);

            if (meta.layout === 'layout-image-as-bg') {
                imageContainer.style.display = 'none';
                pc.style.backgroundImage = imageUrl ? `url("${imageUrl}")` : (globalScreenBgUrl ? `url("${globalScreenBgUrl}")` : 'none');
            } else {
                pc.style.backgroundImage = globalScreenBgUrl ? `url("${globalScreenBgUrl}")` : 'none';
                if (imageUrl) {
                    playerImage.src = imageUrl;
                    imageContainer.style.display = 'block';
                } else {
                    imageContainer.style.display = 'none';
                }
            }
            
            const containerBgUrl = await App.io.getAssetDataUrl(styles['--container-bg-image']);
            pic.style.backgroundImage = containerBgUrl ? `url("${containerBgUrl}")` : 'none';
            
            const musicUrl = await App.io.getAssetDataUrl(styles['--music-path']);
            if (musicUrl) {
                if (!musicPlayer.src.endsWith(musicUrl)) { musicPlayer.src = musicUrl; }
                if (musicPlayer.paused) { musicPlayer.play().catch(e => console.warn("Music autoplay blocked by browser."));}
            } else {
                musicPlayer.pause();
                musicPlayer.src = '';
            }
        },
        generateCSS(stylesOverride = null) { 
            const styles = stylesOverride || App.state.storyData.meta.styles;
            const defaults = this.getDefaults();
            let rootVars = '';

            Object.keys(defaults).forEach(key => {
                if (key.startsWith('--') && !key.includes('path') && !key.includes('image')) {
                    const value = styles[key] || defaults[key];
                    rootVars += `    ${key}: ${value};\n`;
                }
            });

            let css = `
:root {\n${rootVars}}
body {
    background-color: var(--bg-color);
    color: var(--text-color);
    font-family: var(--font-family, sans-serif);
}
#game-container {
    background-color: var(--container-bg-color);
    font-size: var(--font-size);
}
.choice-btn {
    background-color: var(--btn-color);
    color: var(--btn-text-color);
    border: 1px solid transparent;
}
.choice-btn:hover {
    background-color: var(--btn-hover-color);
}
`;
            if (styles['--screen-bg-image']) {
                css += `body { background-image: url('${styles['--screen-bg-image']}'); }\n`;
            }
            if (styles['--container-bg-image']) {
                css += `#game-container { background-image: url('${styles['--container-bg-image']}'); }\n`;
            }
            return css;
        },
        getDefaults() { return { '--bg-color': '#212529', '--text-color': '#f8f9fa', '--btn-color': 'rgba(108, 117, 125, 1)', '--btn-text-color': '#ffffff', '--btn-hover-color': 'rgba(90, 98, 104, 1)', '--font-family': 'sans-serif', '--font-size': '16px', '--padding': '30px', '--screen-bg-image': '', '--container-bg-image': '', '--container-bg-color': 'rgba(0,0,0,0.15)', '--music-path': '', '--music-volume': '0.4', '--ambience-volume': '0.4', '--typewriter-effect': 'on' }; }
    },
    
    modals: {
        show(modalId) { document.getElementById(modalId).classList.add('visible'); },
        hide(modal) {
            if (modal) {
                if (modal.id === 'batch-image-modal' && App.batch.isGenerating) {
                    App.batch.logInfo("Cannot close panel while generation is running. Please Abort first.");
                    return;
                }
                modal.classList.remove('visible');
            }
        },
        hideAll() { document.querySelectorAll('.modal').forEach(m => this.hide(m)); }
    },
    
    batch: {
        isGenerating: false,
        abortRequested: false,

        open() {
            App.modals.hide(document.getElementById('project-menu-modal'));

            const sidebar = document.getElementById('tree-view-container');
            const rect = sidebar.getBoundingClientRect();
            const modalContent = document.querySelector('#batch-image-modal .modal-content');
            
            const style = getComputedStyle(sidebar);
            const scrollbarWidth = sidebar.offsetWidth - sidebar.clientWidth;

            modalContent.style.top = `${rect.top}px`;
            modalContent.style.left = `${rect.left}px`;
            modalContent.style.width = `${rect.width - scrollbarWidth}px`;
            modalContent.style.height = `${rect.height}px`;

            App.modals.show('batch-image-modal');
        },

        logInfo(message) {
            const logEl = document.getElementById('batch-info-log');
            const timestamp = new Date().toLocaleTimeString();
            logEl.textContent += `[${timestamp}] ${message}\n`;
            logEl.scrollTop = logEl.scrollHeight;
        },

        removeAllImages() {
            App.editor.saveCurrentScene(false);
            if (!confirm("Are you sure you want to delete the image paths from ALL scenes? This cannot be undone.")) return;
            
            let count = 0;
            Object.values(App.state.storyData.scenes).forEach(scene => {
                if (scene.image) {
                    scene.image = '';
                    count++;
                }
            });

            App.setDirty(true);
            App.editor.render(); 
            App.ui.invalidateNavViews();
            App.ui.setViewMode(App.state.currentNavView);
            App.ui.showNotification(`${count} image paths have been deleted.`);
        },

        removeAllImagePrompts() {
            App.editor.saveCurrentScene(false);
            if (!confirm("Are you sure you want to delete the image prompts from ALL scenes? This cannot be undone.")) return;
            let count = 0;
            Object.values(App.state.storyData.scenes).forEach(scene => {
                if (scene.imagePrompt) {
                    scene.imagePrompt = '';
                    count++;
                }
            });
            App.setDirty(true);
            App.editor.render(); 
            App.ui.showNotification(`${count} image prompts have been deleted.`);
        },

        async startGeneration() {
            if (this.isGenerating) {
                this.abortRequested = true;
                this.logInfo("Abort requested. Finishing current operation...");
                document.getElementById('batch-generate-btn').disabled = true;
                return;
            }
            
            const rewritePrompt = document.getElementById('batch-rewrite-prompt-checkbox').checked;
            const overwriteExisting = document.getElementById('batch-overwrite-checkbox').checked;

            if (overwriteExisting) {
                let confirmMessage = "This will overwrite existing images for all scenes with prompts.";
                if (rewritePrompt) {
                    confirmMessage = "This will overwrite existing prompts and images for all scenes.";
                }
                if (!confirm(confirmMessage + "\n\nAre you sure you want to continue?")) {
                    this.logInfo("Overwrite operation cancelled by user.");
                    return; 
                }
            }

            App.editor.saveCurrentScene(false);

            this.isGenerating = true;
            this.abortRequested = false;

            const generateBtn = document.getElementById('batch-generate-btn');
            const fieldset = document.getElementById('batch-fieldset');
            const logEl = document.getElementById('batch-info-log');
            
            logEl.textContent = ''; 
            this.logInfo("Starting batch generation...");
            
            fieldset.disabled = true;
            generateBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5zM4 5a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4z"/></svg> <span>Abort</span>`;

            const suffix = document.getElementById('batch-suffix-input').value.trim();
            const cooldown = parseInt(document.getElementById('batch-cooldown-input').value, 10) * 1000;
            
            const sceneIds = Object.keys(App.state.storyData.scenes);
            let generatedCount = 0;

            for (const sceneId of sceneIds) {
                if (this.abortRequested) break;
                
                const scene = App.state.storyData.scenes[sceneId];
                this.logInfo(`--- Processing scene: ${sceneId} ---`);

                if (scene.image && !overwriteExisting) {
                    this.logInfo("Scene already has an image. Skipping (Overwrite is off).");
                    continue;
                }
                
                let prompt = scene.imagePrompt;

                if (rewritePrompt) {
                    if (!prompt || overwriteExisting) {
                        this.logInfo("AI rewrite enabled. Generating new prompt from scene text...");
                        const newPrompt = await this.generatePromptForScene(scene);
                        if (newPrompt) {
                            prompt = newPrompt;
                            scene.imagePrompt = prompt; 
                            App.setDirty(true);
                            this.logInfo(`New prompt: "${prompt}"`);
                        } else {
                            this.logInfo("Failed to generate prompt from text. Using existing prompt if available.");
                        }
                    } else {
                        this.logInfo("Using existing prompt (AI Rewrite is on, but Overwrite is off).");
                    }
                }

                if (!prompt) {
                    this.logInfo("Scene has no prompt to generate from. Skipping.");
                    continue;
                }
                
                const success = await this.generateAndSaveImage(sceneId, scene, prompt, suffix);
                if (!success) {
                    this.logInfo("An error occurred during image generation. ABORTING PROCESS.");
                    break; 
                }
                
                App.ui.selectScene(sceneId);
                
                generatedCount++;

                if (this.abortRequested) break;
                if (cooldown > 0) {
                    this.logInfo(`Cooldown: Waiting ${cooldown / 1000}s...`);
                    await new Promise(resolve => setTimeout(resolve, cooldown));
                }
            }

            this.logInfo("-----------------------------------");
            if (this.abortRequested) this.logInfo("Batch process aborted by user.");
            this.logInfo(`Finished. Generated ${generatedCount} new images.`);
            if (generatedCount > 0) {
                this.logInfo("IMPORTANT: Remember to Save Project to write the new images to disk!");
            }
            
            this.isGenerating = false;
            this.abortRequested = false;
            fieldset.disabled = false;
            generateBtn.disabled = false;
            generateBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M7.657 6.247c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937zM3.794 1.148c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937z"/></svg> <span>Generate</span>`;
            
            App.editor.render();
            App.ui.invalidateNavViews();
            App.ui.setViewMode(App.state.currentNavView);
        },
        
        async generatePromptForScene(scene) {
            if (!scene.text) return null;
            const instruction = "Analyze the text like a cinematographer. Create a vivid, cinematic image prompt. Structure: camera angle, subject, action, setting, location, year, lighting, colors, mood. Combine related details into evocative concepts. Output as comma-separated nouns and adjectives. No labels in the result.";
            const combinedText = `${instruction}: ${scene.text}`;
            const url = "https://text.pollinations.ai/" + encodeURIComponent(combinedText);
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const htmlString = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlString, 'text/html');
                const processedText = doc.body.innerText.trim();
                return processedText || null;
            } catch (error) {
                console.error("Error generating prompt:", error);
                this.logInfo(`Error generating prompt: ${error.message}`);
                return null;
            }
        },

        async generateAndSaveImage(sceneId, scene, prompt, suffix) {
            const fullPrompt = (prompt + ' ' + suffix).trim();
            this.logInfo(`Generating image with prompt: "${fullPrompt}"`);
            
            const layout = App.state.storyData.meta.layout;
            let urlSuffix = '&width=1024&height=1024'; 
            if (layout === 'layout-top-down' || layout === 'layout-image-as-bg') {
                urlSuffix = '&width=1280&height=720';
            }
            const randomSeed = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
            const url = "https://image.pollinations.ai/prompt/" + encodeURIComponent(fullPrompt) + `?seed=${randomSeed}&safe=true&nologo=true&enhance=true&model=flux` + urlSuffix;
            
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Fetch failed: ${response.status} ${response.statusText}`);
                const imageBlob = await response.blob();
                const filename = `${sceneId}_${Date.now()}.jpg`;
                const destinationPath = `images/${filename}`;
                
                App.state.pendingAssetCopies.set(destinationPath, imageBlob);
                scene.image = destinationPath;
                App.setDirty(true);
                
                this.logInfo(`Image successfully generated and saved to path: ${destinationPath}`);
                return true;
            } catch (err) {
                console.error("Error generating/saving AI image:", err);
                this.logInfo(`Error: ${err.message}`);
                return false;
            }
        },

                async exportExeWithConcatenation({ iconBlob = null, logCallback = () => {} }) {
            logCallback('Using simplified export (file concatenation).');
            logCallback('Note: This method is fast but may not work on other PCs. For a distributable game, manually select a full NW.js folder.');
            
            const safeTitle = App.state.storyData.meta.title.replace(/[^a-z0-9]/gi, '_').toLowerCase();

            // 1. Create the package.nw zip
            logCallback('Creating game data package (package.nw)...');
            const appZip = new window.JSZip();
            appZip.file('index.html', await App.io.getFormattedPlayerHTML(true));

            const usedAssetPaths = new Set();
            Object.values(App.state.storyData.scenes).forEach(scene => {
                if (scene.image) usedAssetPaths.add(scene.image);
                if (scene.ambienceSound) usedAssetPaths.add(scene.ambienceSound);
            });
            const metaStyles = App.state.storyData.meta.styles;
            if (metaStyles['--screen-bg-image']) usedAssetPaths.add(metaStyles['--screen-bg-image']);
            if (metaStyles['--container-bg-image']) usedAssetPaths.add(metaStyles['--container-bg-image']);
            if (metaStyles['--music-path']) usedAssetPaths.add(metaStyles['--music-path']);

            for (const path of usedAssetPaths) { try { const f = await App.io.getAssetFile(path); if (f) appZip.file(path, f); } catch {} }
            
            let iconPath = '';
            if (iconBlob) {
                logCallback('-> Processing window icon...');
                const pngBlob = await (async () => {
                    const bmp = await createImageBitmap(iconBlob);
                    const canvas = document.createElement('canvas');
                    canvas.width = 256; canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(bmp, 0, 0, 256, 256);
                    return await new Promise(res => canvas.toBlob(res, 'image/png'));
                })();
                iconPath = 'icon.png';
                appZip.file(iconPath, pngBlob);
            }
            
            const packageJson = {
                name: safeTitle,
                main: 'index.html',
                window: { title: App.state.storyData.meta.title, width: 1280, height: 720, resizable: true, icon: iconPath || undefined }
            };
            appZip.file('package.json', JSON.stringify(packageJson, null, 2));

            const packageNwBlob = await appZip.generateAsync({ type: 'blob', compression: 'DEFLATE' });
            logCallback('-> Game data package complete.');
            
            // 2. Fetch nw.exe from the app's relative folder
            logCallback('Fetching nw.exe from local ./nwjs/ folder...');
            const nwExeResponse = await fetch('./nwjs/nw.exe');
            if (!nwExeResponse.ok) {
                throw new Error("Failed to fetch './nwjs/nw.exe'. Make sure the folder and file exist next to your main HTML file.");
            }
            const nwExeBlob = await nwExeResponse.blob();
            logCallback('-> nw.exe fetched.');

            // 3. Concatenate and Download
            logCallback('Combining files into final executable...');
            const finalExeBlob = new Blob([nwExeBlob, packageNwBlob], { type: 'application/vnd.microsoft.portable-executable' });

            const a = document.createElement('a');
            a.href = URL.createObjectURL(finalExeBlob);
            a.download = `${safeTitle}.exe`;
            a.click();
            URL.revokeObjectURL(a.href);
            logCallback('SUCCESS: Download initiated.');
        },
    }
};

document.addEventListener('DOMContentLoaded', () => App.init());

// Export EXE Modal wiring
(function wireExportExeModal(){
    const exportModal = document.getElementById('export-exe-modal');
    if (!exportModal) return;

    const iconPreview = document.getElementById('export-icon-preview');
    const iconInput = document.getElementById('export-icon-file-input');
    const nwPathInput = document.getElementById('export-nw-path');
    const logOutput = document.getElementById('export-exe-log');
    const runBtn = document.getElementById('export-exe-run-btn');

    let selectedIconBlob = null;
    let selectedNwFolder = null;

    function log(message) {
        if (logOutput) {
            logOutput.textContent += message + '\n';
            logOutput.scrollTop = logOutput.scrollHeight;
        }
        console.log(message);
    }

    // Reset the modal's state when it becomes visible
    const observer = new MutationObserver(() => {
        if (exportModal.classList.contains('visible')) {
            // Reset state for a clean open
            runBtn.disabled = false;
            runBtn.textContent = 'Export';
            selectedIconBlob = null;
            selectedNwFolder = null;
            nwPathInput.value = '';
            iconPreview.innerHTML = '<span>Icon (Optional)</span>';
            
            // Provide clear instructions to the user
            logOutput.textContent = 'Welcome to the exporter.\n';
            log('Due to browser security, you must manually select your NW.js folder.\n');
            log('Please select the folder containing nw.exe to begin.');
        }
    });
    observer.observe(exportModal, { attributes: true, attributeFilter: ['class'] });

    function updateIconPreviewFromBlob(blob){
        const url = URL.createObjectURL(blob);
        iconPreview.innerHTML = '';
        const img = document.createElement('img');
        img.src = url;
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'contain';
        img.onload = () => URL.revokeObjectURL(url);
        iconPreview.appendChild(img);
    }

    document.getElementById('select-export-icon-btn')?.addEventListener('click', () => iconInput.click());
    iconInput?.addEventListener('change', () => {
        const f = iconInput.files && iconInput.files[0];
        if (f) { selectedIconBlob = f; updateIconPreviewFromBlob(f); }
    });

    // This is the primary action for the user.
    document.getElementById('select-nw-btn')?.addEventListener('click', async () => {
        try {
            const dir = await window.showDirectoryPicker({ mode: 'read' });
            await dir.getFileHandle('nw.exe'); // Verify it contains the executable
            selectedNwFolder = dir;
            nwPathInput.value = dir.name; // Display the selected folder name
            log(`NW.js folder selected: ${dir.name}. Ready to export.`);
        } catch (err) {
            if (err.name !== 'AbortError') {
                log('ERROR: The selected folder must contain nw.exe.');
                App.ui.showNotification('Invalid Folder: The selected directory must contain the nw.exe file.');
            }
        }
    });

    runBtn?.addEventListener('click', async () => {
        // Save any pending changes to the current scene before exporting
        App.editor.saveCurrentScene(false);
        
        if (!selectedNwFolder) {
            log('Export failed: Please manually select a valid NW.js folder first.');
            App.ui.showNotification('Please select your NW.js folder before exporting.');
            return;
        }

        runBtn.disabled = true;
        runBtn.textContent = 'Exporting...';
        logOutput.textContent = ''; // Clear log for the new run

        try {
            // Call the one reliable exporter function
            await App.io.exportStandaloneWithOptions({
                nwFolder: selectedNwFolder,
                iconBlob: selectedIconBlob,
                logCallback: log
            });
            
            // On success, wait a moment then close the modal
            setTimeout(() => {
                App.modals.hide(exportModal);
            }, 3000);

        } catch (e) {
            log(`FATAL ERROR: ${e.message}`);
            App.ui.showNotification(`Export Failed: ${e.message}`);
            runBtn.disabled = false;
            runBtn.textContent = 'Export';
        }
    });

    document.getElementById('nw-download-btn')?.addEventListener('click', () => {
        window.open('https://nwjs.io/downloads/', '_blank');
    });
})();
</script>
</body>
</html>
